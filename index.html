<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>ë³´ìŠ¤ê²Œì´íŠ¸ (BOSS GATE)</title>
  <link rel="stylesheet" href="./style.css" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
</head>

<body>
  <div id="wrap">
    <div id="stage">
      <canvas id="game" width="960" height="540"></canvas>
    </div>
  </div>

  <!-- âœ… í„°ì¹˜ ë²„íŠ¼(ë·°í¬íŠ¸ fixed) -->
  <div id="touch" aria-hidden="true">
    <div class="btn" id="b-left" data-k="left">â—€</div>
    <div class="btn" id="b-right" data-k="right">â–¶</div>

    <div class="btn" id="b-jump" data-k="jump">â¤’</div>
    <div class="btn" id="b-potion" data-k="potion">ğŸ§ª</div>
    <div class="btn" id="b-atk" data-k="atk">Z</div>
    <div class="btn" id="b-skill" data-k="skill">X</div>

    <div class="btn" id="b-inv" data-k="inv">ğŸ’</div>
    <div class="btn" id="b-menu" data-k="menu">âš™</div>
  </div>

<script>
(() => {
  "use strict";

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d", { alpha: false });

  const VIEW_W = 960;
  const VIEW_H = 540;

  function getDpr() { return Math.max(1, Math.min(2.5, window.devicePixelRatio || 1)); }
  function resize() {
    const dpr = getDpr();
    canvas.width = Math.floor(VIEW_W * dpr);
    canvas.height = Math.floor(VIEW_H * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.imageSmoothingEnabled = true;
  }
  window.addEventListener("resize", resize, { passive: true });
  resize();

  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const rand = (a, b) => Math.random() * (b - a) + a;
  const randi = (a, b) => Math.floor(rand(a, b + 1));
  const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
  const dist = (ax, ay, bx, by) => Math.hypot(ax - bx, ay - by);
  const isoNow = () => new Date().toISOString();
  const lerp = (a,b,t)=>a+(b-a)*t;
  function smoothFactor(dt, sharpness=18){ return 1 - Math.pow(0.001, dt*sharpness); }

  // âœ… ë¸Œë¼ìš°ì € ê¸°ë³¸ ë™ì‘(ìŠ¤í¬ë¡¤/ë’¤ë¡œê°€ê¸° ë“±) ë°©ì§€
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (["arrowleft","arrowright","arrowup"," ","z","x","escape","i","p","h","enter","backspace"].includes(k)) {
      e.preventDefault();
      e.stopPropagation();
    }
  }, { passive:false });

  // -------------------- Save/Load --------------------
  const SAVE_KEY = "boss_gate_web_v11_full_shop_inv";
  function save(state) { try { localStorage.setItem(SAVE_KEY, JSON.stringify(state)); } catch {} }
  function load() {
    try {
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch { return null; }
  }

  // -------------------- Audio --------------------
  class AudioMan {
    constructor() {
      this.ctx = null; this.master=null; this.bgmGain=null; this.sfxGain=null;
      this.unlocked = false;
      this.muted = false; this.bgmOn = true; this.sfxOn = true;

      this._bases = { bgm: "./assets/bgm", hit: "./assets/sfx_hit", coin: "./assets/sfx_coin" };
      this._exts = [".m4a", ".mp3", ".mp4"];

      this.files = { bgm:new Audio(), hit:new Audio(), coin:new Audio() };
      this.files.bgm.loop = true;

      for (const k of Object.keys(this.files)) {
        const a = this.files[k];
        a.preload = "auto";
        a.volume = (k === "bgm") ? 0.55 : 0.65;
      }

      this._picked = { bgm:null, hit:null, coin:null };
      this.preResolveAll().catch(()=>{});
    }

    _scoreCanPlay(ext){
      const test = document.createElement("audio");
      const map = {
        ".mp3": ["audio/mpeg"],
        ".m4a": ["audio/mp4", "audio/aac"],
        ".mp4": ["audio/mp4", "video/mp4"],
      };
      const mimes = map[ext] || [];
      let best = 0;
      for (const m of mimes){
        const r = test.canPlayType(m);
        if (r === "probably") best = Math.max(best, 2);
        else if (r === "maybe") best = Math.max(best, 1);
      }
      return best;
    }

    _candidateUrls(base){
      const scored = this._exts.map((ext, idx) => ({
        url: base + ext,
        score: this._scoreCanPlay(ext),
        idx
      })).sort((a,b)=> (b.score - a.score) || (a.idx - b.idx));
      return scored.map(x=>x.url);
    }

    async _exists(url){
      try {
        const r = await fetch(url, { method:"HEAD", cache:"no-cache" });
        if (r.ok) return true;
      } catch {}
      try {
        const r2 = await fetch(url, { method:"GET", cache:"no-cache" });
        return r2.ok;
      } catch {}
      return false;
    }

    async resolve(key){
      if (this._picked[key]) return this._picked[key];

      const base = this._bases[key];
      const urls = this._candidateUrls(base);

      for (const url of urls){
        if (await this._exists(url)) {
          this._picked[key] = url;
          this._applySource(key, url);
          return url;
        }
      }

      const fallback = urls[0] || (base + ".mp3");
      this._picked[key] = fallback;
      this._applySource(key, fallback);
      return fallback;
    }

    _applySource(key, url){
      const a = this.files[key];
      if (!a) return;
      if (a.src && a.src.endsWith(url)) return;
      a.src = url;
      if (key === "bgm") a.loop = true;
      a.load();
    }

    async preResolveAll(){
      await Promise.all([ this.resolve("bgm"), this.resolve("hit"), this.resolve("coin") ]);
    }

    ensureCtx() {
      if (this.ctx) return;
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) return;
      this.ctx = new AC();
      this.master = this.ctx.createGain();
      this.bgmGain = this.ctx.createGain();
      this.sfxGain = this.ctx.createGain();
      this.master.connect(this.ctx.destination);
      this.bgmGain.connect(this.master);
      this.sfxGain.connect(this.master);
      this.master.gain.value = 0.9;
      this.bgmGain.gain.value = 0.45;
      this.sfxGain.gain.value = 0.75;
    }

    async unlock() {
      if (this.unlocked) return;
      this.ensureCtx();
      try { if (this.ctx && this.ctx.state !== "running") await this.ctx.resume(); } catch {}
      this.unlocked = true;

      if (this.ctx) {
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        g.gain.value = 0.0001;
        o.connect(g); g.connect(this.master);
        o.start(); o.stop(this.ctx.currentTime + 0.02);
      }
    }

    setMuted(v) {
      this.muted = v;
      if (this.master) this.master.gain.value = v ? 0 : 0.9;
      for (const a of Object.values(this.files)) a.muted = v;
    }

    beep(freq, dur, type="square", vol=0.2) {
      if (!this.sfxOn || this.muted) return;
      this.ensureCtx();
      if (!this.ctx) return;
      const t0 = this.ctx.currentTime;
      const o = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      o.connect(g); g.connect(this.sfxGain);
      o.start(t0); o.stop(t0 + dur + 0.02);
    }

    async _safePlay(key, fallbackBeep){
      if (this.muted) return false;
      await this.resolve(key);
      const a = this.files[key];
      try {
        a.currentTime = 0;
        await a.play();
        return true;
      } catch {
        this._picked[key] = null;
        await this.resolve(key);
        try {
          a.currentTime = 0;
          await a.play();
          return true;
        } catch {
          if (fallbackBeep) fallbackBeep();
          return false;
        }
      }
    }

    async startBgm() {
      if (!this.bgmOn || this.muted) return;
      const ok = await this._safePlay("bgm", () => {
        this.ensureCtx();
        if (!this.ctx) return;
        if (this._bgmNode) return;
        const t0 = this.ctx.currentTime;
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        o.type = "sine";
        g.gain.value = 0.0001;
        o.connect(g); g.connect(this.bgmGain);
        const notes = [220, 277.18, 329.63, 392.0, 329.63, 277.18];
        for (let i=0;i<999;i++){
          const f = notes[i % notes.length] * (i % 12 === 0 ? 0.5 : 1);
          o.frequency.setValueAtTime(f, t0 + i*0.22);
        }
        g.gain.exponentialRampToValueAtTime(0.12, t0 + 0.12);
        o.start(t0);
        this._bgmNode = { o, g };
      });
      if (ok) {
        const bgm = this.files.bgm;
        bgm.loop = true;
        bgm.volume = 0.55;
      }
    }

    stopBgm() {
      const bgm = this.files.bgm;
      try { bgm.pause(); bgm.currentTime = 0; } catch {}
      if (this._bgmNode && this.ctx) {
        try { this._bgmNode.o.stop(); } catch {}
        this._bgmNode = null;
      }
    }

    async playHit() {
      if (!this.sfxOn || this.muted) return;
      await this._safePlay("hit", () => {
        this.beep(220, 0.06, "square", 0.18);
        this.beep(120, 0.08, "triangle", 0.12);
      });
    }

    async playCoin() {
      if (!this.sfxOn || this.muted) return;
      await this._safePlay("coin", () => {
        this.beep(880, 0.05, "triangle", 0.12);
        this.beep(1320, 0.06, "sine", 0.10);
      });
    }
  }

  const audio = new AudioMan();

  const unlockOnce = async () => {
    await audio.unlock();
    await audio.startBgm();
    window.removeEventListener("pointerdown", unlockOnce);
    window.removeEventListener("keydown", unlockOnce);
  };
  window.addEventListener("pointerdown", unlockOnce, { passive: true });
  window.addEventListener("keydown", unlockOnce, { passive: true });

  // -------------------- Input --------------------
  const keys = new Set();
  const pressed = { jump:false, atk:false, skill:false, menu:false, inv:false, potion:false };

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    keys.add(k);

    if (k === " " || k === "arrowup") pressed.jump = true;
    if (k === "z") pressed.atk = true;
    if (k === "x") pressed.skill = true;
    if (k === "escape" || k === "p") pressed.menu = true;
    if (k === "i") pressed.inv = true;
    if (k === "h") pressed.potion = true;
  }, { passive:false });

  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()), { passive:true });

  // âœ… Touch input
  const touch = document.getElementById("touch");
  const touchDown = new Set();
  function setTouchKey(name, down) {
    if (down) touchDown.add(name);
    else touchDown.delete(name);
  }
  if (touch) {
    touch.addEventListener("pointerdown", (e) => {
      const t = e.target;
      if (!(t instanceof HTMLElement)) return;
      const k = t.getAttribute("data-k");
      if (!k) return;
      e.preventDefault();
      t.setPointerCapture(e.pointerId);
      setTouchKey(k, true);
      if (k === "jump") pressed.jump = true;
      if (k === "atk") pressed.atk = true;
      if (k === "skill") pressed.skill = true;
      if (k === "menu") pressed.menu = true;
      if (k === "inv") pressed.inv = true;
      if (k === "potion") pressed.potion = true;
    }, { passive:false });

    touch.addEventListener("pointerup", (e) => {
      const t = e.target;
      if (!(t instanceof HTMLElement)) return;
      const k = t.getAttribute("data-k");
      if (!k) return;
      e.preventDefault();
      setTouchKey(k, false);
    }, { passive:false });

    touch.addEventListener("pointercancel", () => touchDown.clear(), { passive:true });
  }

  function moveAxis() {
    let x = 0;
    if (keys.has("arrowleft") || keys.has("a")) x -= 1;
    if (keys.has("arrowright") || keys.has("d")) x += 1;
    if (touchDown.has("left")) x -= 1;
    if (touchDown.has("right")) x += 1;
    return clamp(x, -1, 1);
  }
  function wantAttack() { return pressed.atk || keys.has("z") || touchDown.has("atk"); }
  function wantSkill() { return pressed.skill || keys.has("x") || touchDown.has("skill"); }

  // -------------------- Pointer (canvas UI) --------------------
  let pointer = { x:0, y:0, down:false, clicked:false, wheelY:0 };
  function toLogicalXY(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const lx = (clientX - rect.left) / rect.width * VIEW_W;
    const ly = (clientY - rect.top) / rect.height * VIEW_H;
    return { x: lx, y: ly };
  }
  canvas.addEventListener("pointerdown", (e) => {
    const p = toLogicalXY(e.clientX, e.clientY);
    pointer.x = p.x; pointer.y = p.y;
    pointer.down = true;
    pointer.clicked = true;
  }, { passive:true });
  canvas.addEventListener("pointerup", () => { pointer.down = false; }, { passive:true });
  canvas.addEventListener("pointermove", (e) => {
    const p = toLogicalXY(e.clientX, e.clientY);
    pointer.x = p.x; pointer.y = p.y;
  }, { passive:true });
  canvas.addEventListener("wheel", (e) => {
    e.preventDefault();
    pointer.wheelY += e.deltaY;
  }, { passive:false });

  function hitBtn(x,y,w,h){
    return pointer.clicked && pointer.x>=x && pointer.x<=x+w && pointer.y>=y && pointer.y<=y+h;
  }

  // -------------------- Assets --------------------
  function loadImage(src) {
    const img = new Image();
    const obj = { img, ok: false };
    img.onload = () => obj.ok = true;
    img.onerror = () => obj.ok = false;
    img.src = src;
    return obj;
  }
  const IMG = {
    player: loadImage("./assets/player_sheet.png"),
    slime:  loadImage("./assets/slime_sheet.png"),
    fxHit:  loadImage("./assets/fx_hit.png"),
    bg:     loadImage("./assets/bg.png"),
  };

  // -------------------- SpriteSheet --------------------
  class SpriteSheet {
    constructor(imageObj, fw, fh, animations) {
      this.imageObj = imageObj;
      this.fw = fw;
      this.fh = fh;
      this.anim = animations;
    }
    draw(name, x, y, t, scale=1, flip=false, alpha=1) {
      const { img, ok } = this.imageObj;
      const a = this.anim[name] || this.anim.idle;
      const frames = Math.max(1, a.frames);
      const idx = a.loop
        ? Math.floor(t * a.fps) % frames
        : Math.min(frames - 1, Math.floor(t * a.fps));
      const sx = idx * this.fw;
      const sy = a.row * this.fh;

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.translate(x, y);
      if (flip) ctx.scale(-1, 1);

      if (ok) {
        ctx.drawImage(img, sx, sy, this.fw, this.fh,
          -this.fw*scale/2, -this.fh*scale/2, this.fw*scale, this.fh*scale);
      } else {
        ctx.fillStyle = "rgba(91,140,255,0.95)";
        if (name === "hurt") ctx.fillStyle = "rgba(255,91,110,0.95)";
        if (name === "attack") ctx.fillStyle = "rgba(255,207,91,0.95)";
        ctx.fillRect(-22*scale, -26*scale, 44*scale, 52*scale);
        ctx.fillStyle = "rgba(235,240,255,0.85)";
        ctx.fillRect(6*scale, -6*scale, 10*scale, 6*scale);
      }
      ctx.restore();
    }
  }

  const playerSheet = new SpriteSheet(IMG.player, 64, 64, {
    idle:   { row:0, frames:6, fps:8,  loop:true  },
    run:    { row:1, frames:8, fps:12, loop:true  },
    jump:   { row:2, frames:4, fps:10, loop:false },
    attack: { row:3, frames:6, fps:16, loop:false },
    hurt:   { row:4, frames:4, fps:14, loop:false }
  });

  const slimeSheet = new SpriteSheet(IMG.slime, 64, 64, {
    idle:   { row:0, frames:6, fps:8,  loop:true  },
    run:    { row:1, frames:6, fps:10, loop:true  },
    hurt:   { row:2, frames:4, fps:14, loop:false },
    attack: { row:3, frames:6, fps:14, loop:false },
    die:    { row:4, frames:6, fps:12, loop:false }
  });

  // -------------------- FX --------------------
  class DamageText {
    constructor(x, y, text, color="rgba(235,240,255,0.92)") {
      this.x=x; this.y=y; this.vy=-50;
      this.text=text; this.t=0; this.life=0.8;
      this.color=color;
    }
    update(dt){ this.t+=dt; this.y += this.vy*dt; }
    draw(cam){
      const a = clamp(1 - this.t/this.life, 0, 1);
      ctx.globalAlpha = a;
      ctx.fillStyle = this.color;
      ctx.font = "bold 18px ui-monospace, Menlo, Consolas, monospace";
      ctx.fillText(this.text, this.x - cam.x, this.y - cam.y);
      ctx.globalAlpha = 1;
    }
    dead(){ return this.t >= this.life; }
  }

  class Particle {
    constructor(x,y,vx,vy,life, col){
      this.x=x; this.y=y; this.vx=vx; this.vy=vy;
      this.t=0; this.life=life; this.col=col;
    }
    update(dt){
      this.t+=dt;
      this.vy += 520*dt;
      this.x += this.vx*dt;
      this.y += this.vy*dt;
      this.vx *= Math.pow(0.12, dt);
      this.vy *= Math.pow(0.22, dt);
    }
    draw(cam){
      const a = clamp(1 - this.t/this.life, 0, 1);
      ctx.globalAlpha = a;
      ctx.fillStyle = this.col;
      ctx.fillRect(this.x - cam.x, this.y - cam.y, 3, 3);
      ctx.globalAlpha = 1;
    }
    dead(){ return this.t >= this.life; }
  }

  class HitSpark {
    constructor(x,y){
      this.x=x; this.y=y; this.t=0; this.life=0.22;
    }
    update(dt){ this.t += dt; }
    draw(cam){
      const a = clamp(1 - this.t/this.life, 0, 1);
      const px = this.x - cam.x, py = this.y - cam.y;
      ctx.save();
      ctx.globalAlpha = a;
      if (IMG.fxHit.ok) {
        const fw=64, fh=64, frames=6;
        const i = Math.min(frames-1, Math.floor((this.t/this.life)*frames));
        ctx.drawImage(IMG.fxHit.img, i*fw, 0, fw, fh, px-32, py-32, 64, 64);
      } else {
        ctx.strokeStyle = "rgba(255,235,120,0.95)";
        ctx.lineWidth = 3;
        const r = 10 + (1-a)*14;
        for(let i=0;i<8;i++){
          const ang = (Math.PI*2)*(i/8);
          ctx.beginPath();
          ctx.moveTo(px, py);
          ctx.lineTo(px + Math.cos(ang)*r, py + Math.sin(ang)*r);
          ctx.stroke();
        }
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.fillRect(px-2, py-2, 4, 4);
      }
      ctx.restore();
    }
    dead(){ return this.t >= this.life; }
  }

  // -------------------- World --------------------
  const WORLD = { w: 4200, h: 1200 };
  const GROUND_Y = 860;
  const GROUND_SCREEN_Y = VIEW_H - 80;
  const CAM_Y = Math.max(0, GROUND_Y - GROUND_SCREEN_Y);

  function stageLabel(i){
    const chap = Math.floor((i-1)/10)+1;
    const step = ((i-1)%10)+1;
    return `${chap}-${step}`;
  }
  function isBossStage(i){
    const step = ((i-1)%10)+1;
    return (step % 5 === 0);
  }

  function buildPlatforms(stageIndex){
    const plats = [];
    plats.push({ x: 0, y: GROUND_Y, w: WORLD.w, h: 80 });

    const seed = stageIndex * 1337;
    const rng = (n)=> {
      const s = Math.sin(seed + n*12.9898) * 43758.5453;
      return s - Math.floor(s);
    };

    for (let i=0;i<10;i++){
      const px = 420 + i*320 + randi(-40, 40);
      const py = GROUND_Y - 120 - Math.floor(rng(i)*220);
      plats.push({ x:px, y:py, w: 170 + randi(0, 60), h: 18 });
    }
    plats.push({ x: WORLD.w - 720, y: GROUND_Y - 160, w: 220, h: 18 });
    return plats;
  }

  // -------------------- Items / Shop / Appraise --------------------
  const SLOTS = ["weapon","armor","ring"];
  const RAR = [
    {k:"N",  name:"ì¼ë°˜", w:60, opt:0, mult:1.00},
    {k:"R",  name:"í¬ê·€", w:28, opt:1, mult:1.20},
    {k:"SR", name:"ì˜ì›…", w:10, opt:2, mult:1.45},
    {k:"SSR",name:"ì „ì„¤", w: 2, opt:2, mult:1.85},
  ];
  const NAMES = {
    weapon:["ë‚˜ë¬´ ê²€","ì² ê²€","í‘ì² ê²€","ë²ˆê°œì˜ ê²€","ì²˜í˜•ì ëŒ€ê²€"],
    armor:["í—Œ ì˜·","ê°€ì£½ ê°‘ì˜·","ì‚¬ìŠ¬ ê°‘ì˜·","ê°•ì²  ê°‘ì˜·","ìˆ˜í˜¸ì˜ íŒê¸ˆ"],
    ring:["ë™ ë°˜ì§€","ì€ ë°˜ì§€","ì§‘ì¤‘ì˜ ë°˜ì§€","íŒŒê´´ì˜ ë°˜ì§€","ì™•ì˜ ë°˜ì§€"]
  };
  const AFFIX = [
    {k:"atk", n:"ê³µê²©", min:1, max:7, w:22},
    {k:"def", n:"ë°©ì–´", min:1, max:6, w:22},
    {k:"hp",  n:"ì²´ë ¥", min:8, max:26, w:18},
    {k:"crit",n:"ì¹˜ëª…", min:1, max:7, w:10},
    {k:"spd", n:"ì´ì†", min:6, max:18, w:10},
    {k:"atkP",n:"ê³µê²©%",min:2, max:10,w:8},
    {k:"hpP", n:"ì²´ë ¥%",min:3, max:12,w:5},
    {k:"ls",  n:"í¡í˜ˆ", min:1, max:4, w:3},
  ];

  function wpick(list){
    const sum = list.reduce((s,x)=>s+x.w,0);
    let r = Math.random()*sum;
    for (const x of list){ r-=x.w; if (r<=0) return x; }
    return list[0];
  }
  function rollRarity(){
    const sum = RAR.reduce((s,x)=>s+x.w,0);
    let r = Math.random()*sum;
    for (const x of RAR){ r-=x.w; if (r<=0) return x; }
    return RAR[0];
  }
  function uuid(){
    if (crypto?.randomUUID) return crypto.randomUUID();
    return "id-"+Math.random().toString(16).slice(2)+Date.now().toString(16);
  }
  function rollAffixes(cnt){
    const used=new Set(); const out=[];
    let tries=0;
    while(out.length<cnt && tries<30){
      tries++;
      const a=wpick(AFFIX);
      if(used.has(a.k)) continue;
      used.add(a.k);
      out.push({k:a.k, n:a.n, v:randi(a.min,a.max)});
    }
    return out;
  }
  function makeItem(slot, level){
    const rar = rollRarity();
    const baseName = pick(NAMES[slot]);
    const ilvl = Math.max(1, level + randi(-1, 2));
    let atk=0,def=0,hp=0,crit=0,spd=0;
    if(slot==="weapon") atk = randi(3,7);
    if(slot==="armor"){ def=randi(2,6); hp=randi(10,22); }
    if(slot==="ring"){ crit=randi(1,4); atk=randi(1,3); spd=randi(0,6); }

    const mult = rar.mult * (1 + (ilvl-1)*0.04);
    const stats = {
      atk: Math.round(atk*mult),
      def: Math.round(def*mult),
      hp:  Math.round(hp*mult),
      crit:Math.round(crit*mult),
      spd: Math.round(spd*mult),
    };

    // âœ… "ë¯¸ê°ì •"ì€ í¬ê·€ ì´ìƒì—ì„œë§Œ ë°œìƒ
    const identified = (rar.k==="N");
    const hidden = (rar.opt>0) ? rollAffixes(rar.opt) : [];

    return {
      id: uuid(),
      slot,
      name: baseName,
      rar: rar.k,
      rarName: rar.name,
      ilvl,
      enh: 0,
      identified,
      hidden,
      aff: [],
      stats,
      createdAt: isoNow()
    };
  }

  // âœ… PATCH: ì•„ì´í…œ êµ¬ì¡° ì •ê·œí™”(ì €ì¥ ë°ì´í„°/êµ¬ë²„ì „ ë°ì´í„°ê°€ ê¹¨ì ¸ë„ ì•ˆì „)
  function normalizeItem(it){
    if (!it || typeof it !== "object") return null;
    it.stats ||= { atk:0, def:0, hp:0, crit:0, spd:0 };
    it.hidden = Array.isArray(it.hidden) ? it.hidden : [];
    it.aff = Array.isArray(it.aff) ? it.aff : [];
    it.identified = !!it.identified;
    it.ilvl = Number(it.ilvl || 1);
    it.enh = Number(it.enh || 0);
    it.rar ||= "N";
    it.slot ||= "weapon";
    it.name ||= "(ì´ë¦„ì—†ìŒ)";
    it.rarName ||= "";
    it.id ||= uuid();
    return it;
  }

  function appraise(it){
    it = normalizeItem(it);
    if (!it) return false;
    if(it.identified) return false;
    it.identified=true;
    it.aff = (Array.isArray(it.hidden) ? it.hidden : []).slice();
    it.hidden = [];
    return true;
  }

  // âœ… PATCH: itemPow ì•ˆì „ ë²„ì „(ëˆ„ë½/ê¹¨ì§ì—ë„ ì ˆëŒ€ í„°ì§€ì§€ ì•Šê²Œ)
  function itemPow(it){
    it = normalizeItem(it);
    if (!it) return 0;

    const stats = it.stats || { atk:0, def:0, hp:0, crit:0, spd:0 };
    const aff = (it.identified && Array.isArray(it.aff)) ? it.aff : [];

    let p =
      (Number(stats.atk)||0)*2 +
      (Number(stats.def)||0)*2 +
      (Number(stats.hp)||0)*0.6 +
      (Number(stats.crit)||0)*1.4 +
      (Number(stats.spd)||0)*0.5 +
      (Number(it.ilvl)||1)*2 +
      (Number(it.enh)||0)*6;

    for (const a of aff){
      const v = Number(a?.v)||0;
      const k = a?.k;
      if (k==="atk")  p += v*3;
      if (k==="def")  p += v*3;
      if (k==="hp")   p += v*0.8;
      if (k==="crit") p += v*2;
      if (k==="spd")  p += v*0.8;
      if (k==="atkP") p += v*4;
      if (k==="hpP")  p += v*3;
      if (k==="ls")   p += v*6;
    }
    return Math.round(p);
  }

  function sellPrice(it){
    it = normalizeItem(it);
    if (!it) return 0;
    const rarMult = (it.rar==="SSR")?3.2:(it.rar==="SR")?2.2:(it.rar==="R")?1.5:1.0;
    const base = 18 + it.ilvl*8 + Math.floor(itemPow(it)*0.12);
    const idBonus = it.identified ? 1.15 : 0.95;
    return Math.max(5, Math.floor(base * rarMult * idBonus));
  }

  // ìƒì /ê°ì •
  const POTION_MAX = 12;
  const POTION_HEAL_PCT = 0.35;
  const POTION_CD = 8.0;

  const POTION_PRICE = 60;         // í¬ì…˜ 1ê°œ ê°€ê²©
  const APPRAISE_PRICE = 45;       // ê°ì • 1íšŒ ê°€ê²©(ê³¨ë“œ)
  const APPRAISE_TICKET_REWARD = 1;// ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´ ê°ì •ê¶Œ(ì˜ˆì‹œ)

  // -------------------- Physics / Combat --------------------
  function aabb(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  const ATTACK_LOCK_ATK = 0.18;
  const ATTACK_LOCK_SKL = 0.24;
  const CONTACT_DAMAGE_COOLDOWN = 0.22;
  const CONTACT_SEP_STRENGTH = 0.78;

  const DROP_RATE_NORMAL = 0.07;
  const DROP_RATE_ELITE  = 0.18;
  const DROP_RATE_BOSS   = 0.60;
  const BOSS_DOUBLE_DROP_RATE = 0.22;

  function snapToGround(ent){
    const gy = GROUND_Y - ent.h/2;
    if (ent.y > gy) {
      ent.y = gy;
      ent.vy = 0;
      ent.onGround = true;
    }
  }

  class Player {
    constructor() {
      this.x = 220; this.y = 200;
      this.vx = 0; this.vy = 0;
      this.w = 42; this.h = 54;
      this.face = 1;
      this.onGround = false;

      this.hpBase = 120;
      this.atkBase = 14;
      this.defBase = 6;
      this.critBase = 6;
      this.spdBase = 230;

      this.hp = 120;
      this.atkCd = 0;
      this.skillCd = 0;

      this.inv = 0;
      this.hitCd = 0;
      this.attackLock = 0;

      this.potions = 3;
      this.potionCd = 0;

      this.gold = 120;
      this.stage = 1;
      this.kills = 0;

      this.appraiseTickets = 0;

      this.anim = "idle";
      this.animT = 0;

      this.invItems = [ makeItem("weapon",1), makeItem("armor",1), makeItem("ring",1) ].map(normalizeItem);
      this.equip = { weapon:null, armor:null, ring:null };
      this.autoEquipBest();
    }
    derived() {
      let hpMax = this.hpBase;
      let atk = this.atkBase;
      let def = this.defBase;
      let crit = this.critBase;
      let spd = this.spdBase;
      let atkP=0, hpP=0, ls=0;

      for (const s of SLOTS) {
        const it0 = this.equip[s];
        const it = normalizeItem(it0);
        if (!it) continue;

        atk += it.stats.atk;
        def += it.stats.def;
        hpMax += it.stats.hp;
        crit += it.stats.crit;
        spd += it.stats.spd;

        if (it.identified) {
          for (const a of it.aff) {
            if (a.k==="atk") atk += (Number(a.v)||0);
            if (a.k==="def") def += (Number(a.v)||0);
            if (a.k==="hp")  hpMax += (Number(a.v)||0);
            if (a.k==="crit")crit += (Number(a.v)||0);
            if (a.k==="spd") spd += (Number(a.v)||0);
            if (a.k==="atkP")atkP += (Number(a.v)||0);
            if (a.k==="hpP") hpP += (Number(a.v)||0);
            if (a.k==="ls")  ls  += (Number(a.v)||0);
          }
        }
      }
      atk = Math.round(atk * (1 + atkP/100));
      hpMax = Math.round(hpMax * (1 + hpP/100));
      crit = clamp(crit, 0, 60);
      spd = clamp(spd, 160, 310);
      ls = clamp(ls, 0, 12);
      return { hpMax, atk, def, crit, spd, ls };
    }
    autoEquipBest() {
      for (const slot of SLOTS) {
        const current = normalizeItem(this.equip[slot]);
        const cand = this.invItems.filter(it => it && it.slot === slot).map(normalizeItem).filter(Boolean);
        if (current) cand.push(current);
        if (!cand.length) continue;
        cand.sort((a,b)=>itemPow(b)-itemPow(a));
        const best = cand[0];
        if (current && best.id === current.id) continue;
        if (current) this.invItems.push(current);
        this.invItems = this.invItems.filter(it => it && it.id !== best.id);
        this.equip[slot] = best;
      }
      const d = this.derived();
      this.hp = clamp(this.hp, 1, d.hpMax);
    }
  }

  class Slime {
    constructor(x,y, tier, stageIndex) {
      this.x=x; this.y=y;
      this.vx=0; this.vy=0;
      this.w=44; this.h=42;
      this.face = -1;
      this.onGround=false;

      this.tier = tier;
      this.hpMax = 55 + stageIndex*18 + (tier==="elite"?80:0) + (tier==="boss"?420:0);
      this.hp = this.hpMax;
      this.atk = 10 + stageIndex*4 + (tier==="elite"?10:0) + (tier==="boss"?26:0);
      this.def = 2 + Math.floor(stageIndex/2) + (tier==="elite"?3:0) + (tier==="boss"?8:0);
      this.spd = (tier==="boss"?150:(tier==="elite"?190:170));

      this.hitCd=0;
      this.aiT=0;

      this.anim="idle";
      this.animT=0;
      this.dead=false;
      this.dieT=0;

      this.jumpCd = 0;
      this.groundSnap = true;
    }
  }

  class Coin { constructor(x,y,amount){ this.x=x; this.y=y; this.vx=rand(-40,40); this.vy=rand(-280,-120); this.r=8; this.amount=amount; this.t=0; } }
  class Loot { constructor(x,y,item){ this.x=x; this.y=y; this.vx=rand(-30,30); this.vy=rand(-240,-120); this.r=10; this.item=normalizeItem(item); this.t=0; } }

  const cam = { x:0, y:CAM_Y };

  // -------------------- UI helpers --------------------
  function roundRect(x, y, w, h, r, fill, stroke){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }
  function panel(x,y,w,h,title){
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(10,14,24,0.74)";
    roundRect(x,y,w,h,14,true,false);
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = 1;
    roundRect(x,y,w,h,14,false,true);

    ctx.globalAlpha = 1;
    ctx.fillStyle = "rgba(235,240,255,0.92)";
    ctx.font = "bold 18px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.fillText(title, x+16, y+30);
    ctx.restore();
  }
  function btn(x,y,w,h,text,hot=false){
    ctx.save();
    ctx.fillStyle = hot ? "rgba(91,140,255,0.22)" : "rgba(255,255,255,0.07)";
    ctx.strokeStyle = hot ? "rgba(91,140,255,0.50)" : "rgba(255,255,255,0.14)";
    ctx.lineWidth = 1;
    roundRect(x,y,w,h,12,true,true);
    ctx.fillStyle = "rgba(235,240,255,0.92)";
    ctx.font = "bold 16px system-ui, -apple-system, Segoe UI";
    const tw = ctx.measureText(text).width;
    ctx.fillText(text, x + (w-tw)/2, y + h/2 + 6);
    ctx.restore();
  }
  function drawIconBtn(x,y,w,h,label,hot=false){
    ctx.save();
    ctx.fillStyle = hot ? "rgba(91,140,255,0.22)" : "rgba(255,255,255,0.07)";
    ctx.strokeStyle = hot ? "rgba(91,140,255,0.55)" : "rgba(255,255,255,0.14)";
    roundRect(x,y,w,h,12,true,true);

    ctx.fillStyle = "rgba(235,240,255,0.92)";
    ctx.font = "900 18px system-ui, -apple-system, Segoe UI";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(label, x + w/2, y + h/2 + 1);
    ctx.restore();
  }

  function rarColor(r){
    if (r==="SSR") return "rgba(255,207,91,0.95)";
    if (r==="SR")  return "rgba(200,140,255,0.95)";
    if (r==="R")   return "rgba(91,140,255,0.95)";
    return "rgba(235,240,255,0.82)";
  }
  function slotName(s){
    return s==="weapon" ? "ë¬´ê¸°" : s==="armor" ? "ë°©ì–´êµ¬" : "ë°˜ì§€";
  }
  function itemLine(it0){
    const it = normalizeItem(it0);
    if (!it) return "(ì˜ëª»ëœ ì•„ì´í…œ)";
    const idTag = it.identified ? "" : " (ë¯¸ê°ì •)";
    return `[${it.rar}] ${slotName(it.slot)} | ${it.name}${idTag} | iLv ${it.ilvl} | PWR ${itemPow(it)} | íŒë§¤ ${sellPrice(it)}G`;
  }

  // HUD ë²„íŠ¼(ìº”ë²„ìŠ¤ ë‚´ë¶€)
  const HUD_MENU_BTN   = { x: 14+740+10, y: 14,            w: 46, h: 46 };
  const HUD_POTION_BTN = { x: 14+740+10, y: 14+46+8,       w: 46, h: 46 };
  const HUD_INV_BTN    = { x: 14+740+10, y: 14+46+8+46+8,  w: 46, h: 46 };

  // -------------------- Game State --------------------
  function freshState(){
    const p = new Player();
    return {
      ver: 11,
      game: "ë³´ìŠ¤ê²Œì´íŠ¸ (BOSS GATE)",
      createdAt: isoNow(),
      updatedAt: isoNow(),

      gs: "MENU", // MENU / OPTIONS / PLAY / PAUSE / INV / SHOP
      lastPlayGs: "PLAY",

      opt: { muted:false, bgm:true, sfx:true },

      player: p,
      stageIndex: 1,
      inBossRoom: false,

      platforms: buildPlatforms(1),
      enemies: [],
      coins: [],
      loots: [],

      goalKills: 10,
      killed: 0,

      door: null,
      fx: [],
      dmgText: [],
      parts: [],

      msg: "ë³´ìŠ¤ë¬¸ì„ ë¶€ìˆ´ë¼. (âš™: ë©”ë‰´, ğŸ’: ì¸ë²¤, ğŸ§ª: í¬ì…˜)",
      msgT: 2.2,

      t: 0,
      camX: 0,

      invSelId: null,
      invScroll: 0,

      shopScroll: 0
    };
  }

  function applyOptions(state){
    audio.setMuted(!!state.opt.muted);
    audio.bgmOn = !!state.opt.bgm;
    audio.sfxOn = !!state.opt.sfx;
    if (!audio.bgmOn) audio.stopBgm();
    else audio.startBgm();
  }

  function rebuildStage(state){
    const si = state.stageIndex;
    state.platforms = buildPlatforms(si);
    state.enemies = [];
    state.coins = [];
    state.loots = [];
    state.fx = [];
    state.dmgText = [];
    state.parts = [];
    state.door = null;

    state.killed = 0;
    state.goalKills = isBossStage(si) ? 1 : clamp(8 + Math.floor(si*0.7), 8, 18);

    state.player.x = 220;
    state.player.y = GROUND_Y - 120;
    state.player.vx = 0; state.player.vy = 0;
    state.player.attackLock = 0;

    state.camX = 0;

    if (isBossStage(si)) {
      state.inBossRoom = true;
      const bx = WORLD.w - 760;
      state.enemies.push(new Slime(bx, GROUND_Y - 120, "boss", si));
      state.msg = `ë³´ìŠ¤ê²Œì´íŠ¸ ${stageLabel(si)} â€” ë³´ìŠ¤ ë“±ì¥!`;
      state.msgT = 1.6;
    } else {
      state.inBossRoom = false;
      const n = state.goalKills;
      for (let i=0;i<n;i++){
        const ex = 700 + i*260 + randi(-80,80);
        state.enemies.push(new Slime(ex, GROUND_Y - 120, Math.random()<0.22 ? "elite":"normal", si));
      }
      state.msg = `ìŠ¤í…Œì´ì§€ ${stageLabel(si)} ì‹œì‘! (${state.goalKills}ë§ˆë¦¬ ì²˜ì¹˜)`;
      state.msgT = 1.8;
    }
  }

  function startNew(state){
    const fresh = freshState();
    fresh.opt = state.opt;
    Object.assign(state, fresh);
    rebuildStage(state);
    state.gs = "PLAY";
    save(state);
  }

  function rollCrit(crit){ return (Math.random()*100) < crit; }
  function damageCalc(atk, def, critChance, mult=1){
    const c = rollCrit(critChance);
    let dmg = Math.max(1, Math.round(atk*mult) - def);
    if (c) dmg = Math.round(dmg*1.65);
    return { dmg, crit:c };
  }

  function spawnHitFX(state, x, y){
    state.fx.push(new HitSpark(x,y));
    for (let i=0;i<14;i++){
      state.parts.push(new Particle(x,y, rand(-220,220), rand(-260, -40), rand(0.18, 0.35), "rgba(255,235,120,0.95)"));
    }
    audio.playHit();
  }

  function shouldDropItem(tier){
    if (tier === "boss")  return Math.random() < DROP_RATE_BOSS;
    if (tier === "elite") return Math.random() < DROP_RATE_ELITE;
    return Math.random() < DROP_RATE_NORMAL;
  }

  function dropRewards(state, e){
    const baseGold = 18 + state.stageIndex*10 + (e.tier==="elite"?40:0) + (e.tier==="boss"?380:0);
    state.coins.push(new Coin(e.x, e.y, baseGold));

    if (shouldDropItem(e.tier)) {
      state.loots.push(new Loot(e.x+rand(-10,10), e.y, makeItem(pick(SLOTS), Math.max(1, Math.floor(state.stageIndex/2)+1))));
      if (e.tier === "boss" && Math.random() < BOSS_DOUBLE_DROP_RATE) {
        state.loots.push(new Loot(e.x+rand(-14,14), e.y, makeItem(pick(SLOTS), Math.max(1, Math.floor(state.stageIndex/2)+2))));
      }
    }
  }

  function ensureDoor(state){
    if (state.door) return;
    const x = WORLD.w - 300;
    const y = GROUND_Y - 120;
    const w = 90, h = 120;
    state.door = { x, y, w, h, kind: state.inBossRoom ? "exit" : "next" };
    state.msg = state.inBossRoom ? "ì¶œêµ¬ ë³´ìŠ¤ë¬¸ì´ ì—´ë ¸ë‹¤!" : "ë‹¤ìŒ ë³´ìŠ¤ë¬¸ì´ ì—´ë ¸ë‹¤!";
    state.msgT = 1.4;
  }

  function stageClearReward(state){
    const p = state.player;
    const before = p.potions;

    const addPotion = state.inBossRoom ? 2 : 1;
    p.potions = clamp(p.potions + addPotion, 0, POTION_MAX);

    const bonusGold = state.inBossRoom ? (120 + state.stageIndex*18) : (40 + state.stageIndex*8);
    p.gold += bonusGold;

    // âœ… ê°ì •ê¶Œ ë³´ìƒ
    p.appraiseTickets += APPRAISE_TICKET_REWARD;

    const got = p.potions - before;
    state.msg = `í´ë¦¬ì–´ ë³´ìƒ: +${bonusGold}G ${got>0?`+í¬ì…˜${got}ê°œ`:``} +ê°ì •ê¶Œ${APPRAISE_TICKET_REWARD}`;
    state.msgT = 1.8;
  }

  function collidePlatforms(ent, plats){
    ent.onGround = false;

    ent.x += ent.vx;
    for (const p of plats){
      if (aabb(ent.x - ent.w/2, ent.y - ent.h/2, ent.w, ent.h, p.x, p.y, p.w, p.h)){
        if (ent.vx > 0) ent.x = p.x - (ent.w/2);
        else if (ent.vx < 0) ent.x = p.x + p.w + (ent.w/2);
        ent.vx = 0;
      }
    }

    ent.y += ent.vy;
    for (const p of plats){
      if (aabb(ent.x - ent.w/2, ent.y - ent.h/2, ent.w, ent.h, p.x, p.y, p.w, p.h)){
        if (ent.vy > 0) {
          ent.y = p.y - (ent.h/2);
          ent.vy = 0;
          ent.onGround = true;
        } else if (ent.vy < 0) {
          ent.y = p.y + p.h + (ent.h/2);
          ent.vy = 0;
        }
      }
    }

    ent.x = clamp(ent.x, 40, WORLD.w - 40);
    ent.y = clamp(ent.y, 40, WORLD.h - 40);
  }

  // -------------------- Draw world --------------------
  function drawBackground(){
    if (IMG.bg.ok) {
      const img = IMG.bg.img;
      const par = 0.35;
      const bx = - (cam.x * par) % img.width;
      for (let x = bx - img.width; x < VIEW_W + img.width; x += img.width) {
        ctx.drawImage(img, x, 0, img.width, Math.min(VIEW_H, img.height));
      }
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(0,0,VIEW_W,VIEW_H);
    } else {
      const g = ctx.createLinearGradient(0,0,0,VIEW_H);
      g.addColorStop(0, "#061021");
      g.addColorStop(1, "#070a14");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,VIEW_W,VIEW_H);
    }
  }

  function drawPlatforms(plats){
    for (const p of plats) {
      const x = p.x - cam.x;
      const y = p.y - cam.y;
      ctx.fillStyle = "rgba(255,255,255,0.08)";
      ctx.fillRect(x, y, p.w, p.h);
      ctx.fillStyle = "rgba(91,140,255,0.10)";
      ctx.fillRect(x, y, p.w, 3);
    }
  }
  function drawDoor(door){
    const x = door.x - cam.x;
    const y = door.y - cam.y;
    ctx.fillStyle = door.kind==="next" ? "rgba(91,140,255,0.20)" : "rgba(255,91,110,0.22)";
    roundRect(x, y, door.w, door.h, 10, true, false);
    ctx.strokeStyle = door.kind==="next" ? "rgba(91,140,255,0.55)" : "rgba(255,91,110,0.55)";
    ctx.lineWidth = 2;
    roundRect(x, y, door.w, door.h, 10, false, true);
    ctx.fillStyle = "rgba(235,240,255,0.92)";
    ctx.font = "bold 12px ui-monospace, Menlo, Consolas";
    ctx.fillText(door.kind==="next" ? "BOSS GATE" : "EXIT GATE", x+10, y+20);
    ctx.lineWidth = 1;
  }
  function drawCoins(coins){
    for (const c of coins) {
      const x = c.x - cam.x, y = c.y - cam.y;
      ctx.fillStyle = "rgba(255,207,91,0.92)";
      ctx.beginPath(); ctx.arc(x,y,c.r,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,0.35)";
      ctx.fillRect(x-2,y-5,3,3);
    }
  }
  function drawLoot(loots){
    for (const l of loots) {
      const x = l.x - cam.x, y = l.y - cam.y;
      ctx.fillStyle = "rgba(91,140,255,0.92)";
      ctx.beginPath(); ctx.arc(x,y,l.r,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = "rgba(235,240,255,0.60)";
      ctx.fillRect(x-3,y-3,6,6);
    }
  }

  function tryUsePotion(state){
    const p = state.player;
    const d = p.derived();

    if (p.potionCd > 0) { state.msg = `í¬ì…˜ ì¿¨íƒ€ì„ ${p.potionCd.toFixed(1)}s`; state.msgT = 0.9; return false; }
    if (p.potions <= 0) { state.msg = "í¬ì…˜ì´ ì—†ë‹¤!"; state.msgT = 1.2; return false; }
    if (p.hp >= d.hpMax) { state.msg = "HPê°€ ì´ë¯¸ ê°€ë“í•˜ë‹¤."; state.msgT = 0.9; return false; }

    const heal = Math.max(1, Math.floor(d.hpMax * POTION_HEAL_PCT));
    const before = p.hp;
    p.hp = clamp(p.hp + heal, 0, d.hpMax);
    p.potions -= 1;
    p.potionCd = POTION_CD;

    audio.playCoin();
    state.dmgText.push(new DamageText(p.x, p.y - 72, `+${Math.floor(p.hp - before)}`, "rgba(46,229,157,0.95)"));
    state.msg = `í¬ì…˜ ì‚¬ìš©! (+${Math.floor(p.hp - before)} HP)`;
    state.msgT = 1.1;
    save(state);
    return true;
  }

  function stabilizeOverlapNoBounce(p, e){
    const dx = (p.x - e.x);
    const overlapX = (p.w/2 + e.w/2) - Math.abs(dx);
    if (overlapX <= 0) return false;

    const dir = dx === 0 ? (p.face || 1) : Math.sign(dx);
    const push = overlapX * CONTACT_SEP_STRENGTH;

    p.x += dir * (push * 0.35);
    e.x -= dir * (push * 0.65);

    p.vx *= 0.10;
    e.vx *= 0.10;

    e.vy = 0;
    if (e.groundSnap) snapToGround(e);
    return true;
  }

  // -------------------- HUD --------------------
  function drawHud(state){
    const p = state.player;
    const d = p.derived();

    ctx.globalAlpha = 0.90;
    ctx.fillStyle = "rgba(10,14,24,0.70)";
    roundRect(14, 14, 740, 110, 14, true, false);
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    roundRect(14, 14, 740, 110, 14, false, true);
    ctx.globalAlpha = 1;

    const hpPct = clamp(p.hp / d.hpMax, 0, 1);
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.fillRect(30, 34, 300, 14);
    ctx.fillStyle = "rgba(46,229,157,0.85)";
    ctx.fillRect(30, 34, 300*hpPct, 14);

    const sc = clamp(p.skillCd / 2.8, 0, 1);
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    ctx.fillRect(30, 54, 300, 10);
    ctx.fillStyle = "rgba(91,140,255,0.75)";
    ctx.fillRect(30, 54, 300*(1-sc), 10);

    const pc = clamp(p.potionCd / POTION_CD, 0, 1);
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    ctx.fillRect(30, 70, 300, 10);
    ctx.fillStyle = "rgba(255,207,91,0.75)";
    ctx.fillRect(30, 70, 300*(1-pc), 10);

    ctx.fillStyle = "rgba(235,240,255,0.92)";
    ctx.font = "bold 12px ui-monospace, Menlo, Consolas";
    ctx.fillText(`BOSS GATE | STAGE ${stageLabel(state.stageIndex)} ${state.inBossRoom ? "(BOSS)" : ""} | KILL ${state.killed}/${state.goalKills}`, 350, 38);
    ctx.fillText(`HP ${Math.floor(p.hp)}/${d.hpMax}  ATK ${d.atk} DEF ${d.def} CRIT ${d.crit}% SPD ${d.spd}`, 350, 56);
    ctx.fillText(`GOLD ${p.gold}G | í¬ì…˜ ${p.potions}/${POTION_MAX} | ê°ì •ê¶Œ ${p.appraiseTickets}`, 350, 74);
    ctx.fillText(`âš™/ESC: ë©”ë‰´  ğŸ’/I: ì¸ë²¤  ğŸª: ìƒì (ë©”ë‰´)  H/ğŸ§ª: í¬ì…˜`, 350, 92);

    const hotGear = (pointer.x>=HUD_MENU_BTN.x && pointer.x<=HUD_MENU_BTN.x+HUD_MENU_BTN.w &&
                     pointer.y>=HUD_MENU_BTN.y && pointer.y<=HUD_MENU_BTN.y+HUD_MENU_BTN.h);
    drawIconBtn(HUD_MENU_BTN.x, HUD_MENU_BTN.y, HUD_MENU_BTN.w, HUD_MENU_BTN.h, "âš™", hotGear);

    const hotPot = (pointer.x>=HUD_POTION_BTN.x && pointer.x<=HUD_POTION_BTN.x+HUD_POTION_BTN.w &&
                    pointer.y>=HUD_POTION_BTN.y && pointer.y<=HUD_POTION_BTN.y+HUD_POTION_BTN.h);
    drawIconBtn(HUD_POTION_BTN.x, HUD_POTION_BTN.y, HUD_POTION_BTN.w, HUD_POTION_BTN.h, "ğŸ§ª", hotPot);

    const hotInv = (pointer.x>=HUD_INV_BTN.x && pointer.x<=HUD_INV_BTN.x+HUD_INV_BTN.w &&
                    pointer.y>=HUD_INV_BTN.y && pointer.y<=HUD_INV_BTN.y+HUD_INV_BTN.h);
    drawIconBtn(HUD_INV_BTN.x, HUD_INV_BTN.y, HUD_INV_BTN.w, HUD_INV_BTN.h, "ğŸ’", hotInv);

    // í¬ì…˜ ê°œìˆ˜ ë±ƒì§€
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    roundRect(HUD_POTION_BTN.x+26, HUD_POTION_BTN.y+28, 20, 16, 8, true, false);
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.font = "bold 11px ui-monospace, Menlo, Consolas";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(String(state.player.potions), HUD_POTION_BTN.x+36, HUD_POTION_BTN.y+36);
    ctx.restore();

    if (state.msgT > 0 && state.msg) {
      ctx.globalAlpha = clamp(state.msgT/0.5, 0, 1);
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      roundRect(14, 130, 920-28, 36, 12, true, false);
      ctx.fillStyle = "rgba(235,240,255,0.92)";
      ctx.font = "bold 14px system-ui, -apple-system, Segoe UI";
      ctx.fillText(state.msg, 28, 154);
      ctx.globalAlpha = 1;
    }
  }

  function drawScene(state, dim=false){
    drawBackground();
    drawPlatforms(state.platforms);
    if (state.door) drawDoor(state.door);
    drawCoins(state.coins);
    drawLoot(state.loots);

    for (const e of state.enemies) {
      const x = e.x - cam.x;
      const y = e.y - cam.y;
      const flip = (e.face === -1);
      const name = e.dead ? "die" : e.anim;
      const scale = (e.tier==="boss") ? 1.45 : (e.tier==="elite" ? 1.15 : 1.0);
      slimeSheet.draw(name, x, y-8, e.animT, scale, flip, e.hitCd>0 ? 0.75 : 1);

      if (!e.dead) {
        const pct = clamp(e.hp/e.hpMax, 0,1);
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.fillRect(x-34*scale, y-56*scale, 68*scale, 8);
        ctx.fillStyle = (e.tier==="boss") ? "rgba(255,91,110,0.85)" : "rgba(46,229,157,0.85)";
        ctx.fillRect(x-34*scale, y-56*scale, 68*scale*pct, 8);
      }
    }

    const p = state.player;
    const px = p.x - cam.x;
    const py = p.y - cam.y;
    const flipP = (p.face === -1);
    playerSheet.draw(p.anim, px, py-10, p.animT, 1.15, flipP, p.inv>0 ? 0.65 : 1);

    for (const f of state.fx) f.draw(cam);
    for (const t of state.dmgText) t.draw(cam);
    for (const pa of state.parts) pa.draw(cam);

    if (dim) {
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.fillRect(0,0,VIEW_W,VIEW_H);
    }
    drawHud(state);
  }

  // -------------------- MENU / OPTIONS --------------------
  function drawMenu(state){
    drawBackground();
    const px = VIEW_W*0.5-260, py = VIEW_H*0.5-190;
    panel(px, py, 520, 380, "ë³´ìŠ¤ê²Œì´íŠ¸");

    ctx.fillStyle = "rgba(235,240,255,0.75)";
    ctx.font = "14px system-ui, -apple-system, Segoe UI";
    ctx.textAlign = "center";
    ctx.fillText("ìŠ¤í…Œì´ì§€ë¥¼ ëš«ê³ , ë³´ìŠ¤ë¬¸ì„ ë¶€ìˆ´ë¼.", VIEW_W*0.5, VIEW_H*0.5-110);
    ctx.textAlign = "left";

    const bx = VIEW_W*0.5-180, by = VIEW_H*0.5-70, bw=360, bh=52;
    const hasSave = !!load();

    btn(bx, by, bw, bh, "ìƒˆ ê²Œì„ ì‹œì‘", true);
    btn(bx, by+64, bw, bh, hasSave ? "ì´ì–´í•˜ê¸°" : "ì´ì–´í•˜ê¸°(ì €ì¥ ì—†ìŒ)", hasSave);
    btn(bx, by+128, bw, bh, "ì˜µì…˜");
    btn(bx, by+192, bw, bh, "ì €ì¥ ì‚­ì œ", false);

    if (hitBtn(bx,by,bw,bh)) startNew(state);

    if (hasSave && hitBtn(bx,by+64,bw,bh)) {
      const s = load();
      if (s) {
        const restored = revive(s);
        Object.assign(state, restored);
        applyOptions(state);
        state.gs = "PLAY";
      }
    }

    if (hitBtn(bx,by+128,bw,bh)) { state._optReturn = "MENU"; state.gs = "OPTIONS"; save(state); }

    if (hitBtn(bx,by+192,bw,bh)) {
      localStorage.removeItem(SAVE_KEY);
      state.msg = "ì €ì¥ ì‚­ì œ ì™„ë£Œ.";
      state.msgT = 1.5;
    }

    ctx.fillStyle = "rgba(235,240,255,0.55)";
    ctx.font = "12px ui-monospace, Menlo, Consolas";
    ctx.fillText("ëª¨ë°”ì¼: í„°ì¹˜ ë²„íŠ¼ / PC: ë°©í–¥í‚¤+Z/X+Space+H+I+ESC", VIEW_W*0.5-240, VIEW_H*0.5+210);
  }

  function drawOptions(state){
    drawBackground();
    panel(VIEW_W*0.5-260, VIEW_H*0.5-170, 520, 340, "ì˜µì…˜");

    const bx = VIEW_W*0.5-200, by = VIEW_H*0.5-90, bw=400, bh=52;

    btn(bx, by, bw, bh, `ìŒì†Œê±°: ${state.opt.muted ? "ON" : "OFF"}`, !state.opt.muted);
    btn(bx, by+64, bw, bh, `BGM: ${state.opt.bgm ? "ON" : "OFF"}`, state.opt.bgm);
    btn(bx, by+128, bw, bh, `SFX: ${state.opt.sfx ? "ON" : "OFF"}`, state.opt.sfx);
    btn(bx, by+212, bw, bh, "ë’¤ë¡œê°€ê¸°(ESC)", true);

    if (hitBtn(bx,by,bw,bh)) { state.opt.muted = !state.opt.muted; applyOptions(state); save(state); }
    if (hitBtn(bx,by+64,bw,bh)) { state.opt.bgm = !state.opt.bgm; applyOptions(state); save(state); }
    if (hitBtn(bx,by+128,bw,bh)) { state.opt.sfx = !state.opt.sfx; applyOptions(state); save(state); }
    if (hitBtn(bx,by+212,bw,bh)) { state.gs = "MENU"; }

    if (pressed.menu) { pressed.menu=false; state.gs="MENU"; }
  }

  // -------------------- PAUSE MENU --------------------
  function drawPause(state){
    drawScene(state, true);

    const px = VIEW_W*0.5-260;
    const py = 70;
    const pw = 520;
    const ph = 400;
    panel(px, py, pw, ph, "ì¼ì‹œì •ì§€ / ë©”ë‰´");

    const bx = VIEW_W*0.5-190;
    const by = py + 54;
    const bw = 380;
    const bh = 46;
    const gap = 10;

    const items = [
      { t:"ì¬ê°œ", hot:true, fn:()=> state.gs="PLAY" },
      { t:"ì¸ë²¤í† ë¦¬(ğŸ’/I)", hot:false, fn:()=> state.gs="INV" },
      { t:"ìƒì /ê°ì •(ğŸª)", hot:false, fn:()=> state.gs="SHOP" },
      { t:"ì˜µì…˜", hot:false, fn:()=> { state._optReturn = "PAUSE"; state.gs="OPTIONS"; save(state); } },
      { t:"ì €ì¥ í›„ íƒ€ì´í‹€ë¡œ", hot:false, fn:()=> { save(state); state.gs="MENU"; state.msg="ì €ì¥ ì™„ë£Œ. íƒ€ì´í‹€ë¡œ ì´ë™."; state.msgT=1.5; } },
    ];

    for (let i=0;i<items.length;i++){
      const y = by + i*(bh+gap);
      btn(bx, y, bw, bh, items[i].t, items[i].hot);
      if (hitBtn(bx, y, bw, bh)) items[i].fn();
    }

    ctx.fillStyle = "rgba(235,240,255,0.65)";
    ctx.font = "12px ui-monospace, Menlo, Consolas";
    ctx.fillText("ESC: ë‹«ê¸° / I: ì¸ë²¤ / (ìƒì ì—ì„œ í¬ì…˜ êµ¬ë§¤Â·ê°ì •Â·íŒë§¤)", bx, py+365);

    if (pressed.menu) { pressed.menu = false; state.gs = "PLAY"; }
    if (pressed.inv) { pressed.inv = false; state.gs = "INV"; }
  }

  // -------------------- INVENTORY --------------------
  function getAllItems(state){
    const p = state.player;
    const items = [];
    for (const s of SLOTS){
      const eq = normalizeItem(p.equip[s]);
      if (eq) items.push({ it:eq, where:"equip" });
    }
    for (const it0 of (p.invItems||[])) {
      const it = normalizeItem(it0);
      if (it) items.push({ it, where:"bag" });
    }
    return items;
  }

  function invSelect(state, id){
    state.invSelId = id;
  }

  function equipFromBag(state, itemId){
    const p = state.player;
    const idx = (p.invItems||[]).findIndex(x=>x && x.id===itemId);
    if (idx < 0) return false;
    const it = normalizeItem(p.invItems[idx]);
    if (!it) return false;
    const slot = it.slot;
    const cur = normalizeItem(p.equip[slot]);
    if (cur) p.invItems.push(cur);
    p.invItems.splice(idx,1);
    p.equip[slot] = it;
    p.autoEquipBest();
    return true;
  }

  function unequipToBag(state, slot){
    const p = state.player;
    const cur = normalizeItem(p.equip[slot]);
    if (!cur) return false;
    p.invItems.push(cur);
    p.equip[slot] = null;
    p.autoEquipBest();
    return true;
  }

  function sellItemFromBag(state, itemId){
    const p = state.player;
    const idx = (p.invItems||[]).findIndex(x=>x && x.id===itemId);
    if (idx < 0) return false;
    const it = normalizeItem(p.invItems[idx]);
    if (!it) return false;
    const price = sellPrice(it);
    p.gold += price;
    p.invItems.splice(idx,1);
    audio.playCoin();
    state.msg = `íŒë§¤: ${price}G`;
    state.msgT = 1.2;
    if (state.invSelId === itemId) state.invSelId = null;
    return true;
  }

  function appraiseOne(state, itemId){
    const p = state.player;
    const it =
      (p.invItems||[]).map(normalizeItem).find(x=>x && x.id===itemId) ||
      Object.values(p.equip).map(normalizeItem).find(x=>x && x.id===itemId);

    if (!it) return false;
    if (it.identified) { state.msg="ì´ë¯¸ ê°ì •ëœ ì•„ì´í…œ."; state.msgT=1.1; return false; }

    if (p.appraiseTickets > 0) {
      p.appraiseTickets -= 1;
      appraise(it);
      audio.playCoin();
      state.msg = "ê°ì • ì™„ë£Œ! (ê°ì •ê¶Œ -1)";
      state.msgT = 1.4;
      return true;
    }
    if (p.gold < APPRAISE_PRICE) {
      state.msg = `ê³¨ë“œ ë¶€ì¡±! (ê°ì • ${APPRAISE_PRICE}G í•„ìš”)`;
      state.msgT = 1.4;
      return false;
    }
    p.gold -= APPRAISE_PRICE;
    appraise(it);
    audio.playCoin();
    state.msg = `ê°ì • ì™„ë£Œ! (-${APPRAISE_PRICE}G)`;
    state.msgT = 1.4;
    return true;
  }

  function drawItemDetail(state, x, y, w, h, it0){
    const it = normalizeItem(it0);
    if (!it) return;

    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    roundRect(x,y,w,h,12,true,true);

    ctx.fillStyle = rarColor(it.rar);
    ctx.font = "900 16px system-ui, -apple-system, Segoe UI";
    ctx.fillText(`[${it.rar}] ${it.name} ${it.identified?"":"(ë¯¸ê°ì •)"}`, x+14, y+28);

    ctx.fillStyle = "rgba(235,240,255,0.80)";
    ctx.font = "12px ui-monospace, Menlo, Consolas";
    ctx.fillText(`${slotName(it.slot)} | iLv ${it.ilvl} | PWR ${itemPow(it)} | íŒë§¤ ${sellPrice(it)}G`, x+14, y+48);

    const baseY = y+72;
    ctx.fillStyle = "rgba(235,240,255,0.86)";
    ctx.font = "bold 13px ui-monospace, Menlo, Consolas";
    ctx.fillText(`ê¸°ë³¸: ATK ${it.stats.atk} DEF ${it.stats.def} HP ${it.stats.hp} CRIT ${it.stats.crit}% SPD ${it.stats.spd}`, x+14, baseY);

    ctx.fillStyle = "rgba(235,240,255,0.72)";
    ctx.font = "12px ui-monospace, Menlo, Consolas";
    let yy = baseY+20;

    if (!it.identified) {
      ctx.fillStyle = "rgba(255,207,91,0.88)";
      ctx.fillText("ì ì¬ ì˜µì…˜: ??? (ê°ì • í•„ìš”)", x+14, yy);
      yy += 18;
    } else if (it.aff && it.aff.length) {
      ctx.fillStyle = "rgba(91,140,255,0.85)";
      ctx.fillText("ì¶”ê°€ ì˜µì…˜:", x+14, yy); yy+=18;
      ctx.fillStyle = "rgba(235,240,255,0.75)";
      for (const a of it.aff) {
        const isPct = (a?.k||"").endsWith("P") || a?.k==="crit" || a?.k==="ls";
        ctx.fillText(`- ${a?.n||"ì˜µì…˜"} +${Number(a?.v)||0}${isPct?"%":""}`, x+24, yy);
        yy += 16;
      }
    } else {
      ctx.fillStyle = "rgba(235,240,255,0.55)";
      ctx.fillText("ì¶”ê°€ ì˜µì…˜ ì—†ìŒ", x+14, yy);
      yy += 18;
    }

    ctx.restore();
  }

  function drawInventory(state){
    drawScene(state, true);

    const px = 40, py = 54, pw = 880, ph = 430;
    panel(px, py, pw, ph, "ì¸ë²¤í† ë¦¬ (I/ESC: ë‹«ê¸°)");

    const p = state.player;

    // ìƒë‹¨ íƒ­ ë²„íŠ¼
    const tabY = py+44;
    const bInv = {x:px+18, y:tabY, w:160, h:38};
    const bShop = {x:px+18+170, y:tabY, w:160, h:38};

    btn(bInv.x,bInv.y,bInv.w,bInv.h,"ì¸ë²¤í† ë¦¬", true);
    btn(bShop.x,bShop.y,bShop.w,bShop.h,"ìƒì /ê°ì •", false);
    if (hitBtn(bShop.x,bShop.y,bShop.w,bShop.h)) state.gs="SHOP";

    // ì¢Œì¸¡: ì¥ë¹„ + ê°€ë°© ë¦¬ìŠ¤íŠ¸
    const leftX = px+18;
    const leftY = py+92;
    const leftW = 520;
    const leftH = ph-120;

    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    roundRect(leftX, leftY, leftW, leftH, 12, true, true);

    // ìš°ì¸¡: ìƒì„¸ + ë²„íŠ¼
    const rightX = leftX+leftW+16;
    const rightY = leftY;
    const rightW = pw - (rightX - px) - 18;
    const rightH = leftH;

    // ë¦¬ìŠ¤íŠ¸ ì•„ì´í…œë“¤
    const all = getAllItems(state);

    // âœ… PATCH: ì •ë ¬ ì¤‘ ì ˆëŒ€ ì•ˆ í„°ì§€ê²Œ(ì •ê·œí™” + itemPowê°€ ì•ˆì „)
    all.sort((a,b)=>{
      if (a.where !== b.where) return a.where==="equip" ? -1 : 1;
      return itemPow(b.it)-itemPow(a.it);
    });

    const rowH = 34;
    const innerPad = 12;
    const clipX = leftX+innerPad, clipY = leftY+innerPad+34, clipW = leftW-innerPad*2, clipH = leftH-innerPad*2-34;

    // í—¤ë”
    ctx.fillStyle = "rgba(235,240,255,0.88)";
    ctx.font = "bold 13px ui-monospace, Menlo, Consolas";
    ctx.fillText(`ì¥ì°©/ê°€ë°© (ìŠ¤í¬ë¡¤: ë§ˆìš°ìŠ¤íœ )`, leftX+14, leftY+28);

    // ìŠ¤í¬ë¡¤ ì²˜ë¦¬
    const maxRows = Math.floor(clipH/rowH);
    const maxScroll = Math.max(0, all.length - maxRows);
    if (pointer.wheelY !== 0) {
      const delta = Math.sign(pointer.wheelY);
      state.invScroll = clamp(state.invScroll + delta, 0, maxScroll);
    }

    // í´ë¦¬í•‘
    ctx.save();
    ctx.beginPath();
    ctx.rect(clipX, clipY, clipW, clipH);
    ctx.clip();

    for (let i=0;i<all.length;i++){
      const row = i - state.invScroll;
      if (row < 0 || row >= maxRows) continue;
      const y = clipY + row*rowH;
      const it = normalizeItem(all[i].it);
      const where = all[i].where;

      if (!it) continue;

      const isSel = (state.invSelId === it.id);
      ctx.fillStyle = isSel ? "rgba(91,140,255,0.16)" : (i%2===0 ? "rgba(255,255,255,0.03)" : "rgba(0,0,0,0)");
      ctx.fillRect(clipX, y, clipW, rowH-2);

      ctx.fillStyle = rarColor(it.rar);
      ctx.font = "bold 12px ui-monospace, Menlo, Consolas";
      ctx.fillText(where==="equip" ? "E" : "B", clipX+6, y+22);

      ctx.fillStyle = "rgba(235,240,255,0.86)";
      ctx.font = "12px ui-monospace, Menlo, Consolas";
      const txt = itemLine(it);
      ctx.fillText(txt, clipX+28, y+22);

      // í´ë¦­ ì„ íƒ
      if (pointer.clicked && pointer.x>=clipX && pointer.x<=clipX+clipW && pointer.y>=y && pointer.y<=y+rowH-2){
        invSelect(state, it.id);
      }
    }
    ctx.restore();

    // ì„ íƒëœ ì•„ì´í…œ ê°€ì ¸ì˜¤ê¸°
    const sel0 = all.find(x=>x.it && x.it.id===state.invSelId)?.it || null;
    const sel = normalizeItem(sel0);

    if (!sel) {
      ctx.fillStyle = "rgba(235,240,255,0.70)";
      ctx.font = "14px system-ui, -apple-system, Segoe UI";
      ctx.fillText("ì™¼ìª½ì—ì„œ ì•„ì´í…œì„ ì„ íƒí•´.", rightX+10, rightY+30);
    } else {
      drawItemDetail(state, rightX, rightY, rightW, rightH-120, sel);

      // ë²„íŠ¼ ì˜ì—­
      const bbY = rightY + rightH - 110;
      const bw = (rightW - 20);
      const b1 = {x:rightX+10, y:bbY, w:bw, h:40};
      const b2 = {x:rightX+10, y:bbY+46, w:bw, h:40};

      const inEquip = Object.values(p.equip).some(x=>x && x.id===sel.id);

      // 1ë²ˆ: ì¥ì°©/í•´ì œ
      if (inEquip) {
        btn(b1.x,b1.y,b1.w,b1.h, `í•´ì œ(ê°€ë°©ìœ¼ë¡œ)`, true);
        if (hitBtn(b1.x,b1.y,b1.w,b1.h)) {
          unequipToBag(state, sel.slot);
          state.msg="í•´ì œ ì™„ë£Œ";
          state.msgT=1.2;
          save(state);
        }
      } else {
        btn(b1.x,b1.y,b1.w,b1.h, `ì¥ì°©`, true);
        if (hitBtn(b1.x,b1.y,b1.w,b1.h)) {
          equipFromBag(state, sel.id);
          state.msg="ì¥ì°© ì™„ë£Œ";
          state.msgT=1.2;
          save(state);
        }
      }

      // 2ë²ˆ: ê°ì • or íŒë§¤
      if (!sel.identified) {
        const costTxt = (p.appraiseTickets>0) ? "ê°ì •(ê°ì •ê¶Œ 1)" : `ê°ì •(${APPRAISE_PRICE}G)`;
        btn(b2.x,b2.y,b2.w,b2.h, costTxt, true);
        if (hitBtn(b2.x,b2.y,b2.w,b2.h)) {
          appraiseOne(state, sel.id);
          save(state);
        }
      } else {
        const canSell = (p.invItems||[]).some(x=>x && x.id===sel.id);
        btn(b2.x,b2.y,b2.w,b2.h, canSell ? `íŒë§¤(+${sellPrice(sel)}G)` : "íŒë§¤(ì¥ì°© ì¤‘ ë¶ˆê°€)", canSell);
        if (canSell && hitBtn(b2.x,b2.y,b2.w,b2.h)) {
          sellItemFromBag(state, sel.id);
          save(state);
        }
      }
    }

    // ESC/I ì²˜ë¦¬
    if (pressed.menu) { pressed.menu=false; state.gs="PAUSE"; }
    if (pressed.inv) { pressed.inv=false; state.gs="PLAY"; }
  }

  // -------------------- SHOP --------------------
  function sellAllNormal(state){
    const p = state.player;
    const before = (p.invItems||[]).length;
    let gain = 0;
    const keep = [];
    for (const it0 of (p.invItems||[])){
      const it = normalizeItem(it0);
      if (!it) continue;
      if (it.rar === "N") gain += sellPrice(it);
      else keep.push(it);
    }
    const sold = before - keep.length;
    p.invItems = keep;
    p.gold += gain;
    if (sold>0) audio.playCoin();
    state.msg = sold>0 ? `ì¼ë°˜í…œ ${sold}ê°œ íŒë§¤ (+${gain}G)` : "íŒë§¤í•  ì¼ë°˜í…œì´ ì—†ë‹¤.";
    state.msgT = 1.4;
  }

  function appraiseAll(state){
    const p = state.player;
    const targets = (p.invItems||[]).map(normalizeItem).filter(it=>it && !it.identified);
    if (!targets.length) { state.msg="ê°ì •í•  ë¯¸ê°ì • ì•„ì´í…œì´ ì—†ë‹¤."; state.msgT=1.2; return; }

    let done = 0;
    for (const it of targets){
      if (p.appraiseTickets > 0) {
        p.appraiseTickets--;
        appraise(it);
        done++;
      } else if (p.gold >= APPRAISE_PRICE) {
        p.gold -= APPRAISE_PRICE;
        appraise(it);
        done++;
      } else {
        break;
      }
    }
    if (done>0) audio.playCoin();
    state.msg = (done>0) ? `ì¼ê´„ ê°ì • ${done}ê°œ ì™„ë£Œ` : "ê°ì •ê¶Œ/ê³¨ë“œê°€ ë¶€ì¡±í•˜ë‹¤.";
    state.msgT = 1.4;
  }

  function buyPotion(state, qty){
    const p = state.player;
    const can = Math.min(qty, POTION_MAX - p.potions);
    if (can <= 0) { state.msg="í¬ì…˜ì´ ì´ë¯¸ ê°€ë“í•˜ë‹¤."; state.msgT=1.2; return; }
    const cost = can * POTION_PRICE;
    if (p.gold < cost) { state.msg=`ê³¨ë“œ ë¶€ì¡±! (${cost}G í•„ìš”)`; state.msgT=1.3; return; }
    p.gold -= cost;
    p.potions += can;
    audio.playCoin();
    state.msg = `í¬ì…˜ ${can}ê°œ êµ¬ë§¤ (-${cost}G)`;
    state.msgT = 1.3;
  }

  function drawShop(state){
    drawScene(state, true);

    const px = 40, py = 54, pw = 880, ph = 430;
    panel(px, py, pw, ph, "ìƒì  / ê°ì • (ESC: ë’¤ë¡œ)");

    // íƒ­
    const tabY = py+44;
    const bInv = {x:px+18, y:tabY, w:160, h:38};
    const bShop = {x:px+18+170, y:tabY, w:160, h:38};

    btn(bInv.x,bInv.y,bInv.w,bInv.h,"ì¸ë²¤í† ë¦¬", false);
    btn(bShop.x,bShop.y,bShop.w,bShop.h,"ìƒì /ê°ì •", true);
    if (hitBtn(bInv.x,bInv.y,bInv.w,bInv.h)) state.gs="INV";

    const p = state.player;

    // ì¢Œì¸¡: ìƒì  ë©”ë‰´
    const leftX = px+18, leftY = py+92, leftW = 420, leftH = ph-120;
    ctx.fillStyle="rgba(255,255,255,0.06)";
    ctx.strokeStyle="rgba(255,255,255,0.12)";
    roundRect(leftX,leftY,leftW,leftH,12,true,true);

    ctx.fillStyle="rgba(235,240,255,0.88)";
    ctx.font="bold 13px ui-monospace, Menlo, Consolas";
    ctx.fillText(`GOLD ${p.gold}G | í¬ì…˜ ${p.potions}/${POTION_MAX} | ê°ì •ê¶Œ ${p.appraiseTickets}`, leftX+14, leftY+28);

    const by = leftY+46;
    const bw = leftW-28;
    const bh = 44;
    const gap = 10;

    const b1 = {x:leftX+14, y:by, w:bw, h:bh};
    const b2 = {x:leftX+14, y:by+(bh+gap), w:bw, h:bh};
    const b3 = {x:leftX+14, y:by+2*(bh+gap), w:bw, h:bh};
    const b4 = {x:leftX+14, y:by+3*(bh+gap), w:bw, h:bh};
    const b5 = {x:leftX+14, y:by+4*(bh+gap), w:bw, h:bh};

    btn(b1.x,b1.y,b1.w,b1.h, `í¬ì…˜ 1ê°œ êµ¬ë§¤ (${POTION_PRICE}G)`, true);
    btn(b2.x,b2.y,b2.w,b2.h, `í¬ì…˜ 3ê°œ êµ¬ë§¤ (${POTION_PRICE*3}G)`, true);
    btn(b3.x,b3.y,b3.w,b3.h, `ë¯¸ê°ì • ì¼ê´„ ê°ì • (ê°ì •ê¶Œ/ê³¨ë“œ)`, true);
    btn(b4.x,b4.y,b4.w,b4.h, `ì¼ë°˜í…œ(N) ì¼ê´„ íŒë§¤`, false);
    btn(b5.x,b5.y,b5.w,b5.h, `ë’¤ë¡œê°€ê¸°(ESC)`, true);

    if (hitBtn(b1.x,b1.y,b1.w,b1.h)) { buyPotion(state,1); save(state); }
    if (hitBtn(b2.x,b2.y,b2.w,b2.h)) { buyPotion(state,3); save(state); }
    if (hitBtn(b3.x,b3.y,b3.w,b3.h)) { appraiseAll(state); save(state); }
    if (hitBtn(b4.x,b4.y,b4.w,b4.h)) { sellAllNormal(state); save(state); }
    if (hitBtn(b5.x,b5.y,b5.w,b5.h)) { state.gs="PAUSE"; }

    // ìš°ì¸¡: ì•ˆë‚´ + ë¯¸ê°ì • ëª©ë¡
    const rightX = leftX+leftW+16, rightY=leftY, rightW=pw-(rightX-px)-18, rightH=leftH;
    ctx.fillStyle="rgba(255,255,255,0.06)";
    ctx.strokeStyle="rgba(255,255,255,0.12)";
    roundRect(rightX,rightY,rightW,rightH,12,true,true);

    ctx.fillStyle="rgba(235,240,255,0.88)";
    ctx.font="bold 13px ui-monospace, Menlo, Consolas";
    ctx.fillText("ë¯¸ê°ì • ì•„ì´í…œ ëª©ë¡", rightX+14, rightY+28);

    const list = (p.invItems||[]).map(normalizeItem).filter(it=>it && !it.identified);
    ctx.fillStyle="rgba(235,240,255,0.60)";
    ctx.font="12px ui-monospace, Menlo, Consolas";
    ctx.fillText(`ê°œìˆ˜: ${list.length} | ê°ì •ê¶Œ ìš°ì„  ì‚¬ìš©, ì—†ìœ¼ë©´ 1ê°œë‹¹ ${APPRAISE_PRICE}G`, rightX+14, rightY+48);

    const rowH = 28;
    const clipX = rightX+12, clipY = rightY+64, clipW = rightW-24, clipH = rightH-76;
    const maxRows = Math.floor(clipH/rowH);
    const maxScroll = Math.max(0, list.length - maxRows);

    if (pointer.wheelY !== 0) {
      const delta = Math.sign(pointer.wheelY);
      state.shopScroll = clamp(state.shopScroll + delta, 0, maxScroll);
    }

    ctx.save();
    ctx.beginPath(); ctx.rect(clipX,clipY,clipW,clipH); ctx.clip();
    for (let i=0;i<list.length;i++){
      const row = i - state.shopScroll;
      if (row<0 || row>=maxRows) continue;
      const y = clipY + row*rowH;
      const it = list[i];

      ctx.fillStyle = (i%2===0) ? "rgba(255,255,255,0.03)" : "rgba(0,0,0,0)";
      ctx.fillRect(clipX,y,clipW,rowH-2);

      ctx.fillStyle = rarColor(it.rar);
      ctx.font="bold 12px ui-monospace, Menlo, Consolas";
      ctx.fillText(`[${it.rar}]`, clipX+6, y+19);

      ctx.fillStyle="rgba(235,240,255,0.80)";
      ctx.font="12px ui-monospace, Menlo, Consolas";
      ctx.fillText(`${slotName(it.slot)} | ${it.name} | iLv ${it.ilvl} | ê°ì • í•„ìš”`, clipX+62, y+19);

      // í´ë¦­í•˜ë©´ 1ê°œ ê°ì •
      const bX = clipX + clipW - 92;
      const bY = y + 3;
      const bW = 84;
      const bH = 22;

      const can = (p.appraiseTickets>0) || (p.gold>=APPRAISE_PRICE);
      ctx.fillStyle = can ? "rgba(91,140,255,0.22)" : "rgba(255,255,255,0.06)";
      ctx.strokeStyle = can ? "rgba(91,140,255,0.52)" : "rgba(255,255,255,0.10)";
      roundRect(bX,bY,bW,bH,10,true,true);
      ctx.fillStyle = "rgba(235,240,255,0.92)";
      ctx.font="bold 12px system-ui, -apple-system, Segoe UI";
      ctx.fillText("ê°ì •", bX+24, bY+16);

      if (pointer.clicked && pointer.x>=bX && pointer.x<=bX+bW && pointer.y>=bY && pointer.y<=bY+bH) {
        appraiseOne(state, it.id);
        save(state);
      }
    }
    ctx.restore();

    if (pressed.menu) { pressed.menu=false; state.gs="PAUSE"; }
    if (pressed.inv) { pressed.inv=false; state.gs="INV"; }
  }

  // -------------------- PLAY update --------------------
  function updatePlay(state, dt){
    const p = state.player;
    const d = p.derived();

    p.atkCd = Math.max(0, p.atkCd - dt);
    p.skillCd = Math.max(0, p.skillCd - dt);
    p.inv = Math.max(0, p.inv - dt);
    p.hitCd = Math.max(0, p.hitCd - dt);
    p.attackLock = Math.max(0, p.attackLock - dt);
    p.potionCd = Math.max(0, p.potionCd - dt);

    const ax = moveAxis();
    if (p.attackLock > 0 && p.onGround) p.vx = 0;
    else p.vx = ax * d.spd * dt;
    if (ax !== 0) p.face = ax > 0 ? 1 : -1;

    if (pressed.jump && p.onGround) {
      p.vy = -520;
      p.onGround = false;
    }
    pressed.jump = false;

    if (pressed.potion) tryUsePotion(state);
    pressed.potion = false;

    p.vy += 1200 * dt;
    collidePlatforms(p, state.platforms);

    if (p.inv > 0) p.anim = "hurt";
    else if (!p.onGround) p.anim = "jump";
    else if (Math.abs(ax) > 0.05 && p.attackLock <= 0) p.anim = "run";
    else p.anim = "idle";

    p.animT += dt;
    if (p.anim !== state._prevAnimP) { p.animT = 0; state._prevAnimP = p.anim; }

    const doAtk = wantAttack();
    const doSkl = wantSkill();

    // ê³µê²©(Z)
    if (doAtk && p.atkCd <= 0) {
      p.atkCd = 0.30;
      p.anim = "attack"; p.animT = 0;
      p.attackLock = Math.max(p.attackLock, ATTACK_LOCK_ATK);

      const hx = p.x + p.face * 46;
      const hy = p.y - 10;
      const hw = 72, hh = 52;

      let hit = 0;
      for (const e of state.enemies) {
        if (e.dead) continue;
        if (aabb(hx - hw/2, hy - hh/2, hw, hh, e.x - e.w/2, e.y - e.h/2, e.w, e.h)) {
          const { dmg, crit } = damageCalc(d.atk, e.def, d.crit, 1.05);
          e.hp = clamp(e.hp - dmg, 0, e.hpMax);
          e.hitCd = 0.12;

          e.vy = 0;
          snapToGround(e);

          hit++;
          spawnHitFX(state, e.x, e.y - 14);
          state.dmgText.push(new DamageText(
            e.x, e.y - 64, `${crit ? "âœ¦" : ""}${dmg}`,
            crit ? "rgba(255,235,120,0.95)" : "rgba(235,240,255,0.92)"
          ));

          if (e.hp <= 0) {
            e.dead = true; e.dieT = 0;
            dropRewards(state, e);
            state.killed++;
            p.kills++;
          }
        }
      }
      if (hit === 0) audio.playHit();
    }
    pressed.atk = false;

    // ìŠ¤í‚¬(X)
    if (doSkl && p.skillCd <= 0) {
      p.skillCd = 2.8;
      p.atkCd = 0.42;
      p.anim = "attack"; p.animT = 0;
      p.attackLock = Math.max(p.attackLock, ATTACK_LOCK_SKL);

      const hx = p.x + p.face * 78;
      const hy = p.y - 12;
      const hw = 160, hh = 76;

      for (const e of state.enemies) {
        if (e.dead) continue;
        if (aabb(hx - hw/2, hy - hh/2, hw, hh, e.x - e.w/2, e.y - e.h/2, e.w, e.h)) {
          const { dmg, crit } = damageCalc(d.atk, e.def, d.crit, 1.85);
          e.hp = clamp(e.hp - dmg, 0, e.hpMax);
          e.hitCd = 0.16;

          e.vy = 0;
          snapToGround(e);

          spawnHitFX(state, e.x, e.y - 14);
          state.dmgText.push(new DamageText(
            e.x, e.y - 64, `${crit ? "âœ¦" : ""}${dmg}`,
            "rgba(255,207,91,0.95)"
          ));

          if (e.hp <= 0) {
            e.dead = true; e.dieT = 0;
            dropRewards(state, e);
            state.killed++;
            p.kills++;
          }
        }
      }
    }
    pressed.skill = false;

    // ì  AI + ì ‘ì´‰ íŒì •
    for (const e of state.enemies) {
      if (e.dead) { e.dieT += dt; continue; }
      e.hitCd = Math.max(0, e.hitCd - dt);
      e.aiT += dt;
      e.jumpCd = Math.max(0, e.jumpCd - dt);

      const dx = p.x - e.x;
      const ad = Math.abs(dx);
      const chase = ad < 360 || (e.tier==="boss" && ad < 520);
      const dir = dx > 0 ? 1 : -1;
      e.face = dir;

      e.vx = chase ? (dir * e.spd * dt * 0.75) : (Math.sin(e.aiT*1.2) * e.spd * dt * 0.28);
      e.vy += 1100 * dt;

      collidePlatforms(e, state.platforms);
      snapToGround(e);

      const overlapped = aabb(
        p.x - p.w/2, p.y - p.h/2, p.w, p.h,
        e.x - e.w/2, e.y - e.h/2, e.w, e.h
      );

      if (overlapped) stabilizeOverlapNoBounce(p, e);

      if (overlapped && p.inv <= 0 && p.hitCd <= 0) {
        const { dmg } = damageCalc(e.atk, d.def, 0, 1);

        p.hp = clamp(p.hp - dmg, 0, d.hpMax);
        p.inv = 0.55;
        p.hitCd = CONTACT_DAMAGE_COOLDOWN;

        audio.playHit();
        state.dmgText.push(new DamageText(p.x, p.y - 64, `-${dmg}`, "rgba(255,91,110,0.95)"));
        p.x += -e.face * 14;

        if (p.hp <= 0) {
          const lost = Math.round(p.gold * 0.08);
          p.gold = Math.max(0, p.gold - lost);
          p.hp = d.hpMax;
          state.gs = "MENU";
          state.msg = `ë³´ìŠ¤ê²Œì´íŠ¸ì—ì„œ ì“°ëŸ¬ì¡Œë‹¤â€¦ ${lost}G ìƒìŒ.`;
          state.msgT = 2.0;
          save(state);
          return;
        }
      }

      if (e.dead) e.anim = "die";
      else if (e.hitCd > 0) e.anim = "hurt";
      else if (!e.onGround) e.anim = "run";
      else if (chase) e.anim = "run";
      else e.anim = "idle";

      e.animT += dt;
      if (e.anim !== e._prevAnim) { e.animT = 0; e._prevAnim = e.anim; }
    }

    if (state.killed >= state.goalKills) ensureDoor(state);

    // ì½”ì¸ ìˆ˜ì§‘
    for (let i=state.coins.length-1;i>=0;i--){
      const c = state.coins[i];
      c.t += dt;
      c.vy += 1100*dt;
      c.x += c.vx*dt;
      c.y += c.vy*dt;
      if (c.y > GROUND_Y - 12) {
        c.y = GROUND_Y - 12;
        c.vy *= -0.22;
        c.vx *= 0.55;
      }
      if (dist(c.x,c.y, p.x, p.y-20) < 38) {
        p.gold += c.amount;
        state.coins.splice(i,1);
        audio.playCoin();
      }
    }

    // ë£¨íŒ…
    for (let i=state.loots.length-1;i>=0;i--){
      const l = state.loots[i];
      l.t += dt;
      l.vy += 1100*dt;
      l.x += l.vx*dt;
      l.y += l.vy*dt;
      if (l.y > GROUND_Y - 16) {
        l.y = GROUND_Y - 16;
        l.vy *= -0.18;
        l.vx *= 0.45;
      }
      if (dist(l.x,l.y, p.x, p.y-20) < 38) {
        p.invItems.push(normalizeItem(l.item));
        state.loots.splice(i,1);
        state.msg = `íšë“: [${l.item?.rar||"N"}] ${l.item?.name||"(ì•„ì´í…œ)"}${l.item?.identified?"":"(ë¯¸ê°ì •)"}`;
        state.msgT = 1.5;
      }
    }

    // ë¬¸ ì§„ì…
    if (state.door) {
      const d0 = state.door;
      if (aabb(p.x - p.w/2, p.y - p.h/2, p.w, p.h, d0.x, d0.y, d0.w, d0.h)) {
        stageClearReward(state);
        state.stageIndex += 1;
        state.player.stage = state.stageIndex;
        rebuildStage(state);
        save(state);
      }
    }

    for (const f of state.fx) f.update(dt);
    state.fx = state.fx.filter(x => !x.dead());
    for (const t of state.dmgText) t.update(dt);
    state.dmgText = state.dmgText.filter(x => !x.dead());
    for (const pa of state.parts) pa.update(dt);
    state.parts = state.parts.filter(x => !x.dead());

    if (state.msgT > 0) state.msgT -= dt;

    cam.y = CAM_Y;
    const targetX = clamp(p.x - VIEW_W*0.45, 0, WORLD.w - VIEW_W);
    state.camX = lerp(state.camX, targetX, smoothFactor(dt, 18));
    cam.x = state.camX;

    // HUD í´ë¦­(âš™/ğŸ§ª/ğŸ’)
    const hotGear = (pointer.x>=HUD_MENU_BTN.x && pointer.x<=HUD_MENU_BTN.x+HUD_MENU_BTN.w &&
                     pointer.y>=HUD_MENU_BTN.y && pointer.y<=HUD_MENU_BTN.y+HUD_MENU_BTN.h);

    if (pointer.clicked && hotGear) {
      state.gs = "PAUSE";
      save(state);
    }

    const hotPotionHud = (pointer.x>=HUD_POTION_BTN.x && pointer.x<=HUD_POTION_BTN.x+HUD_POTION_BTN.w &&
                          pointer.y>=HUD_POTION_BTN.y && pointer.y<=HUD_POTION_BTN.y+HUD_POTION_BTN.h);
    if (pointer.clicked && hotPotionHud) { tryUsePotion(state); }

    const hotInv = (pointer.x>=HUD_INV_BTN.x && pointer.x<=HUD_INV_BTN.x+HUD_INV_BTN.w &&
                    pointer.y>=HUD_INV_BTN.y && pointer.y<=HUD_INV_BTN.y+HUD_INV_BTN.h);
    if (pointer.clicked && hotInv) { state.gs = "INV"; save(state); }

    // í‚¤ë¡œ ë©”ë‰´/ì¸ë²¤
    if (pressed.menu) { pressed.menu = false; state.gs = "PAUSE"; save(state); return; }
    if (pressed.inv) { pressed.inv = false; state.gs = "INV"; save(state); return; }
  }

  // -------------------- Revive --------------------
  function revive(raw){
    const st = freshState();

    st.gs = raw?.gs || "MENU";
    st.opt = raw?.opt || st.opt;

    st.player = new Player();
    Object.assign(st.player, raw?.player || {});

    st.player.invItems ??= [];
    st.player.equip ??= { weapon:null, armor:null, ring:null };
    st.player.appraiseTickets ??= 0;

    // âœ… PATCH: ë¶ˆëŸ¬ì˜¨ ì•„ì´í…œ ì •ê·œí™”(ì—¬ê¸°ê°€ í•µì‹¬)
    st.player.invItems = (raw?.player?.invItems || st.player.invItems || [])
      .map(normalizeItem)
      .filter(Boolean);

    st.player.equip = (raw?.player?.equip || st.player.equip || { weapon:null, armor:null, ring:null });
    for (const s of SLOTS) st.player.equip[s] = normalizeItem(st.player.equip[s]);

    st.stageIndex = raw?.stageIndex ?? st.stageIndex;
    st.inBossRoom = raw?.inBossRoom ?? st.inBossRoom;

    rebuildStage(st);

    st.player.gold = raw?.player?.gold ?? st.player.gold;
    st.player.hp = raw?.player?.hp ?? st.player.hp;

    st.killed = raw?.killed ?? 0;
    st.goalKills = raw?.goalKills ?? st.goalKills;

    st.msg = raw?.msg ?? st.msg;
    st.msgT = raw?.msgT ?? 0;

    st.invSelId = raw?.invSelId ?? null;
    st.invScroll = raw?.invScroll ?? 0;
    st.shopScroll = raw?.shopScroll ?? 0;

    st.t = 0;
    st.camX = raw?.camX ?? 0;

    // ì¥ë¹„/ì²´ë ¥ ì•ˆì „ ë³´ì •
    st.player.autoEquipBest();

    return st;
  }

  // -------------------- Main Loop --------------------
  let state = load() ? revive(load()) : freshState();
  applyOptions(state);
  if (state.gs === "PLAY") rebuildStage(state);

  let last = performance.now();

  function loop(t){
    const dt = Math.min(0.033, (t - last)/1000);
    last = t;

    try {
      state.t += dt;

      if (state.gs === "PLAY") updatePlay(state, dt);

      state.updatedAt = isoNow();
      if (Math.random() < 0.03) save(state);

      ctx.clearRect(0,0,VIEW_W,VIEW_H);

      if (state.gs === "MENU") drawMenu(state);
      else if (state.gs === "OPTIONS") drawOptions(state);
      else if (state.gs === "PAUSE") drawPause(state);
      else if (state.gs === "INV") drawInventory(state);
      else if (state.gs === "SHOP") drawShop(state);
      else drawScene(state);

      // ESC ë™ì‘(ìƒíƒœë³„)
      if (pressed.menu) {
        pressed.menu = false;
        if (state.gs === "OPTIONS") state.gs = "MENU";
        else if (state.gs === "INV" || state.gs === "SHOP") state.gs = "PAUSE";
        else if (state.gs === "PAUSE") state.gs = "PLAY";
        else if (state.gs === "PLAY") state.gs = "PAUSE";
      }

    } catch (err) {
      console.error("[BOSS GATE] Loop error:", err);

      // âœ… íŒ¨ë‹‰ ë³µêµ¬: ë¨¹í†µ ë°©ì§€ + íƒ€ì´í‹€ë¡œ ë³µê·€(ESCê°€ ì•ˆ ë¨¹ëŠ” ìµœì•… ìƒíƒœ ë°©ì§€)
      try {
        state.gs = "MENU";
        state.msg = "ì—ëŸ¬ê°€ ë°œìƒí•´ íƒ€ì´í‹€ë¡œ ì´ë™í–ˆì–´. (ì €ì¥ ë°ì´í„°ê°€ ê¹¨ì¡Œì„ ìˆ˜ ìˆìŒ: íƒ€ì´í‹€ì—ì„œ 'ì €ì¥ ì‚­ì œ' ê¶Œì¥)";
        state.msgT = 2.6;
        save(state);
      } catch {}
    }

    pointer.clicked = false;
    pointer.wheelY = 0;
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // -------------------- (ì°¸ê³ ) ê°•ì œ ì €ì¥ ì‚­ì œ - ì½˜ì†”ìš© --------------------
  // localStorage.removeItem("boss_gate_web_v11_full_shop_inv"); location.reload();

})();
</script>
</body>
</html>
