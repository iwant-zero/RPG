<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Î≥¥Ïä§Í≤åÏù¥Ìä∏ (BOSS GATE)</title>
  <link rel="stylesheet" href="./style.css" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
</head>

<body>
  <div id="wrap">
    <div id="stage">
      <canvas id="game" width="960" height="540"></canvas>
    </div>
  </div>

  <!-- ‚úÖ ÌÑ∞Ïπò Î≤ÑÌäº(Î∑∞Ìè¨Ìä∏ fixed) -->
  <div id="touch" aria-hidden="true">
    <div class="btn" id="b-left" data-k="left">‚óÄ</div>
    <div class="btn" id="b-right" data-k="right">‚ñ∂</div>

    <div class="btn" id="b-jump" data-k="jump">‚§í</div>
    <div class="btn" id="b-potion" data-k="potion">üß™</div>
    <div class="btn" id="b-atk" data-k="atk">Z</div>
    <div class="btn" id="b-skill" data-k="skill">X</div>

    <div class="btn" id="b-inv" data-k="inv">üéí</div>
    <div class="btn" id="b-menu" data-k="menu">‚öô</div>
  </div>

<script>
(() => {
  "use strict";

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d", { alpha: false });

  const VIEW_W = 960;
  const VIEW_H = 540;

  function getDpr() { return Math.max(1, Math.min(2.5, window.devicePixelRatio || 1)); }
  function resize() {
    const dpr = getDpr();
    canvas.width = Math.floor(VIEW_W * dpr);
    canvas.height = Math.floor(VIEW_H * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.imageSmoothingEnabled = true;
  }
  window.addEventListener("resize", resize, { passive: true });
  resize();

  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const rand = (a, b) => Math.random() * (b - a) + a;
  const randi = (a, b) => Math.floor(rand(a, b + 1));
  const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
  const dist = (ax, ay, bx, by) => Math.hypot(ax - bx, ay - by);
  const isoNow = () => new Date().toISOString();
  const lerp = (a,b,t)=>a+(b-a)*t;
  function smoothFactor(dt, sharpness=18){ return 1 - Math.pow(0.001, dt*sharpness); }

  // ‚úÖ Î∏åÎùºÏö∞Ï†Ä Í∏∞Î≥∏ ÎèôÏûë(Ïä§ÌÅ¨Î°§/Îí§Î°úÍ∞ÄÍ∏∞ Îì±) Î∞©ÏßÄ
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (["arrowleft","arrowright","arrowup"," ","z","x","escape","i","p","h","enter","backspace"].includes(k)) {
      e.preventDefault();
      e.stopPropagation();
    }
  }, { passive:false });

  // -------------------- Save/Load (ÏàòÎèô Ï†ÄÏû• Ï†ÑÏö©) --------------------
  const SAVE_KEY = "boss_gate_web_v11_full_shop_inv";

  // ‚úÖ Ï†ÄÏû•: "Ï†ÄÏû• Î≤ÑÌäº" ÎàåÎ†ÄÏùÑ ÎïåÎßå Ìò∏Ï∂úÌïúÎã§.
  function saveGame(state) {
    try {
      const p = state.player;
      const payload = {
        ver: state.ver || 11,
        game: state.game || "Î≥¥Ïä§Í≤åÏù¥Ìä∏ (BOSS GATE)",
        createdAt: state.createdAt || isoNow(),
        updatedAt: isoNow(),

        // ‚úÖ UI ÏÉÅÌÉú Ï†ÄÏû• Í∏àÏßÄ: Î°úÎìú Ïãú Î¨¥Ï°∞Í±¥ PLAYÎ°ú Î≥µÍµ¨ (Î¨¥ÌïúÎ£®ÌîÑ Î∞©ÏßÄ)
        gs: "PLAY",

        opt: state.opt || { muted:false, bgm:true, sfx:true },

        stageIndex: state.stageIndex || 1,
        inBossRoom: !!state.inBossRoom,

        player: {
          // ÏúÑÏπò/ÏÜçÎèÑÎäî Î≥µÍµ¨ ÌïÑÏöî ÏóÜÏúºÎãà ÏµúÏÜåÎßå Ï†ÄÏû•
          hp: p.hp,
          hpBase: p.hpBase, atkBase: p.atkBase, defBase: p.defBase, critBase: p.critBase, spdBase: p.spdBase,

          potions: p.potions,
          gold: p.gold,
          stage: state.stageIndex || p.stage || 1,
          kills: p.kills || 0,

          appraiseTickets: p.appraiseTickets || 0,

          // Ïù∏Î≤§/Ïû•ÎπÑ
          invItems: p.invItems || [],
          equip: p.equip || { weapon:null, armor:null, ring:null },
        },

        killed: state.killed || 0,
        goalKills: state.goalKills || 10,
      };

      localStorage.setItem(SAVE_KEY, JSON.stringify(payload));
      state.msg = "Ï†ÄÏû• ÏôÑÎ£å.";
      state.msgT = 1.4;
      state._dirty = false;
    } catch {
      state.msg = "Ï†ÄÏû• Ïã§Ìå®(Î∏åÎùºÏö∞Ï†Ä Ï†ÄÏû•Í≥µÍ∞Ñ ÌôïÏù∏)";
      state.msgT = 1.6;
    }
  }

  function load() {
    try {
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch { return null; }
  }

  function markDirty(state){ state._dirty = true; }

  // -------------------- Audio --------------------
  class AudioMan {
    constructor() {
      this.ctx = null; this.master=null; this.bgmGain=null; this.sfxGain=null;
      this.unlocked = false;
      this.muted = false; this.bgmOn = true; this.sfxOn = true;

      this._bases = { bgm: "./assets/bgm", hit: "./assets/sfx_hit", coin: "./assets/sfx_coin" };
      this._exts = [".m4a", ".mp3", ".mp4"];

      this.files = { bgm:new Audio(), hit:new Audio(), coin:new Audio() };
      this.files.bgm.loop = true;

      for (const k of Object.keys(this.files)) {
        const a = this.files[k];
        a.preload = "auto";
        a.volume = (k === "bgm") ? 0.55 : 0.65;
      }

      this._picked = { bgm:null, hit:null, coin:null };
      this.preResolveAll().catch(()=>{});
    }

    _scoreCanPlay(ext){
      const test = document.createElement("audio");
      const map = {
        ".mp3": ["audio/mpeg"],
        ".m4a": ["audio/mp4", "audio/aac"],
        ".mp4": ["audio/mp4", "video/mp4"],
      };
      const mimes = map[ext] || [];
      let best = 0;
      for (const m of mimes){
        const r = test.canPlayType(m);
        if (r === "probably") best = Math.max(best, 2);
        else if (r === "maybe") best = Math.max(best, 1);
      }
      return best;
    }

    _candidateUrls(base){
      const scored = this._exts.map((ext, idx) => ({
        url: base + ext,
        score: this._scoreCanPlay(ext),
        idx
      })).sort((a,b)=> (b.score - a.score) || (a.idx - b.idx));
      return scored.map(x=>x.url);
    }

    async _exists(url){
      try {
        const r = await fetch(url, { method:"HEAD", cache:"no-cache" });
        if (r.ok) return true;
      } catch {}
      try {
        const r2 = await fetch(url, { method:"GET", cache:"no-cache" });
        return r2.ok;
      } catch {}
      return false;
    }

    async resolve(key){
      if (this._picked[key]) return this._picked[key];

      const base = this._bases[key];
      const urls = this._candidateUrls(base);

      for (const url of urls){
        if (await this._exists(url)) {
          this._picked[key] = url;
          this._applySource(key, url);
          return url;
        }
      }

      const fallback = urls[0] || (base + ".mp3");
      this._picked[key] = fallback;
      this._applySource(key, fallback);
      return fallback;
    }

    _applySource(key, url){
      const a = this.files[key];
      if (!a) return;
      if (a.src && a.src.endsWith(url)) return;
      a.src = url;
      if (key === "bgm") a.loop = true;
      a.load();
    }

    async preResolveAll(){
      await Promise.all([ this.resolve("bgm"), this.resolve("hit"), this.resolve("coin") ]);
    }

    ensureCtx() {
      if (this.ctx) return;
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) return;
      this.ctx = new AC();
      this.master = this.ctx.createGain();
      this.bgmGain = this.ctx.createGain();
      this.sfxGain = this.ctx.createGain();
      this.master.connect(this.ctx.destination);
      this.bgmGain.connect(this.master);
      this.sfxGain.connect(this.master);
      this.master.gain.value = 0.9;
      this.bgmGain.gain.value = 0.45;
      this.sfxGain.gain.value = 0.75;
    }

    async unlock() {
      if (this.unlocked) return;
      this.ensureCtx();
      try { if (this.ctx && this.ctx.state !== "running") await this.ctx.resume(); } catch {}
      this.unlocked = true;

      if (this.ctx) {
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        g.gain.value = 0.0001;
        o.connect(g); g.connect(this.master);
        o.start(); o.stop(this.ctx.currentTime + 0.02);
      }
    }

    setMuted(v) {
      this.muted = v;
      if (this.master) this.master.gain.value = v ? 0 : 0.9;
      for (const a of Object.values(this.files)) a.muted = v;
    }

    beep(freq, dur, type="square", vol=0.2) {
      if (!this.sfxOn || this.muted) return;
      this.ensureCtx();
      if (!this.ctx) return;
      const t0 = this.ctx.currentTime;
      const o = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      o.connect(g); g.connect(this.sfxGain);
      o.start(t0); o.stop(t0 + dur + 0.02);
    }

    async _safePlay(key, fallbackBeep){
      if (this.muted) return false;
      await this.resolve(key);
      const a = this.files[key];
      try {
        a.currentTime = 0;
        await a.play();
        return true;
      } catch {
        this._picked[key] = null;
        await this.resolve(key);
        try {
          a.currentTime = 0;
          await a.play();
          return true;
        } catch {
          if (fallbackBeep) fallbackBeep();
          return false;
        }
      }
    }

    async startBgm() {
      if (!this.bgmOn || this.muted) return;
      const ok = await this._safePlay("bgm", () => {
        this.ensureCtx();
        if (!this.ctx) return;
        if (this._bgmNode) return;
        const t0 = this.ctx.currentTime;
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        o.type = "sine";
        g.gain.value = 0.0001;
        o.connect(g); g.connect(this.bgmGain);
        const notes = [220, 277.18, 329.63, 392.0, 329.63, 277.18];
        for (let i=0;i<999;i++){
          const f = notes[i % notes.length] * (i % 12 === 0 ? 0.5 : 1);
          o.frequency.setValueAtTime(f, t0 + i*0.22);
        }
        g.gain.exponentialRampToValueAtTime(0.12, t0 + 0.12);
        o.start(t0);
        this._bgmNode = { o, g };
      });
      if (ok) {
        const bgm = this.files.bgm;
        bgm.loop = true;
        bgm.volume = 0.55;
      }
    }

    stopBgm() {
      const bgm = this.files.bgm;
      try { bgm.pause(); bgm.currentTime = 0; } catch {}
      if (this._bgmNode && this.ctx) {
        try { this._bgmNode.o.stop(); } catch {}
        this._bgmNode = null;
      }
    }

    async playHit() {
      if (!this.sfxOn || this.muted) return;
      await this._safePlay("hit", () => {
        this.beep(220, 0.06, "square", 0.18);
        this.beep(120, 0.08, "triangle", 0.12);
      });
    }

    async playCoin() {
      if (!this.sfxOn || this.muted) return;
      await this._safePlay("coin", () => {
        this.beep(880, 0.05, "triangle", 0.12);
        this.beep(1320, 0.06, "sine", 0.10);
      });
    }
  }

  const audio = new AudioMan();

  const unlockOnce = async () => {
    await audio.unlock();
    await audio.startBgm();
    window.removeEventListener("pointerdown", unlockOnce);
    window.removeEventListener("keydown", unlockOnce);
  };
  window.addEventListener("pointerdown", unlockOnce, { passive: true });
  window.addEventListener("keydown", unlockOnce, { passive: true });

  // -------------------- Input --------------------
  const keys = new Set();
  const pressed = { jump:false, atk:false, skill:false, menu:false, inv:false, potion:false };

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    keys.add(k);

    if (k === " " || k === "arrowup") pressed.jump = true;
    if (k === "z") pressed.atk = true;
    if (k === "x") pressed.skill = true;
    if (k === "escape" || k === "p") pressed.menu = true;
    if (k === "i") pressed.inv = true;
    if (k === "h") pressed.potion = true;
  }, { passive:false });

  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()), { passive:true });

  // ‚úÖ Touch input
  const touch = document.getElementById("touch");
  const touchDown = new Set();
  function setTouchKey(name, down) {
    if (down) touchDown.add(name);
    else touchDown.delete(name);
  }
  if (touch) {
    touch.addEventListener("pointerdown", (e) => {
      const t = e.target;
      if (!(t instanceof HTMLElement)) return;
      const k = t.getAttribute("data-k");
      if (!k) return;
      e.preventDefault();
      t.setPointerCapture(e.pointerId);
      setTouchKey(k, true);
      if (k === "jump") pressed.jump = true;
      if (k === "atk") pressed.atk = true;
      if (k === "skill") pressed.skill = true;
      if (k === "menu") pressed.menu = true;
      if (k === "inv") pressed.inv = true;
      if (k === "potion") pressed.potion = true;
    }, { passive:false });

    touch.addEventListener("pointerup", (e) => {
      const t = e.target;
      if (!(t instanceof HTMLElement)) return;
      const k = t.getAttribute("data-k");
      if (!k) return;
      e.preventDefault();
      setTouchKey(k, false);
    }, { passive:false });

    touch.addEventListener("pointercancel", () => touchDown.clear(), { passive:true });
  }

  function moveAxis() {
    let x = 0;
    if (keys.has("arrowleft") || keys.has("a")) x -= 1;
    if (keys.has("arrowright") || keys.has("d")) x += 1;
    if (touchDown.has("left")) x -= 1;
    if (touchDown.has("right")) x += 1;
    return clamp(x, -1, 1);
  }
  function wantAttack() { return pressed.atk || keys.has("z") || touchDown.has("atk"); }
  function wantSkill() { return pressed.skill || keys.has("x") || touchDown.has("skill"); }

  // -------------------- Pointer (canvas UI) --------------------
  let pointer = { x:0, y:0, down:false, clicked:false, wheelY:0 };
  function toLogicalXY(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const lx = (clientX - rect.left) / rect.width * VIEW_W;
    const ly = (clientY - rect.top) / rect.height * VIEW_H;
    return { x: lx, y: ly };
  }
  canvas.addEventListener("pointerdown", (e) => {
    const p = toLogicalXY(e.clientX, e.clientY);
    pointer.x = p.x; pointer.y = p.y;
    pointer.down = true;
    pointer.clicked = true;
  }, { passive:true });
  canvas.addEventListener("pointerup", () => { pointer.down = false; }, { passive:true });
  canvas.addEventListener("pointermove", (e) => {
    const p = toLogicalXY(e.clientX, e.clientY);
    pointer.x = p.x; pointer.y = p.y;
  }, { passive:true });
  canvas.addEventListener("wheel", (e) => {
    e.preventDefault();
    pointer.wheelY += e.deltaY;
  }, { passive:false });

  function hitBtn(x,y,w,h){
    return pointer.clicked && pointer.x>=x && pointer.x<=x+w && pointer.y>=y && pointer.y<=y+h;
  }

  // -------------------- Assets --------------------
  function loadImage(src) {
    const img = new Image();
    const obj = { img, ok: false };
    img.onload = () => obj.ok = true;
    img.onerror = () => obj.ok = false;
    img.src = src;
    return obj;
  }
  const IMG = {
    player: loadImage("./assets/player_sheet.png"),
    slime:  loadImage("./assets/slime_sheet.png"),
    fxHit:  loadImage("./assets/fx_hit.png"),
    bg:     loadImage("./assets/bg.png"),
  };

  // -------------------- SpriteSheet --------------------
  class SpriteSheet {
    constructor(imageObj, fw, fh, animations) {
      this.imageObj = imageObj;
      this.fw = fw;
      this.fh = fh;
      this.anim = animations;
    }
    draw(name, x, y, t, scale=1, flip=false, alpha=1) {
      const { img, ok } = this.imageObj;
      const a = this.anim[name] || this.anim.idle;
      const frames = Math.max(1, a.frames);
      const idx = a.loop
        ? Math.floor(t * a.fps) % frames
        : Math.min(frames - 1, Math.floor(t * a.fps));
      const sx = idx * this.fw;
      const sy = a.row * this.fh;

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.translate(x, y);
      if (flip) ctx.scale(-1, 1);

      if (ok) {
        ctx.drawImage(img, sx, sy, this.fw, this.fh,
          -this.fw*scale/2, -this.fh*scale/2, this.fw*scale, this.fh*scale);
      } else {
        ctx.fillStyle = "rgba(91,140,255,0.95)";
        if (name === "hurt") ctx.fillStyle = "rgba(255,91,110,0.95)";
        if (name === "attack") ctx.fillStyle = "rgba(255,207,91,0.95)";
        ctx.fillRect(-22*scale, -26*scale, 44*scale, 52*scale);
        ctx.fillStyle = "rgba(235,240,255,0.85)";
        ctx.fillRect(6*scale, -6*scale, 10*scale, 6*scale);
      }
      ctx.restore();
    }
  }

  const playerSheet = new SpriteSheet(IMG.player, 64, 64, {
    idle:   { row:0, frames:6, fps:8,  loop:true  },
    run:    { row:1, frames:8, fps:12, loop:true  },
    jump:   { row:2, frames:4, fps:10, loop:false },
    attack: { row:3, frames:6, fps:16, loop:false },
    hurt:   { row:4, frames:4, fps:14, loop:false }
  });

  const slimeSheet = new SpriteSheet(IMG.slime, 64, 64, {
    idle:   { row:0, frames:6, fps:8,  loop:true  },
    run:    { row:1, frames:6, fps:10, loop:true  },
    hurt:   { row:2, frames:4, fps:14, loop:false },
    attack: { row:3, frames:6, fps:14, loop:false },
    die:    { row:4, frames:6, fps:12, loop:false }
  });

  // -------------------- FX --------------------
  class DamageText {
    constructor(x, y, text, color="rgba(235,240,255,0.92)") {
      this.x=x; this.y=y; this.vy=-50;
      this.text=text; this.t=0; this.life=0.8;
      this.color=color;
    }
    update(dt){ this.t+=dt; this.y += this.vy*dt; }
    draw(cam){
      const a = clamp(1 - this.t/this.life, 0, 1);
      ctx.globalAlpha = a;
      ctx.fillStyle = this.color;
      ctx.font = "bold 18px ui-monospace, Menlo, Consolas, monospace";
      ctx.fillText(this.text, this.x - cam.x, this.y - cam.y);
      ctx.globalAlpha = 1;
    }
    dead(){ return this.t >= this.life; }
  }

  class Particle {
    constructor(x,y,vx,vy,life, col){
      this.x=x; this.y=y; this.vx=vx; this.vy=vy;
      this.t=0; this.life=life; this.col=col;
    }
    update(dt){
      this.t+=dt;
      this.vy += 520*dt;
      this.x += this.vx*dt;
      this.y += this.vy*dt;
      this.vx *= Math.pow(0.12, dt);
      this.vy *= Math.pow(0.22, dt);
    }
    draw(cam){
      const a = clamp(1 - this.t/this.life, 0, 1);
      ctx.globalAlpha = a;
      ctx.fillStyle = this.col;
      ctx.fillRect(this.x - cam.x, this.y - cam.y, 3, 3);
      ctx.globalAlpha = 1;
    }
    dead(){ return this.t >= this.life; }
  }

  class HitSpark {
    constructor(x,y){
      this.x=x; this.y=y; this.t=0; this.life=0.22;
    }
    update(dt){ this.t += dt; }
    draw(cam){
      const a = clamp(1 - this.t/this.life, 0, 1);
      const px = this.x - cam.x, py = this.y - cam.y;
      ctx.save();
      ctx.globalAlpha = a;
      if (IMG.fxHit.ok) {
        const fw=64, fh=64, frames=6;
        const i = Math.min(frames-1, Math.floor((this.t/this.life)*frames));
        ctx.drawImage(IMG.fxHit.img, i*fw, 0, fw, fh, px-32, py-32, 64, 64);
      } else {
        ctx.strokeStyle = "rgba(255,235,120,0.95)";
        ctx.lineWidth = 3;
        const r = 10 + (1-a)*14;
        for(let i=0;i<8;i++){
          const ang = (Math.PI*2)*(i/8);
          ctx.beginPath();
          ctx.moveTo(px, py);
          ctx.lineTo(px + Math.cos(ang)*r, py + Math.sin(ang)*r);
          ctx.stroke();
        }
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.fillRect(px-2, py-2, 4, 4);
      }
      ctx.restore();
    }
    dead(){ return this.t >= this.life; }
  }

  // -------------------- World --------------------
  const WORLD = { w: 4200, h: 1200 };
  const GROUND_Y = 860;
  const GROUND_SCREEN_Y = VIEW_H - 80;
  const CAM_Y = Math.max(0, GROUND_Y - GROUND_SCREEN_Y);

  function stageLabel(i){
    const chap = Math.floor((i-1)/10)+1;
    const step = ((i-1)%10)+1;
    return `${chap}-${step}`;
  }
  function isBossStage(i){
    const step = ((i-1)%10)+1;
    return (step % 5 === 0);
  }

  function buildPlatforms(stageIndex){
    const plats = [];
    plats.push({ x: 0, y: GROUND_Y, w: WORLD.w, h: 80 });

    const seed = stageIndex * 1337;
    const rng = (n)=> {
      const s = Math.sin(seed + n*12.9898) * 43758.5453;
      return s - Math.floor(s);
    };

    for (let i=0;i<10;i++){
      const px = 420 + i*320 + randi(-40, 40);
      const py = GROUND_Y - 120 - Math.floor(rng(i)*220);
      plats.push({ x:px, y:py, w: 170 + randi(0, 60), h: 18 });
    }
    plats.push({ x: WORLD.w - 720, y: GROUND_Y - 160, w: 220, h: 18 });
    return plats;
  }

  // -------------------- Items / Shop / Appraise --------------------
  const SLOTS = ["weapon","armor","ring"];
  const RAR = [
    {k:"N",  name:"ÏùºÎ∞ò", w:60, opt:0, mult:1.00},
    {k:"R",  name:"Ìù¨Í∑Ä", w:28, opt:1, mult:1.20},
    {k:"SR", name:"ÏòÅÏõÖ", w:10, opt:2, mult:1.45},
    {k:"SSR",name:"Ï†ÑÏÑ§", w: 2, opt:2, mult:1.85},
  ];
  const NAMES = {
    weapon:["ÎÇòÎ¨¥ Í≤Ä","Ï≤†Í≤Ä","ÌùëÏ≤†Í≤Ä","Î≤àÍ∞úÏùò Í≤Ä","Ï≤òÌòïÏûê ÎåÄÍ≤Ä"],
    armor:["Ìóå Ïò∑","Í∞ÄÏ£Ω Í∞ëÏò∑","ÏÇ¨Ïä¨ Í∞ëÏò∑","Í∞ïÏ≤† Í∞ëÏò∑","ÏàòÌò∏Ïùò ÌåêÍ∏à"],
    ring:["Îèô Î∞òÏßÄ","ÏùÄ Î∞òÏßÄ","ÏßëÏ§ëÏùò Î∞òÏßÄ","ÌååÍ¥¥Ïùò Î∞òÏßÄ","ÏôïÏùò Î∞òÏßÄ"]
  };
  const AFFIX = [
    {k:"atk", n:"Í≥µÍ≤©", min:1, max:7, w:22},
    {k:"def", n:"Î∞©Ïñ¥", min:1, max:6, w:22},
    {k:"hp",  n:"Ï≤¥Î†•", min:8, max:26, w:18},
    {k:"crit",n:"ÏπòÎ™Ö", min:1, max:7, w:10},
    {k:"spd", n:"Ïù¥ÏÜç", min:6, max:18, w:10},
    {k:"atkP",n:"Í≥µÍ≤©%",min:2, max:10,w:8},
    {k:"hpP", n:"Ï≤¥Î†•%",min:3, max:12,w:5},
    {k:"ls",  n:"Ìù°Ìòà", min:1, max:4, w:3},
  ];

  function wpick(list){
    const sum = list.reduce((s,x)=>s+x.w,0);
    let r = Math.random()*sum;
    for (const x of list){ r-=x.w; if (r<=0) return x; }
    return list[0];
  }
  function rollRarity(){
    const sum = RAR.reduce((s,x)=>s+x.w,0);
    let r = Math.random()*sum;
    for (const x of RAR){ r-=x.w; if (r<=0) return x; }
    return RAR[0];
  }
  function uuid(){
    if (crypto?.randomUUID) return crypto.randomUUID();
    return "id-"+Math.random().toString(16).slice(2)+Date.now().toString(16);
  }
  function rollAffixes(cnt){
    const used=new Set(); const out=[];
    let tries=0;
    while(out.length<cnt && tries<30){
      tries++;
      const a=wpick(AFFIX);
      if(used.has(a.k)) continue;
      used.add(a.k);
      out.push({k:a.k, n:a.n, v:randi(a.min,a.max)});
    }
    return out;
  }
  function makeItem(slot, level){
    const rar = rollRarity();
    const baseName = pick(NAMES[slot]);
    const ilvl = Math.max(1, level + randi(-1, 2));
    let atk=0,def=0,hp=0,crit=0,spd=0;
    if(slot==="weapon") atk = randi(3,7);
    if(slot==="armor"){ def=randi(2,6); hp=randi(10,22); }
    if(slot==="ring"){ crit=randi(1,4); atk=randi(1,3); spd=randi(0,6); }

    const mult = rar.mult * (1 + (ilvl-1)*0.04);
    const stats = {
      atk: Math.round(atk*mult),
      def: Math.round(def*mult),
      hp:  Math.round(hp*mult),
      crit:Math.round(crit*mult),
      spd: Math.round(spd*mult),
    };

    // ‚úÖ "ÎØ∏Í∞êÏ†ï"ÏùÄ Ìù¨Í∑Ä Ïù¥ÏÉÅÏóêÏÑúÎßå Î∞úÏÉù
    const identified = (rar.k==="N");
    const hidden = (rar.opt>0) ? rollAffixes(rar.opt) : [];

    return {
      id: uuid(),
      slot,
      name: baseName,
      rar: rar.k,
      rarName: rar.name,
      ilvl,
      enh: 0,
      identified,
      hidden,
      aff: [],
      stats,
      createdAt: isoNow()
    };
  }
  function appraise(it){
    if(it.identified) return false;
    it.identified=true;
    it.aff = it.hidden.slice();
    it.hidden = [];
    return true;
  }
  function itemPow(it){
    let p = it.stats.atk*2 + it.stats.def*2 + it.stats.hp*0.6 + it.stats.crit*1.4 + it.stats.spd*0.5 + it.ilvl*2 + it.enh*6;
    if(it.identified){
      for(const a of it.aff){
        if(a.k==="atk") p+=a.v*3;
        if(a.k==="def") p+=a.v*3;
        if(a.k==="hp")  p+=a.v*0.8;
        if(a.k==="crit")p+=a.v*2;
        if(a.k==="spd") p+=a.v*0.8;
        if(a.k==="atkP")p+=a.v*4;
        if(a.k==="hpP") p+=a.v*3;
        if(a.k==="ls")  p+=a.v*6;
      }
    }
    return Math.round(p);
  }
  function sellPrice(it){
    const rarMult = (it.rar==="SSR")?3.2:(it.rar==="SR")?2.2:(it.rar==="R")?1.5:1.0;
    const base = 18 + it.ilvl*8 + Math.floor(itemPow(it)*0.12);
    const idBonus = it.identified ? 1.15 : 0.95;
    return Math.max(5, Math.floor(base * rarMult * idBonus));
  }

  // ÏÉÅÏ†ê/Í∞êÏ†ï
  const POTION_MAX = 12;
  const POTION_HEAL_PCT = 0.35;
  const POTION_CD = 8.0;

  const POTION_PRICE = 60;
  const APPRAISE_PRICE = 45;
  const APPRAISE_TICKET_REWARD = 1;

  // -------------------- Physics / Combat --------------------
  function aabb(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  const ATTACK_LOCK_ATK = 0.18;
  const ATTACK_LOCK_SKL = 0.24;
  const CONTACT_DAMAGE_COOLDOWN = 0.22;
  const CONTACT_SEP_STRENGTH = 0.78;

  const DROP_RATE_NORMAL = 0.07;
  const DROP_RATE_ELITE  = 0.18;
  const DROP_RATE_BOSS   = 0.60;
  const BOSS_DOUBLE_DROP_RATE = 0.22;

  // ‚úÖ Ï†ÑÌà¨ Ï¢ÖÎ£å ÌõÑ ÏûêÏó∞ ÌöåÎ≥µ(Î≥µÍµ¨)
  const REGEN_DELAY = 2.5;
  const REGEN_RATE_PCT = 0.025;   // Ï¥àÎãπ ÏµúÎåÄÏ≤¥Î†•Ïùò 2.5%
  const REGEN_NEAR_ENEMY = 420;

  function snapToGround(ent){
    const gy = GROUND_Y - ent.h/2;
    if (ent.y > gy) {
      ent.y = gy;
      ent.vy = 0;
      ent.onGround = true;
    }
  }

  class Player {
    constructor() {
      this.x = 220; this.y = 200;
      this.vx = 0; this.vy = 0;
      this.w = 42; this.h = 54;
      this.face = 1;
      this.onGround = false;

      this.hpBase = 120;
      this.atkBase = 14;
      this.defBase = 6;
      this.critBase = 6;
      this.spdBase = 230;

      this.hp = 120;
      this.atkCd = 0;
      this.skillCd = 0;

      this.inv = 0;
      this.hitCd = 0;
      this.attackLock = 0;

      this.potions = 3;
      this.potionCd = 0;

      this.gold = 120;
      this.stage = 1;
      this.kills = 0;

      this.appraiseTickets = 0;

      // ‚úÖ ÏûêÏó∞ ÌöåÎ≥µ ÏÉÅÌÉúÍ∞í
      this.regenBlockT = 0;
      this.regenAcc = 0;

      this.anim = "idle";
      this.animT = 0;

      this.invItems = [ makeItem("weapon",1), makeItem("armor",1), makeItem("ring",1) ];
      this.equip = { weapon:null, armor:null, ring:null };
      this.autoEquipBest();
    }
    derived() {
      let hpMax = this.hpBase;
      let atk = this.atkBase;
      let def = this.defBase;
      let crit = this.critBase;
      let spd = this.spdBase;
      let atkP=0, hpP=0, ls=0;

      for (const s of SLOTS) {
        const it = this.equip[s];
        if (!it) continue;
        atk += it.stats.atk;
        def += it.stats.def;
        hpMax += it.stats.hp;
        crit += it.stats.crit;
        spd += it.stats.spd;

        if (it.identified) {
          for (const a of it.aff) {
            if (a.k==="atk") atk += a.v;
            if (a.k==="def") def += a.v;
            if (a.k==="hp")  hpMax += a.v;
            if (a.k==="crit")crit += a.v;
            if (a.k==="spd") spd += a.v;
            if (a.k==="atkP")atkP += a.v;
            if (a.k==="hpP") hpP += a.v;
            if (a.k==="ls")  ls += a.v;
          }
        }
      }
      atk = Math.round(atk * (1 + atkP/100));
      hpMax = Math.round(hpMax * (1 + hpP/100));
      crit = clamp(crit, 0, 60);
      spd = clamp(spd, 160, 310);
      ls = clamp(ls, 0, 12);
      return { hpMax, atk, def, crit, spd, ls };
    }
    autoEquipBest() {
      for (const slot of SLOTS) {
        const current = this.equip[slot];
        const cand = this.invItems.filter(it => it.slot === slot);
        if (current) cand.push(current);
        if (!cand.length) continue;
        cand.sort((a,b)=>itemPow(b)-itemPow(a));
        const best = cand[0];
        if (current && best.id === current.id) continue;
        if (current) this.invItems.push(current);
        this.invItems = this.invItems.filter(it => it.id !== best.id);
        this.equip[slot] = best;
      }
      const d = this.derived();
      this.hp = clamp(this.hp, 1, d.hpMax);
    }
  }

  class Slime {
    constructor(x,y, tier, stageIndex) {
      this.x=x; this.y=y;
      this.vx=0; this.vy=0;
      this.w=44; this.h=42;
      this.face = -1;
      this.onGround=false;

      this.tier = tier;
      this.hpMax = 55 + stageIndex*18 + (tier==="elite"?80:0) + (tier==="boss"?420:0);
      this.hp = this.hpMax;
      this.atk = 10 + stageIndex*4 + (tier==="elite"?10:0) + (tier==="boss"?26:0);
      this.def = 2 + Math.floor(stageIndex/2) + (tier==="elite"?3:0) + (tier==="boss"?8:0);
      this.spd = (tier==="boss"?150:(tier==="elite"?190:170));

      this.hitCd=0;
      this.aiT=0;

      this.anim="idle";
      this.animT=0;
      this.dead=false;
      this.dieT=0;

      this.jumpCd = 0;
      this.groundSnap = true;
    }
  }

  class Coin { constructor(x,y,amount){ this.x=x; this.y=y; this.vx=rand(-40,40); this.vy=rand(-280,-120); this.r=8; this.amount=amount; this.t=0; } }
  class Loot { constructor(x,y,item){ this.x=x; this.y=y; this.vx=rand(-30,30); this.vy=rand(-240,-120); this.r=10; this.item=item; this.t=0; } }

  const cam = { x:0, y:CAM_Y };

  // -------------------- UI helpers --------------------
  function roundRect(x, y, w, h, r, fill, stroke){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }
  function panel(x,y,w,h,title){
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(10,14,24,0.74)";
    roundRect(x,y,w,h,14,true,false);
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = 1;
    roundRect(x,y,w,h,14,false,true);

    ctx.globalAlpha = 1;
    ctx.fillStyle = "rgba(235,240,255,0.92)";
    ctx.font = "bold 18px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.fillText(title, x+16, y+30);
    ctx.restore();
  }
  function btn(x,y,w,h,text,hot=false){
    ctx.save();
    ctx.fillStyle = hot ? "rgba(91,140,255,0.22)" : "rgba(255,255,255,0.07)";
    ctx.strokeStyle = hot ? "rgba(91,140,255,0.50)" : "rgba(255,255,255,0.14)";
    ctx.lineWidth = 1;
    roundRect(x,y,w,h,12,true,true);
    ctx.fillStyle = "rgba(235,240,255,0.92)";
    ctx.font = "bold 16px system-ui, -apple-system, Segoe UI";
    const tw = ctx.measureText(text).width;
    ctx.fillText(text, x + (w-tw)/2, y + h/2 + 6);
    ctx.restore();
  }
  function drawIconBtn(x,y,w,h,label,hot=false){
    ctx.save();
    ctx.fillStyle = hot ? "rgba(91,140,255,0.22)" : "rgba(255,255,255,0.07)";
    ctx.strokeStyle = hot ? "rgba(91,140,255,0.55)" : "rgba(255,255,255,0.14)";
    roundRect(x,y,w,h,12,true,true);

    ctx.fillStyle = "rgba(235,240,255,0.92)";
    ctx.font = "900 18px system-ui, -apple-system, Segoe UI";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(label, x + w/2, y + h/2 + 1);
    ctx.restore();
  }

  function rarColor(r){
    if (r==="SSR") return "rgba(255,207,91,0.95)";
    if (r==="SR")  return "rgba(200,140,255,0.95)";
    if (r==="R")   return "rgba(91,140,255,0.95)";
    return "rgba(235,240,255,0.82)";
  }
  function slotName(s){
    return s==="weapon" ? "Î¨¥Í∏∞" : s==="armor" ? "Î∞©Ïñ¥Íµ¨" : "Î∞òÏßÄ";
  }
  function itemLine(it){
    const idTag = it.identified ? "" : " (ÎØ∏Í∞êÏ†ï)";
    return `[${it.rar}] ${slotName(it.slot)} | ${it.name}${idTag} | iLv ${it.ilvl} | PWR ${itemPow(it)} | ÌåêÎß§ ${sellPrice(it)}G`;
  }

  // HUD Î≤ÑÌäº(Ï∫îÎ≤ÑÏä§ ÎÇ¥Î∂Ä)
  const HUD_MENU_BTN   = { x: 14+740+10, y: 14,            w: 46, h: 46 };
  const HUD_POTION_BTN = { x: 14+740+10, y: 14+46+8,       w: 46, h: 46 };
  const HUD_INV_BTN    = { x: 14+740+10, y: 14+46+8+46+8,  w: 46, h: 46 };

  // -------------------- Game State --------------------
  function freshState(){
    const p = new Player();
    return {
      ver: 11,
      game: "Î≥¥Ïä§Í≤åÏù¥Ìä∏ (BOSS GATE)",
      createdAt: isoNow(),
      updatedAt: isoNow(),

      gs: "MENU",

      opt: { muted:false, bgm:true, sfx:true },

      player: p,
      stageIndex: 1,
      inBossRoom: false,

      platforms: buildPlatforms(1),
      enemies: [],
      coins: [],
      loots: [],

      goalKills: 10,
      killed: 0,

      door: null,
      fx: [],
      dmgText: [],
      parts: [],

      msg: "Î≥¥Ïä§Î¨∏ÏùÑ Î∂ÄÏà¥Îùº. (‚öô: Î©îÎâ¥, üéí: Ïù∏Î≤§, üß™: Ìè¨ÏÖò)",
      msgT: 2.2,

      t: 0,
      camX: 0,

      invSelId: null,
      invScroll: 0,
      shopScroll: 0,

      _dirty: false,
    };
  }

  function applyOptions(state){
    audio.setMuted(!!state.opt.muted);
    audio.bgmOn = !!state.opt.bgm;
    audio.sfxOn = !!state.opt.sfx;
    if (!audio.bgmOn) audio.stopBgm();
    else audio.startBgm();
  }

  function rebuildStage(state){
    const si = state.stageIndex;
    state.platforms = buildPlatforms(si);
    state.enemies = [];
    state.coins = [];
    state.loots = [];
    state.fx = [];
    state.dmgText = [];
    state.parts = [];
    state.door = null;

    state.killed = 0;
    state.goalKills = isBossStage(si) ? 1 : clamp(8 + Math.floor(si*0.7), 8, 18);

    state.player.x = 220;
    state.player.y = GROUND_Y - 120;
    state.player.vx = 0; state.player.vy = 0;
    state.player.attackLock = 0;

    state.camX = 0;

    if (isBossStage(si)) {
      state.inBossRoom = true;
      const bx = WORLD.w - 760;
      state.enemies.push(new Slime(bx, GROUND_Y - 120, "boss", si));
      state.msg = `Î≥¥Ïä§Í≤åÏù¥Ìä∏ ${stageLabel(si)} ‚Äî Î≥¥Ïä§ Îì±Ïû•!`;
      state.msgT = 1.6;
    } else {
      state.inBossRoom = false;
      const n = state.goalKills;
      for (let i=0;i<n;i++){
        const ex = 700 + i*260 + randi(-80,80);
        state.enemies.push(new Slime(ex, GROUND_Y - 120, Math.random()<0.22 ? "elite":"normal", si));
      }
      state.msg = `Ïä§ÌÖåÏù¥ÏßÄ ${stageLabel(si)} ÏãúÏûë! (${state.goalKills}ÎßàÎ¶¨ Ï≤òÏπò)`;
      state.msgT = 1.8;
    }
  }

  function startNew(state){
    const opt = state.opt;
    const fresh = freshState();
    fresh.opt = opt;
    Object.assign(state, fresh);
    rebuildStage(state);
    state.gs = "PLAY";
    state._dirty = true; // ÏÉà Í≤åÏûÑ ÏãúÏûë -> Ï†ÄÏû• Ïïà ÌñàÏùå ÌëúÏãú
  }

  function rollCrit(crit){ return (Math.random()*100) < crit; }
  function damageCalc(atk, def, critChance, mult=1){
    const c = rollCrit(critChance);
    let dmg = Math.max(1, Math.round(atk*mult) - def);
    if (c) dmg = Math.round(dmg*1.65);
    return { dmg, crit:c };
  }

  function spawnHitFX(state, x, y){
    state.fx.push(new HitSpark(x,y));
    for (let i=0;i<14;i++){
      state.parts.push(new Particle(x,y, rand(-220,220), rand(-260, -40), rand(0.18, 0.35), "rgba(255,235,120,0.95)"));
    }
    audio.playHit();
  }

  function shouldDropItem(tier){
    if (tier === "boss")  return Math.random() < DROP_RATE_BOSS;
    if (tier === "elite") return Math.random() < DROP_RATE_ELITE;
    return Math.random() < DROP_RATE_NORMAL;
  }

  function dropRewards(state, e){
    const baseGold = 18 + state.stageIndex*10 + (e.tier==="elite"?40:0) + (e.tier==="boss"?380:0);
    state.coins.push(new Coin(e.x, e.y, baseGold));

    if (shouldDropItem(e.tier)) {
      state.loots.push(new Loot(e.x+rand(-10,10), e.y, makeItem(pick(SLOTS), Math.max(1, Math.floor(state.stageIndex/2)+1))));
      if (e.tier === "boss" && Math.random() < BOSS_DOUBLE_DROP_RATE) {
        state.loots.push(new Loot(e.x+rand(-14,14), e.y, makeItem(pick(SLOTS), Math.max(1, Math.floor(state.stageIndex/2)+2))));
      }
    }
    markDirty(state);
  }

  function ensureDoor(state){
    if (state.door) return;
    const x = WORLD.w - 300;
    const y = GROUND_Y - 120;
    const w = 90, h = 120;
    state.door = { x, y, w, h, kind: state.inBossRoom ? "exit" : "next" };
    state.msg = state.inBossRoom ? "Ï∂úÍµ¨ Î≥¥Ïä§Î¨∏Ïù¥ Ïó¥Î†∏Îã§!" : "Îã§Ïùå Î≥¥Ïä§Î¨∏Ïù¥ Ïó¥Î†∏Îã§!";
    state.msgT = 1.4;
  }

  function stageClearReward(state){
    const p = state.player;
    const before = p.potions;

    const addPotion = state.inBossRoom ? 2 : 1;
    p.potions = clamp(p.potions + addPotion, 0, POTION_MAX);

    const bonusGold = state.inBossRoom ? (120 + state.stageIndex*18) : (40 + state.stageIndex*8);
    p.gold += bonusGold;

    p.appraiseTickets += APPRAISE_TICKET_REWARD;

    const got = p.potions - before;
    state.msg = `ÌÅ¥Î¶¨Ïñ¥ Î≥¥ÏÉÅ: +${bonusGold}G ${got>0?`+Ìè¨ÏÖò${got}Í∞ú`:``} +Í∞êÏ†ïÍ∂å${APPRAISE_TICKET_REWARD}`;
    state.msgT = 1.8;
    markDirty(state);
  }

  function collidePlatforms(ent, plats){
    ent.onGround = false;

    ent.x += ent.vx;
    for (const p of plats){
      if (aabb(ent.x - ent.w/2, ent.y - ent.h/2, ent.w, ent.h, p.x, p.y, p.w, p.h)){
        if (ent.vx > 0) ent.x = p.x - (ent.w/2);
        else if (ent.vx < 0) ent.x = p.x + p.w + (ent.w/2);
        ent.vx = 0;
      }
    }

    ent.y += ent.vy;
    for (const p of plats){
      if (aabb(ent.x - ent.w/2, ent.y - ent.h/2, ent.w, ent.h, p.x, p.y, p.w, p.h)){
        if (ent.vy > 0) {
          ent.y = p.y - (ent.h/2);
          ent.vy = 0;
          ent.onGround = true;
        } else if (ent.vy < 0) {
          ent.y = p.y + p.h + (ent.h/2);
          ent.vy = 0;
        }
      }
    }

    ent.x = clamp(ent.x, 40, WORLD.w - 40);
    ent.y = clamp(ent.y, 40, WORLD.h - 40);
  }

  // -------------------- Draw world --------------------
  function drawBackground(){
    if (IMG.bg.ok) {
      const img = IMG.bg.img;
      const par = 0.35;
      const bx = - (cam.x * par) % img.width;
      for (let x = bx - img.width; x < VIEW_W + img.width; x += img.width) {
        ctx.drawImage(img, x, 0, img.width, Math.min(VIEW_H, img.height));
      }
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(0,0,VIEW_W,VIEW_H);
    } else {
      const g = ctx.createLinearGradient(0,0,0,VIEW_H);
      g.addColorStop(0, "#061021");
      g.addColorStop(1, "#070a14");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,VIEW_W,VIEW_H);
    }
  }

  function drawPlatforms(plats){
    for (const p of plats) {
      const x = p.x - cam.x;
      const y = p.y - cam.y;
      ctx.fillStyle = "rgba(255,255,255,0.08)";
      ctx.fillRect(x, y, p.w, p.h);
      ctx.fillStyle = "rgba(91,140,255,0.10)";
      ctx.fillRect(x, y, p.w, 3);
    }
  }
  function drawDoor(door){
    const x = door.x - cam.x;
    const y = door.y - cam.y;
    ctx.fillStyle = door.kind==="next" ? "rgba(91,140,255,0.20)" : "rgba(255,91,110,0.22)";
    roundRect(x, y, door.w, door.h, 10, true, false);
    ctx.strokeStyle = door.kind==="next" ? "rgba(91,140,255,0.55)" : "rgba(255,91,110,0.55)";
    ctx.lineWidth = 2;
    roundRect(x, y, door.w, door.h, 10, false, true);
    ctx.fillStyle = "rgba(235,240,255,0.92)";
    ctx.font = "bold 12px ui-monospace, Menlo, Consolas";
    ctx.fillText(door.kind==="next" ? "BOSS GATE" : "EXIT GATE", x+10, y+20);
    ctx.lineWidth = 1;
  }
  function drawCoins(coins){
    for (const c of coins) {
      const x = c.x - cam.x, y = c.y - cam.y;
      ctx.fillStyle = "rgba(255,207,91,0.92)";
      ctx.beginPath(); ctx.arc(x,y,c.r,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,0.35)";
      ctx.fillRect(x-2,y-5,3,3);
    }
  }
  function drawLoot(loots){
    for (const l of loots) {
      const x = l.x - cam.x, y = l.y - cam.y;
      ctx.fillStyle = "rgba(91,140,255,0.92)";
      ctx.beginPath(); ctx.arc(x,y,l.r,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = "rgba(235,240,255,0.60)";
      ctx.fillRect(x-3,y-3,6,6);
    }
  }

  function tryUsePotion(state){
    const p = state.player;
    const d = p.derived();

    if (p.potionCd > 0) { state.msg = `Ìè¨ÏÖò Ïø®ÌÉÄÏûÑ ${p.potionCd.toFixed(1)}s`; state.msgT = 0.9; return false; }
    if (p.potions <= 0) { state.msg = "Ìè¨ÏÖòÏù¥ ÏóÜÎã§!"; state.msgT = 1.2; return false; }
    if (p.hp >= d.hpMax) { state.msg = "HPÍ∞Ä Ïù¥ÎØ∏ Í∞ÄÎìùÌïòÎã§."; state.msgT = 0.9; return false; }

    const heal = Math.max(1, Math.floor(d.hpMax * POTION_HEAL_PCT));
    const before = p.hp;
    p.hp = clamp(p.hp + heal, 0, d.hpMax);
    p.potions -= 1;
    p.potionCd = POTION_CD;

    audio.playCoin();
    state.dmgText.push(new DamageText(p.x, p.y - 72, `+${Math.floor(p.hp - before)}`, "rgba(46,229,157,0.95)"));
    state.msg = `Ìè¨ÏÖò ÏÇ¨Ïö©! (+${Math.floor(p.hp - before)} HP)`;
    state.msgT = 1.1;

    markDirty(state);
    return true;
  }

  function stabilizeOverlapNoBounce(p, e){
    const dx = (p.x - e.x);
    const overlapX = (p.w/2 + e.w/2) - Math.abs(dx);
    if (overlapX <= 0) return false;

    const dir = dx === 0 ? (p.face || 1) : Math.sign(dx);
    const push = overlapX * CONTACT_SEP_STRENGTH;

    p.x += dir * (push * 0.35);
    e.x -= dir * (push * 0.65);

    p.vx *= 0.10;
    e.vx *= 0.10;

    e.vy = 0;
    if (e.groundSnap) snapToGround(e);
    return true;
  }

  // -------------------- HUD --------------------
  function drawHud(state){
    const p = state.player;
    const d = p.derived();

    ctx.globalAlpha = 0.90;
    ctx.fillStyle = "rgba(10,14,24,0.70)";
    roundRect(14, 14, 740, 110, 14, true, false);
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    roundRect(14, 14, 740, 110, 14, false, true);
    ctx.globalAlpha = 1;

    const hpPct = clamp(p.hp / d.hpMax, 0, 1);
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.fillRect(30, 34, 300, 14);
    ctx.fillStyle = "rgba(46,229,157,0.85)";
    ctx.fillRect(30, 34, 300*hpPct, 14);

    const sc = clamp(p.skillCd / 2.8, 0, 1);
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    ctx.fillRect(30, 54, 300, 10);
    ctx.fillStyle = "rgba(91,140,255,0.75)";
    ctx.fillRect(30, 54, 300*(1-sc), 10);

    const pc = clamp(p.potionCd / POTION_CD, 0, 1);
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    ctx.fillRect(30, 70, 300, 10);
    ctx.fillStyle = "rgba(255,207,91,0.75)";
    ctx.fillRect(30, 70, 300*(1-pc), 10);

    ctx.fillStyle = "rgba(235,240,255,0.92)";
    ctx.font = "bold 12px ui-monospace, Menlo, Consolas";
    ctx.fillText(`BOSS GATE | STAGE ${stageLabel(state.stageIndex)} ${state.inBossRoom ? "(BOSS)" : ""} | KILL ${state.killed}/${state.goalKills}`, 350, 38);
    ctx.fillText(`HP ${Math.floor(p.hp)}/${d.hpMax}  ATK ${d.atk} DEF ${d.def} CRIT ${d.crit}% SPD ${d.spd}`, 350, 56);
    ctx.fillText(`GOLD ${p.gold}G | Ìè¨ÏÖò ${p.potions}/${POTION_MAX} | Í∞êÏ†ïÍ∂å ${p.appraiseTickets} ${state._dirty ? "| *ÎØ∏Ï†ÄÏû•" : ""}`, 350, 74);
    ctx.fillText(`‚öô/ESC: Î©îÎâ¥  üéí/I: Ïù∏Î≤§  H/üß™: Ìè¨ÏÖò`, 350, 92);

    const hotGear = (pointer.x>=HUD_MENU_BTN.x && pointer.x<=HUD_MENU_BTN.x+HUD_MENU_BTN.w &&
                     pointer.y>=HUD_MENU_BTN.y && pointer.y<=HUD_MENU_BTN.y+HUD_MENU_BTN.h);
    drawIconBtn(HUD_MENU_BTN.x, HUD_MENU_BTN.y, HUD_MENU_BTN.w, HUD_MENU_BTN.h, "‚öô", hotGear);

    const hotPot = (pointer.x>=HUD_POTION_BTN.x && pointer.x<=HUD_POTION_BTN.x+HUD_POTION_BTN.w &&
                    pointer.y>=HUD_POTION_BTN.y && pointer.y<=HUD_POTION_BTN.y+HUD_POTION_BTN.h);
    drawIconBtn(HUD_POTION_BTN.x, HUD_POTION_BTN.y, HUD_POTION_BTN.w, HUD_POTION_BTN.h, "üß™", hotPot);

    const hotInv = (pointer.x>=HUD_INV_BTN.x && pointer.x<=HUD_INV_BTN.x+HUD_INV_BTN.w &&
                    pointer.y>=HUD_INV_BTN.y && pointer.y<=HUD_INV_BTN.y+HUD_INV_BTN.h);
    drawIconBtn(HUD_INV_BTN.x, HUD_INV_BTN.y, HUD_INV_BTN.w, HUD_INV_BTN.h, "üéí", hotInv);

    // Ìè¨ÏÖò Í∞úÏàò Î±ÉÏßÄ
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    roundRect(HUD_POTION_BTN.x+26, HUD_POTION_BTN.y+28, 20, 16, 8, true, false);
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.font = "bold 11px ui-monospace, Menlo, Consolas";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(String(state.player.potions), HUD_POTION_BTN.x+36, HUD_POTION_BTN.y+36);
    ctx.restore();

    if (state.msgT > 0 && state.msg) {
      ctx.globalAlpha = clamp(state.msgT/0.5, 0, 1);
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      roundRect(14, 130, 920-28, 36, 12, true, false);
      ctx.fillStyle = "rgba(235,240,255,0.92)";
      ctx.font = "bold 14px system-ui, -apple-system, Segoe UI";
      ctx.fillText(state.msg, 28, 154);
      ctx.globalAlpha = 1;
    }
  }

  function drawScene(state, dim=false){
    drawBackground();
    drawPlatforms(state.platforms);
    if (state.door) drawDoor(state.door);
    drawCoins(state.coins);
    drawLoot(state.loots);

    for (const e of state.enemies) {
      const x = e.x - cam.x;
      const y = e.y - cam.y;
      const flip = (e.face === -1);
      const name = e.dead ? "die" : e.anim;
      const scale = (e.tier==="boss") ? 1.45 : (e.tier==="elite" ? 1.15 : 1.0);
      slimeSheet.draw(name, x, y-8, e.animT, scale, flip, e.hitCd>0 ? 0.75 : 1);

      if (!e.dead) {
        const pct = clamp(e.hp/e.hpMax, 0,1);
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.fillRect(x-34*scale, y-56*scale, 68*scale, 8);
        ctx.fillStyle = (e.tier==="boss") ? "rgba(255,91,110,0.85)" : "rgba(46,229,157,0.85)";
        ctx.fillRect(x-34*scale, y-56*scale, 68*scale*pct, 8);
      }
    }

    const p = state.player;
    const px = p.x - cam.x;
    const py = p.y - cam.y;
    const flipP = (p.face === -1);
    playerSheet.draw(p.anim, px, py-10, p.animT, 1.15, flipP, p.inv>0 ? 0.65 : 1);

    for (const f of state.fx) f.draw(cam);
    for (const t of state.dmgText) t.draw(cam);
    for (const pa of state.parts) pa.draw(cam);

    if (dim) {
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.fillRect(0,0,VIEW_W,VIEW_H);
    }
    drawHud(state);
  }

  // -------------------- MENU / OPTIONS --------------------
  function drawMenu(state){
    drawBackground();
    const px = VIEW_W*0.5-260, py = VIEW_H*0.5-190;
    panel(px, py, 520, 380, "Î≥¥Ïä§Í≤åÏù¥Ìä∏");

    ctx.fillStyle = "rgba(235,240,255,0.75)";
    ctx.font = "14px system-ui, -apple-system, Segoe UI";
    ctx.textAlign = "center";
    ctx.fillText("Ïä§ÌÖåÏù¥ÏßÄÎ•º Îö´Í≥†, Î≥¥Ïä§Î¨∏ÏùÑ Î∂ÄÏà¥Îùº.", VIEW_W*0.5, VIEW_H*0.5-110);
    ctx.textAlign = "left";

    const bx = VIEW_W*0.5-180, by = VIEW_H*0.5-70, bw=360, bh=52;
    const hasSave = !!load();

    btn(bx, by, bw, bh, "ÏÉà Í≤åÏûÑ ÏãúÏûë", true);
    btn(bx, by+64, bw, bh, hasSave ? "Ïù¥Ïñ¥ÌïòÍ∏∞" : "Ïù¥Ïñ¥ÌïòÍ∏∞(Ï†ÄÏû• ÏóÜÏùå)", hasSave);
    btn(bx, by+128, bw, bh, "ÏòµÏÖò");
    btn(bx, by+192, bw, bh, "Ï†ÄÏû• ÏÇ≠Ï†ú", false);

    if (hitBtn(bx,by,bw,bh)) startNew(state);

    if (hasSave && hitBtn(bx,by+64,bw,bh)) {
      const s = load();
      if (s) {
        const restored = revive(s);
        Object.assign(state, restored);
        applyOptions(state);
        state.gs = "PLAY";
      }
    }

    if (hitBtn(bx,by+128,bw,bh)) { state.gs = "OPTIONS"; }

    if (hitBtn(bx,by+192,bw,bh)) {
      localStorage.removeItem(SAVE_KEY);
      state.msg = "Ï†ÄÏû• ÏÇ≠Ï†ú ÏôÑÎ£å.";
      state.msgT = 1.5;
    }

    ctx.fillStyle = "rgba(235,240,255,0.55)";
    ctx.font = "12px ui-monospace, Menlo, Consolas";
    ctx.fillText("Î™®Î∞îÏùº: ÌÑ∞Ïπò Î≤ÑÌäº / PC: Î∞©Ìñ•ÌÇ§+Z/X+Space+H+I+ESC", VIEW_W*0.5-240, VIEW_H*0.5+210);
  }

  function drawOptions(state){
    drawBackground();
    panel(VIEW_W*0.5-260, VIEW_H*0.5-170, 520, 340, "ÏòµÏÖò");

    const bx = VIEW_W*0.5-200, by = VIEW_H*0.5-90, bw=400, bh=52;

    btn(bx, by, bw, bh, `ÏùåÏÜåÍ±∞: ${state.opt.muted ? "ON" : "OFF"}`, !state.opt.muted);
    btn(bx, by+64, bw, bh, `BGM: ${state.opt.bgm ? "ON" : "OFF"}`, state.opt.bgm);
    btn(bx, by+128, bw, bh, `SFX: ${state.opt.sfx ? "ON" : "OFF"}`, state.opt.sfx);
    btn(bx, by+212, bw, bh, "Îí§Î°úÍ∞ÄÍ∏∞(ESC)", true);

    if (hitBtn(bx,by,bw,bh)) { state.opt.muted = !state.opt.muted; applyOptions(state); }
    if (hitBtn(bx,by+64,bw,bh)) { state.opt.bgm = !state.opt.bgm; applyOptions(state); }
    if (hitBtn(bx,by+128,bw,bh)) { state.opt.sfx = !state.opt.sfx; applyOptions(state); }
    if (hitBtn(bx,by+212,bw,bh)) { state.gs = "MENU"; }

    if (pressed.menu) { pressed.menu=false; state.gs="MENU"; }
  }

  // -------------------- PAUSE MENU --------------------
  function drawPause(state){
    drawScene(state, true);

    const px = VIEW_W*0.5-260;
    const py = 70;
    const pw = 520;
    const ph = 400;
    panel(px, py, pw, ph, "ÏùºÏãúÏ†ïÏßÄ / Î©îÎâ¥");

    const bx = VIEW_W*0.5-190;
    const by = py + 54;
    const bw = 380;
    const bh = 46;
    const gap = 10;

    const items = [
      { t:"Ïû¨Í∞ú", hot:true, fn:()=> state.gs="PLAY" },
      { t:"Ïù∏Î≤§ÌÜ†Î¶¨(üéí/I)", hot:false, fn:()=> state.gs="INV" },
      { t:"ÏÉÅÏ†ê/Í∞êÏ†ï(üè™)", hot:false, fn:()=> state.gs="SHOP" },
      { t:"ÏòµÏÖò", hot:false, fn:()=> state.gs="OPTIONS" },

      // ‚úÖ ÏàòÎèô Ï†ÄÏû• Î≤ÑÌäº
      { t:`Ï†ÄÏû•(ÏàòÎèô) ${state._dirty ? "" : "(ÏµúÏã†)"}`, hot:false, fn:()=> saveGame(state) },

      { t:"ÌÉÄÏù¥ÌãÄÎ°ú", hot:false, fn:()=> { state.gs="MENU"; state.msg="ÌÉÄÏù¥ÌãÄÎ°ú Ïù¥Îèô."; state.msgT=1.3; } },
    ];

    for (let i=0;i<items.length;i++){
      const y = by + i*(bh+gap);
      btn(bx, y, bw, bh, items[i].t, items[i].hot);
      if (hitBtn(bx, y, bw, bh)) items[i].fn();
    }

    ctx.fillStyle = "rgba(235,240,255,0.65)";
    ctx.font = "12px ui-monospace, Menlo, Consolas";
    ctx.fillText("ESC: Îã´Í∏∞ / I: Ïù∏Î≤§ / Ï†ÄÏû•ÏùÄ 'Ï†ÄÏû•(ÏàòÎèô)' Î≤ÑÌäºÎßå", bx, py+365);

    if (pressed.menu) { pressed.menu = false; state.gs = "PLAY"; }
    if (pressed.inv) { pressed.inv = false; state.gs = "INV"; }
  }

  // -------------------- INVENTORY --------------------
  function getAllItems(state){
    const p = state.player;
    const items = [];
    for (const s of SLOTS){
      if (p.equip[s]) items.push({ it:p.equip[s], where:"equip" });
    }
    for (const it of p.invItems) items.push({ it, where:"bag" });
    return items;
  }

  function invSelect(state, id){
    state.invSelId = id;
  }

  function clampHpAfterEquip(p){
    const d = p.derived();
    p.hp = clamp(p.hp, 1, d.hpMax);
  }

  // ‚úÖ Ïû•Ï∞©(Í∞ÄÎ∞© ‚Üí Ïû•ÎπÑ): autoEquipBestÎ°ú ÎçÆÏñ¥Ïì∞ÏßÄ ÏïäÍ≤å ÏàòÏ†ï
  function equipFromBag(state, itemId){
    const p = state.player;
    const idx = p.invItems.findIndex(x=>x.id===itemId);
    if (idx < 0) return false;
    const it = p.invItems[idx];
    const slot = it.slot;
    const cur = p.equip[slot];
    if (cur) p.invItems.push(cur);
    p.invItems.splice(idx,1);
    p.equip[slot] = it;
    clampHpAfterEquip(p);
    markDirty(state);
    return true;
  }

  // ‚úÖ Ìï¥Ï†ú(Ïû•ÎπÑ ‚Üí Í∞ÄÎ∞©): autoEquipBestÍ∞Ä Ï¶âÏãú Ïû¨Ïû•Ï∞©ÌïòÎäî Î¨∏Ï†ú Ï†úÍ±∞
  function unequipToBag(state, slot){
    const p = state.player;
    const cur = p.equip[slot];
    if (!cur) return false;
    p.invItems.push(cur);
    p.equip[slot] = null;
    clampHpAfterEquip(p);
    markDirty(state);
    return true;
  }

  function sellItemFromBag(state, itemId){
    const p = state.player;
    const idx = p.invItems.findIndex(x=>x.id===itemId);
    if (idx < 0) return false;
    const it = p.invItems[idx];
    const price = sellPrice(it);
    p.gold += price;
    p.invItems.splice(idx,1);
    audio.playCoin();
    state.msg = `ÌåêÎß§: ${price}G`;
    state.msgT = 1.2;
    if (state.invSelId === itemId) state.invSelId = null;
    markDirty(state);
    return true;
  }

  function appraiseOne(state, itemId){
    const p = state.player;
    const it = p.invItems.find(x=>x.id===itemId) || Object.values(p.equip).find(x=>x && x.id===itemId);
    if (!it) return false;
    if (it.identified) { state.msg="Ïù¥ÎØ∏ Í∞êÏ†ïÎêú ÏïÑÏù¥ÌÖú."; state.msgT=1.1; return false; }

    if (p.appraiseTickets > 0) {
      p.appraiseTickets -= 1;
      appraise(it);
      audio.playCoin();
      state.msg = "Í∞êÏ†ï ÏôÑÎ£å! (Í∞êÏ†ïÍ∂å -1)";
      state.msgT = 1.4;
      markDirty(state);
      return true;
    }
    if (p.gold < APPRAISE_PRICE) {
      state.msg = `Í≥®Îìú Î∂ÄÏ°±! (Í∞êÏ†ï ${APPRAISE_PRICE}G ÌïÑÏöî)`;
      state.msgT = 1.4;
      return false;
    }
    p.gold -= APPRAISE_PRICE;
    appraise(it);
    audio.playCoin();
    state.msg = `Í∞êÏ†ï ÏôÑÎ£å! (-${APPRAISE_PRICE}G)`;
    state.msgT = 1.4;
    markDirty(state);
    return true;
  }

  function drawItemDetail(state, x, y, w, h, it){
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    roundRect(x,y,w,h,12,true,true);

    ctx.fillStyle = rarColor(it.rar);
    ctx.font = "900 16px system-ui, -apple-system, Segoe UI";
    ctx.fillText(`[${it.rar}] ${it.name} ${it.identified?"":"(ÎØ∏Í∞êÏ†ï)"}`, x+14, y+28);

    ctx.fillStyle = "rgba(235,240,255,0.80)";
    ctx.font = "12px ui-monospace, Menlo, Consolas";
    ctx.fillText(`${slotName(it.slot)} | iLv ${it.ilvl} | PWR ${itemPow(it)} | ÌåêÎß§ ${sellPrice(it)}G`, x+14, y+48);

    const baseY = y+72;
    ctx.fillStyle = "rgba(235,240,255,0.86)";
    ctx.font = "bold 13px ui-monospace, Menlo, Consolas";
    ctx.fillText(`Í∏∞Î≥∏: ATK ${it.stats.atk} DEF ${it.stats.def} HP ${it.stats.hp} CRIT ${it.stats.crit}% SPD ${it.stats.spd}`, x+14, baseY);

    ctx.fillStyle = "rgba(235,240,255,0.72)";
    ctx.font = "12px ui-monospace, Menlo, Consolas";
    let yy = baseY+20;

    if (!it.identified) {
      ctx.fillStyle = "rgba(255,207,91,0.88)";
      ctx.fillText("Ïû†Ïû¨ ÏòµÏÖò: ??? (Í∞êÏ†ï ÌïÑÏöî)", x+14, yy);
      yy += 18;
    } else if (it.aff && it.aff.length) {
      ctx.fillStyle = "rgba(91,140,255,0.85)";
      ctx.fillText("Ï∂îÍ∞Ä ÏòµÏÖò:", x+14, yy); yy+=18;
      ctx.fillStyle = "rgba(235,240,255,0.75)";
      for (const a of it.aff) {
        ctx.fillText(`- ${a.n} +${a.v}${(a.k.endsWith("P")||a.k==="crit"||a.k==="ls")?"%":""}`, x+24, yy);
        yy += 16;
      }
    } else {
      ctx.fillStyle = "rgba(235,240,255,0.55)";
      ctx.fillText("Ï∂îÍ∞Ä ÏòµÏÖò ÏóÜÏùå", x+14, yy);
      yy += 18;
    }

    ctx.restore();
  }

  function drawInventory(state){
    drawScene(state, true);

    const px = 40, py = 54, pw = 880, ph = 430;
    panel(px, py, pw, ph, "Ïù∏Î≤§ÌÜ†Î¶¨ (I/ESC: Îã´Í∏∞)");

    const p = state.player;

    const tabY = py+44;
    const bInv = {x:px+18, y:tabY, w:160, h:38};
    const bShop = {x:px+18+170, y:tabY, w:160, h:38};

    btn(bInv.x,bInv.y,bInv.w,bInv.h,"Ïù∏Î≤§ÌÜ†Î¶¨", true);
    btn(bShop.x,bShop.y,bShop.w,bShop.h,"ÏÉÅÏ†ê/Í∞êÏ†ï", false);
    if (hitBtn(bShop.x,bShop.y,bShop.w,bShop.h)) state.gs="SHOP";

    const leftX = px+18;
    const leftY = py+92;
    const leftW = 520;
    const leftH = ph-120;

    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    roundRect(leftX, leftY, leftW, leftH, 12, true, true);

    const rightX = leftX+leftW+16;
    const rightY = leftY;
    const rightW = pw - (rightX - px) - 18;
    const rightH = leftH;

    const all = getAllItems(state);
    all.sort((a,b)=>{
      if (a.where !== b.where) return a.where==="equip" ? -1 : 1;
      return itemPow(b.it)-itemPow(a.it);
    });

    const rowH = 34;
    const innerPad = 12;
    const clipX = leftX+innerPad, clipY = leftY+innerPad+34, clipW = leftW-innerPad*2, clipH = leftH-innerPad*2-34;

    ctx.fillStyle = "rgba(235,240,255,0.88)";
    ctx.font = "bold 13px ui-monospace, Menlo, Consolas";
    ctx.fillText(`Ïû•Ï∞©/Í∞ÄÎ∞© (Ïä§ÌÅ¨Î°§: ÎßàÏö∞Ïä§Ìú†)`, leftX+14, leftY+28);

    const maxRows = Math.floor(clipH/rowH);
    const maxScroll = Math.max(0, all.length - maxRows);
    if (pointer.wheelY !== 0) {
      const delta = Math.sign(pointer.wheelY);
      state.invScroll = clamp(state.invScroll + delta, 0, maxScroll);
    }

    ctx.save();
    ctx.beginPath();
    ctx.rect(clipX, clipY, clipW, clipH);
    ctx.clip();

    for (let i=0;i<all.length;i++){
      const row = i - state.invScroll;
      if (row < 0 || row >= maxRows) continue;
      const y = clipY + row*rowH;
      const it = all[i].it;
      const where = all[i].where;

      const isSel = (state.invSelId === it.id);
      ctx.fillStyle = isSel ? "rgba(91,140,255,0.16)" : (i%2===0 ? "rgba(255,255,255,0.03)" : "rgba(0,0,0,0)");
      ctx.fillRect(clipX, y, clipW, rowH-2);

      ctx.fillStyle = rarColor(it.rar);
      ctx.font = "bold 12px ui-monospace, Menlo, Consolas";
      ctx.fillText(where==="equip" ? "E" : "B", clipX+6, y+22);

      ctx.fillStyle = "rgba(235,240,255,0.86)";
      ctx.font = "12px ui-monospace, Menlo, Consolas";
      const txt = itemLine(it);
      ctx.fillText(txt, clipX+28, y+22);

      if (pointer.clicked && pointer.x>=clipX && pointer.x<=clipX+clipW && pointer.y>=y && pointer.y<=y+rowH-2){
        invSelect(state, it.id);
      }
    }
    ctx.restore();

    const sel = all.find(x=>x.it.id===state.invSelId)?.it || null;

    if (!sel) {
      ctx.fillStyle = "rgba(235,240,255,0.70)";
      ctx.font = "14px system-ui, -apple-system, Segoe UI";
      ctx.fillText("ÏôºÏ™ΩÏóêÏÑú ÏïÑÏù¥ÌÖúÏùÑ ÏÑ†ÌÉùÌï¥.", rightX+10, rightY+30);
    } else {
      drawItemDetail(state, rightX, rightY, rightW, rightH-120, sel);

      const bbY = rightY + rightH - 110;
      const bw = (rightW - 20);
      const b1 = {x:rightX+10, y:bbY, w:bw, h:40};
      const b2 = {x:rightX+10, y:bbY+46, w:bw, h:40};

      const inEquip = Object.values(p.equip).some(x=>x && x.id===sel.id);

      if (inEquip) {
        btn(b1.x,b1.y,b1.w,b1.h, `Ìï¥Ï†ú(Í∞ÄÎ∞©ÏúºÎ°ú)`, true);
        if (hitBtn(b1.x,b1.y,b1.w,b1.h)) {
          unequipToBag(state, sel.slot);
          state.msg="Ìï¥Ï†ú ÏôÑÎ£å";
          state.msgT=1.2;
        }
      } else {
        btn(b1.x,b1.y,b1.w,b1.h, `Ïû•Ï∞©`, true);
        if (hitBtn(b1.x,b1.y,b1.w,b1.h)) {
          equipFromBag(state, sel.id);
          state.msg="Ïû•Ï∞© ÏôÑÎ£å";
          state.msgT=1.2;
        }
      }

      if (!sel.identified) {
        const costTxt = (p.appraiseTickets>0) ? "Í∞êÏ†ï(Í∞êÏ†ïÍ∂å 1)" : `Í∞êÏ†ï(${APPRAISE_PRICE}G)`;
        btn(b2.x,b2.y,b2.w,b2.h, costTxt, true);
        if (hitBtn(b2.x,b2.y,b2.w,b2.h)) {
          appraiseOne(state, sel.id);
        }
      } else {
        const canSell = p.invItems.some(x=>x.id===sel.id);
        btn(b2.x,b2.y,b2.w,b2.h, canSell ? `ÌåêÎß§(+${sellPrice(sel)}G)` : "ÌåêÎß§(Ïû•Ï∞© Ï§ë Î∂àÍ∞Ä)", canSell);
        if (canSell && hitBtn(b2.x,b2.y,b2.w,b2.h)) {
          sellItemFromBag(state, sel.id);
        }
      }
    }

    if (pressed.menu) { pressed.menu=false; state.gs="PAUSE"; }
    if (pressed.inv) { pressed.inv=false; state.gs="PLAY"; }
  }

  // -------------------- SHOP --------------------
  function sellAllNormal(state){
    const p = state.player;
    const before = p.invItems.length;
    let gain = 0;
    const keep = [];
    for (const it of p.invItems){
      if (it.rar === "N") gain += sellPrice(it);
      else keep.push(it);
    }
    const sold = before - keep.length;
    p.invItems = keep;
    p.gold += gain;
    if (sold>0) audio.playCoin();
    state.msg = sold>0 ? `ÏùºÎ∞òÌÖú ${sold}Í∞ú ÌåêÎß§ (+${gain}G)` : "ÌåêÎß§Ìï† ÏùºÎ∞òÌÖúÏù¥ ÏóÜÎã§.";
    state.msgT = 1.4;
    if (sold>0) markDirty(state);
  }

  function appraiseAll(state){
    const p = state.player;
    const targets = p.invItems.filter(it=>!it.identified);
    if (!targets.length) { state.msg="Í∞êÏ†ïÌï† ÎØ∏Í∞êÏ†ï ÏïÑÏù¥ÌÖúÏù¥ ÏóÜÎã§."; state.msgT=1.2; return; }

    let done = 0;
    for (const it of targets){
      if (p.appraiseTickets > 0) {
        p.appraiseTickets--;
        appraise(it);
        done++;
      } else if (p.gold >= APPRAISE_PRICE) {
        p.gold -= APPRAISE_PRICE;
        appraise(it);
        done++;
      } else {
        break;
      }
    }
    if (done>0) audio.playCoin();
    state.msg = (done>0) ? `ÏùºÍ¥Ñ Í∞êÏ†ï ${done}Í∞ú ÏôÑÎ£å` : "Í∞êÏ†ïÍ∂å/Í≥®ÎìúÍ∞Ä Î∂ÄÏ°±ÌïòÎã§.";
    state.msgT = 1.4;
    if (done>0) markDirty(state);
  }

  function buyPotion(state, qty){
    const p = state.player;
    const can = Math.min(qty, POTION_MAX - p.potions);
    if (can <= 0) { state.msg="Ìè¨ÏÖòÏù¥ Ïù¥ÎØ∏ Í∞ÄÎìùÌïòÎã§."; state.msgT=1.2; return; }
    const cost = can * POTION_PRICE;
    if (p.gold < cost) { state.msg=`Í≥®Îìú Î∂ÄÏ°±! (${cost}G ÌïÑÏöî)`; state.msgT=1.3; return; }
    p.gold -= cost;
    p.potions += can;
    audio.playCoin();
    state.msg = `Ìè¨ÏÖò ${can}Í∞ú Íµ¨Îß§ (-${cost}G)`;
    state.msgT = 1.3;
    markDirty(state);
  }

  function drawShop(state){
    drawScene(state, true);

    const px = 40, py = 54, pw = 880, ph = 430;
    panel(px, py, pw, ph, "ÏÉÅÏ†ê / Í∞êÏ†ï (ESC: Îí§Î°ú)");

    const tabY = py+44;
    const bInv = {x:px+18, y:tabY, w:160, h:38};
    const bShop = {x:px+18+170, y:tabY, w:160, h:38};

    btn(bInv.x,bInv.y,bInv.w,bInv.h,"Ïù∏Î≤§ÌÜ†Î¶¨", false);
    btn(bShop.x,bShop.y,bShop.w,bShop.h,"ÏÉÅÏ†ê/Í∞êÏ†ï", true);
    if (hitBtn(bInv.x,bInv.y,bInv.w,bInv.h)) state.gs="INV";

    const p = state.player;

    const leftX = px+18, leftY = py+92, leftW = 420, leftH = ph-120;
    ctx.fillStyle="rgba(255,255,255,0.06)";
    ctx.strokeStyle="rgba(255,255,255,0.12)";
    roundRect(leftX,leftY,leftW,leftH,12,true,true);

    ctx.fillStyle="rgba(235,240,255,0.88)";
    ctx.font="bold 13px ui-monospace, Menlo, Consolas";
    ctx.fillText(`GOLD ${p.gold}G | Ìè¨ÏÖò ${p.potions}/${POTION_MAX} | Í∞êÏ†ïÍ∂å ${p.appraiseTickets}`, leftX+14, leftY+28);

    const by = leftY+46;
    const bw = leftW-28;
    const bh = 44;
    const gap = 10;

    const b1 = {x:leftX+14, y:by, w:bw, h:bh};
    const b2 = {x:leftX+14, y:by+(bh+gap), w:bw, h:bh};
    const b3 = {x:leftX+14, y:by+2*(bh+gap), w:bw, h:bh};
    const b4 = {x:leftX+14, y:by+3*(bh+gap), w:bw, h:bh};
    const b5 = {x:leftX+14, y:by+4*(bh+gap), w:bw, h:bh};

    btn(b1.x,b1.y,b1.w,b1.h, `Ìè¨ÏÖò 1Í∞ú Íµ¨Îß§ (${POTION_PRICE}G)`, true);
    btn(b2.x,b2.y,b2.w,b2.h, `Ìè¨ÏÖò 3Í∞ú Íµ¨Îß§ (${POTION_PRICE*3}G)`, true);
    btn(b3.x,b3.y,b3.w,b3.h, `ÎØ∏Í∞êÏ†ï ÏùºÍ¥Ñ Í∞êÏ†ï (Í∞êÏ†ïÍ∂å/Í≥®Îìú)`, true);
    btn(b4.x,b4.y,b4.w,b4.h, `ÏùºÎ∞òÌÖú(N) ÏùºÍ¥Ñ ÌåêÎß§`, false);
    btn(b5.x,b5.y,b5.w,b5.h, `Îí§Î°úÍ∞ÄÍ∏∞(ESC)`, true);

    if (hitBtn(b1.x,b1.y,b1.w,b1.h)) { buyPotion(state,1); }
    if (hitBtn(b2.x,b2.y,b2.w,b2.h)) { buyPotion(state,3); }
    if (hitBtn(b3.x,b3.y,b3.w,b3.h)) { appraiseAll(state); }
    if (hitBtn(b4.x,b4.y,b4.w,b4.h)) { sellAllNormal(state); }
    if (hitBtn(b5.x,b5.y,b5.w,b5.h)) { state.gs="PAUSE"; }

    const rightX = leftX+leftW+16, rightY=leftY, rightW=pw-(rightX-px)-18, rightH=leftH;
    ctx.fillStyle="rgba(255,255,255,0.06)";
    ctx.strokeStyle="rgba(255,255,255,0.12)";
    roundRect(rightX,rightY,rightW,rightH,12,true,true);

    ctx.fillStyle="rgba(235,240,255,0.88)";
    ctx.font="bold 13px ui-monospace, Menlo, Consolas";
    ctx.fillText("ÎØ∏Í∞êÏ†ï ÏïÑÏù¥ÌÖú Î™©Î°ù", rightX+14, rightY+28);

    const list = p.invItems.filter(it=>!it.identified);
    ctx.fillStyle="rgba(235,240,255,0.60)";
    ctx.font="12px ui-monospace, Menlo, Consolas";
    ctx.fillText(`Í∞úÏàò: ${list.length} | Í∞êÏ†ïÍ∂å Ïö∞ÏÑ† ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ 1Í∞úÎãπ ${APPRAISE_PRICE}G`, rightX+14, rightY+48);

    const rowH = 28;
    const clipX = rightX+12, clipY = rightY+64, clipW = rightW-24, clipH = rightH-76;
    const maxRows = Math.floor(clipH/rowH);
    const maxScroll = Math.max(0, list.length - maxRows);

    if (pointer.wheelY !== 0) {
      const delta = Math.sign(pointer.wheelY);
      state.shopScroll = clamp(state.shopScroll + delta, 0, maxScroll);
    }

    ctx.save();
    ctx.beginPath(); ctx.rect(clipX,clipY,clipW,clipH); ctx.clip();
    for (let i=0;i<list.length;i++){
      const row = i - state.shopScroll;
      if (row<0 || row>=maxRows) continue;
      const y = clipY + row*rowH;
      const it = list[i];

      ctx.fillStyle = (i%2===0) ? "rgba(255,255,255,0.03)" : "rgba(0,0,0,0)";
      ctx.fillRect(clipX,y,clipW,rowH-2);

      ctx.fillStyle = rarColor(it.rar);
      ctx.font="bold 12px ui-monospace, Menlo, Consolas";
      ctx.fillText(`[${it.rar}]`, clipX+6, y+19);

      ctx.fillStyle="rgba(235,240,255,0.80)";
      ctx.font="12px ui-monospace, Menlo, Consolas";
      ctx.fillText(`${slotName(it.slot)} | ${it.name} | iLv ${it.ilvl} | Í∞êÏ†ï ÌïÑÏöî`, clipX+62, y+19);

      const bX = clipX + clipW - 92;
      const bY = y + 3;
      const bW = 84;
      const bH = 22;

      const can = (p.appraiseTickets>0) || (p.gold>=APPRAISE_PRICE);
      ctx.fillStyle = can ? "rgba(91,140,255,0.22)" : "rgba(255,255,255,0.06)";
      ctx.strokeStyle = can ? "rgba(91,140,255,0.52)" : "rgba(255,255,255,0.10)";
      roundRect(bX,bY,bW,bH,10,true,true);
      ctx.fillStyle = "rgba(235,240,255,0.92)";
      ctx.font="bold 12px system-ui, -apple-system, Segoe UI";
      ctx.fillText("Í∞êÏ†ï", bX+24, bY+16);

      if (pointer.clicked && pointer.x>=bX && pointer.x<=bX+bW && pointer.y>=bY && pointer.y<=bY+bH) {
        appraiseOne(state, it.id);
      }
    }
    ctx.restore();

    if (pressed.menu) { pressed.menu=false; state.gs="PAUSE"; }
    if (pressed.inv) { pressed.inv=false; state.gs="INV"; }
  }

  // -------------------- PLAY update --------------------
  function updatePlay(state, dt){
    const p = state.player;
    const d = p.derived();

    p.atkCd = Math.max(0, p.atkCd - dt);
    p.skillCd = Math.max(0, p.skillCd - dt);
    p.inv = Math.max(0, p.inv - dt);
    p.hitCd = Math.max(0, p.hitCd - dt);
    p.attackLock = Math.max(0, p.attackLock - dt);
    p.potionCd = Math.max(0, p.potionCd - dt);

    // ‚úÖ Ï†ÑÌà¨ Ï¢ÖÎ£å ÌõÑ ÏûêÏó∞ ÌöåÎ≥µ(Î≥µÍµ¨)
    let nearEnemy = false;
    for (const e of state.enemies) {
      if (e.dead) continue;
      if (Math.abs(e.x - p.x) < REGEN_NEAR_ENEMY) { nearEnemy = true; break; }
    }
    if (nearEnemy) p.regenBlockT = REGEN_DELAY;
    else p.regenBlockT = Math.max(0, p.regenBlockT - dt);

    if (p.regenBlockT <= 0) {
      const hpMax = d.hpMax;
      if (p.hp < hpMax) {
        p.regenAcc += (hpMax * REGEN_RATE_PCT) * dt;
        const add = Math.floor(p.regenAcc);
        if (add >= 1) {
          p.regenAcc -= add;
          const before = p.hp;
          p.hp = clamp(p.hp + add, 0, hpMax);
          if (p.hp !== before) markDirty(state);
        }
      } else {
        p.regenAcc = 0;
      }
    }

    const ax = moveAxis();
    if (p.attackLock > 0 && p.onGround) p.vx = 0;
    else p.vx = ax * d.spd * dt;
    if (ax !== 0) p.face = ax > 0 ? 1 : -1;

    if (pressed.jump && p.onGround) {
      p.vy = -520;
      p.onGround = false;
    }
    pressed.jump = false;

    if (pressed.potion) tryUsePotion(state);
    pressed.potion = false;

    p.vy += 1200 * dt;
    collidePlatforms(p, state.platforms);

    if (p.inv > 0) p.anim = "hurt";
    else if (!p.onGround) p.anim = "jump";
    else if (Math.abs(ax) > 0.05 && p.attackLock <= 0) p.anim = "run";
    else p.anim = "idle";

    p.animT += dt;
    if (p.anim !== state._prevAnimP) { p.animT = 0; state._prevAnimP = p.anim; }

    const doAtk = wantAttack();
    const doSkl = wantSkill();

    // Í≥µÍ≤©(Z)
    if (doAtk && p.atkCd <= 0) {
      p.regenBlockT = REGEN_DELAY; // Ï†ÑÌà¨ ÌñâÏúÑ -> ÌöåÎ≥µ ÎßâÍ∏∞
      p.atkCd = 0.30;
      p.anim = "attack"; p.animT = 0;
      p.attackLock = Math.max(p.attackLock, ATTACK_LOCK_ATK);

      const hx = p.x + p.face * 46;
      const hy = p.y - 10;
      const hw = 72, hh = 52;

      let hit = 0;
      for (const e of state.enemies) {
        if (e.dead) continue;
        if (aabb(hx - hw/2, hy - hh/2, hw, hh, e.x - e.w/2, e.y - e.h/2, e.w, e.h)) {
          const { dmg, crit } = damageCalc(d.atk, e.def, d.crit, 1.05);
          e.hp = clamp(e.hp - dmg, 0, e.hpMax);
          e.hitCd = 0.12;

          e.vy = 0;
          snapToGround(e);

          hit++;
          spawnHitFX(state, e.x, e.y - 14);
          state.dmgText.push(new DamageText(
            e.x, e.y - 64, `${crit ? "‚ú¶" : ""}${dmg}`,
            crit ? "rgba(255,235,120,0.95)" : "rgba(235,240,255,0.92)"
          ));

          if (e.hp <= 0) {
            e.dead = true; e.dieT = 0;
            dropRewards(state, e);
            state.killed++;
            p.kills++;
          }
          markDirty(state);
        }
      }
      if (hit === 0) audio.playHit();
    }
    pressed.atk = false;

    // Ïä§ÌÇ¨(X)
    if (doSkl && p.skillCd <= 0) {
      p.regenBlockT = REGEN_DELAY; // Ï†ÑÌà¨ ÌñâÏúÑ -> ÌöåÎ≥µ ÎßâÍ∏∞
      p.skillCd = 2.8;
      p.atkCd = 0.42;
      p.anim = "attack"; p.animT = 0;
      p.attackLock = Math.max(p.attackLock, ATTACK_LOCK_SKL);

      const hx = p.x + p.face * 78;
      const hy = p.y - 12;
      const hw = 160, hh = 76;

      for (const e of state.enemies) {
        if (e.dead) continue;
        if (aabb(hx - hw/2, hy - hh/2, hw, hh, e.x - e.w/2, e.y - e.h/2, e.w, e.h)) {
          const { dmg, crit } = damageCalc(d.atk, e.def, d.crit, 1.85);
          e.hp = clamp(e.hp - dmg, 0, e.hpMax);
          e.hitCd = 0.16;

          e.vy = 0;
          snapToGround(e);

          spawnHitFX(state, e.x, e.y - 14);
          state.dmgText.push(new DamageText(
            e.x, e.y - 64, `${crit ? "‚ú¶" : ""}${dmg}`,
            "rgba(255,207,91,0.95)"
          ));

          if (e.hp <= 0) {
            e.dead = true; e.dieT = 0;
            dropRewards(state, e);
            state.killed++;
            p.kills++;
          }
          markDirty(state);
        }
      }
    }
    pressed.skill = false;

    // Ï†Å AI + Ï†ëÏ¥â ÌåêÏ†ï
    for (const e of state.enemies) {
      if (e.dead) { e.dieT += dt; continue; }
      e.hitCd = Math.max(0, e.hitCd - dt);
      e.aiT += dt;
      e.jumpCd = Math.max(0, e.jumpCd - dt);

      const dx = p.x - e.x;
      const ad = Math.abs(dx);
      const chase = ad < 360 || (e.tier==="boss" && ad < 520);
      const dir = dx > 0 ? 1 : -1;
      e.face = dir;

      e.vx = chase ? (dir * e.spd * dt * 0.75) : (Math.sin(e.aiT*1.2) * e.spd * dt * 0.28);
      e.vy += 1100 * dt;

      collidePlatforms(e, state.platforms);
      snapToGround(e);

      const overlapped = aabb(
        p.x - p.w/2, p.y - p.h/2, p.w, p.h,
        e.x - e.w/2, e.y - e.h/2, e.w, e.h
      );

      if (overlapped) stabilizeOverlapNoBounce(p, e);

      if (overlapped && p.inv <= 0 && p.hitCd <= 0) {
        p.regenBlockT = REGEN_DELAY; // ÌîºÍ≤© -> ÌöåÎ≥µ ÎßâÍ∏∞

        const { dmg } = damageCalc(e.atk, d.def, 0, 1);

        p.hp = clamp(p.hp - dmg, 0, d.hpMax);
        p.inv = 0.55;
        p.hitCd = CONTACT_DAMAGE_COOLDOWN;

        audio.playHit();
        state.dmgText.push(new DamageText(p.x, p.y - 64, `-${dmg}`, "rgba(255,91,110,0.95)"));
        p.x += -e.face * 14;

        markDirty(state);

        if (p.hp <= 0) {
          const lost = Math.round(p.gold * 0.08);
          p.gold = Math.max(0, p.gold - lost);
          p.hp = d.hpMax;
          state.gs = "MENU";
          state.msg = `Î≥¥Ïä§Í≤åÏù¥Ìä∏ÏóêÏÑú Ïì∞Îü¨Ï°åÎã§‚Ä¶ ${lost}G ÏûÉÏùå.`;
          state.msgT = 2.0;
          markDirty(state);
          return;
        }
      }

      if (e.dead) e.anim = "die";
      else if (e.hitCd > 0) e.anim = "hurt";
      else if (!e.onGround) e.anim = "run";
      else if (chase) e.anim = "run";
      else e.anim = "idle";

      e.animT += dt;
      if (e.anim !== e._prevAnim) { e.animT = 0; e._prevAnim = e.anim; }
    }

    if (state.killed >= state.goalKills) ensureDoor(state);

    // ÏΩîÏù∏ ÏàòÏßë
    for (let i=state.coins.length-1;i>=0;i--){
      const c = state.coins[i];
      c.t += dt;
      c.vy += 1100*dt;
      c.x += c.vx*dt;
      c.y += c.vy*dt;
      if (c.y > GROUND_Y - 12) {
        c.y = GROUND_Y - 12;
        c.vy *= -0.22;
        c.vx *= 0.55;
      }
      if (dist(c.x,c.y, p.x, p.y-20) < 38) {
        p.gold += c.amount;
        state.coins.splice(i,1);
        audio.playCoin();
        markDirty(state);
      }
    }

    // Î£®ÌåÖ
    for (let i=state.loots.length-1;i>=0;i--){
      const l = state.loots[i];
      l.t += dt;
      l.vy += 1100*dt;
      l.x += l.vx*dt;
      l.y += l.vy*dt;
      if (l.y > GROUND_Y - 16) {
        l.y = GROUND_Y - 16;
        l.vy *= -0.18;
        l.vx *= 0.45;
      }
      if (dist(l.x,l.y, p.x, p.y-20) < 38) {
        p.invItems.push(l.item);
        state.loots.splice(i,1);
        state.msg = `ÌöçÎìù: [${l.item.rar}] ${l.item.name}${l.item.identified?"":"(ÎØ∏Í∞êÏ†ï)"}`;
        state.msgT = 1.5;
        markDirty(state);
      }
    }

    // Î¨∏ ÏßÑÏûÖ
    if (state.door) {
      const d0 = state.door;
      if (aabb(p.x - p.w/2, p.y - p.h/2, p.w, p.h, d0.x, d0.y, d0.w, d0.h)) {
        stageClearReward(state);
        state.stageIndex += 1;
        state.player.stage = state.stageIndex;
        rebuildStage(state);
        markDirty(state);
      }
    }

    for (const f of state.fx) f.update(dt);
    state.fx = state.fx.filter(x => !x.dead());
    for (const t of state.dmgText) t.update(dt);
    state.dmgText = state.dmgText.filter(x => !x.dead());
    for (const pa of state.parts) pa.update(dt);
    state.parts = state.parts.filter(x => !x.dead());

    if (state.msgT > 0) state.msgT -= dt;

    cam.y = CAM_Y;
    const targetX = clamp(p.x - VIEW_W*0.45, 0, WORLD.w - VIEW_W);
    state.camX = lerp(state.camX, targetX, smoothFactor(dt, 18));
    cam.x = state.camX;

    // HUD ÌÅ¥Î¶≠(‚öô/üß™/üéí) - ‚úÖ Ï†ÄÏû• Ìò∏Ï∂ú Ï†úÍ±∞(ÏûêÎèô Ï†ÄÏû• Í∏àÏßÄ)
    const hotGear = (pointer.x>=HUD_MENU_BTN.x && pointer.x<=HUD_MENU_BTN.x+HUD_MENU_BTN.w &&
                     pointer.y>=HUD_MENU_BTN.y && pointer.y<=HUD_MENU_BTN.y+HUD_MENU_BTN.h);
    if (pointer.clicked && hotGear) state.gs = "PAUSE";

    const hotPotionHud = (pointer.x>=HUD_POTION_BTN.x && pointer.x<=HUD_POTION_BTN.x+HUD_POTION_BTN.w &&
                          pointer.y>=HUD_POTION_BTN.y && pointer.y<=HUD_POTION_BTN.y+HUD_POTION_BTN.h);
    if (pointer.clicked && hotPotionHud) { tryUsePotion(state); }

    const hotInv = (pointer.x>=HUD_INV_BTN.x && pointer.x<=HUD_INV_BTN.x+HUD_INV_BTN.w &&
                    pointer.y>=HUD_INV_BTN.y && pointer.y<=HUD_INV_BTN.y+HUD_INV_BTN.h);
    if (pointer.clicked && hotInv) { state.gs = "INV"; }

    if (pressed.menu) { pressed.menu = false; state.gs = "PAUSE"; return; }
    if (pressed.inv) { pressed.inv = false; state.gs = "INV"; return; }
  }

  // -------------------- Revive --------------------
  function revive(raw){
    const st = freshState();
    st.gs = raw.gs || "MENU";
    st.opt = raw.opt || st.opt;

    st.player = new Player();
    Object.assign(st.player, raw.player || {});
    st.player.invItems ??= [];
    st.player.equip ??= { weapon:null, armor:null, ring:null };
    st.player.appraiseTickets ??= 0;
    st.player.regenBlockT ??= 0;
    st.player.regenAcc ??= 0;

    for (const s of SLOTS) st.player.equip[s] = st.player.equip[s] || null;

    st.stageIndex = raw.stageIndex ?? st.stageIndex;
    st.inBossRoom = raw.inBossRoom ?? st.inBossRoom;

    rebuildStage(st);

    st.player.invItems = raw.player?.invItems ?? st.player.invItems;
    st.player.equip = raw.player?.equip ?? st.player.equip;
    for (const s of SLOTS) st.player.equip[s] = st.player.equip[s] || null;

    st.player.gold = raw.player?.gold ?? st.player.gold;
    st.player.hp = raw.player?.hp ?? st.player.hp;

    st.killed = raw.killed ?? 0;
    st.goalKills = raw.goalKills ?? st.goalKills;

    st.msg = raw.msg ?? st.msg;
    st.msgT = raw.msgT ?? 0;

    st.invSelId = null;
    st.invScroll = 0;
    st.shopScroll = 0;

    st.t = 0;
    st.camX = 0;

    st._dirty = false;
    st.gs = "PLAY"; // ‚úÖ Î°úÎìú ÌõÑ Ìï≠ÏÉÅ Ï†ïÏÉÅ ÏÉÅÌÉúÎ°ú ÏßÑÏûÖ
    return st;
  }

  // -------------------- Main Loop --------------------
  let state = load() ? revive(load()) : freshState();
  applyOptions(state);
  if (state.gs === "PLAY") rebuildStage(state);

  let last = performance.now();
  function loop(t){
    const dt = Math.min(0.033, (t - last)/1000);
    last = t;

    state.t += dt;

    if (state.gs === "PLAY") updatePlay(state, dt);

    state.updatedAt = isoNow();

    ctx.clearRect(0,0,VIEW_W,VIEW_H);

    if (state.gs === "MENU") drawMenu(state);
    else if (state.gs === "OPTIONS") drawOptions(state);
    else if (state.gs === "PAUSE") drawPause(state);
    else if (state.gs === "INV") drawInventory(state);
    else if (state.gs === "SHOP") drawShop(state);
    else drawScene(state);

    // ESC fallback
    if (pressed.menu) {
      pressed.menu = false;
      if (state.gs === "OPTIONS") state.gs = "MENU";
      else if (state.gs === "INV" || state.gs === "SHOP") state.gs = "PAUSE";
      else if (state.gs === "PAUSE") state.gs = "PLAY";
      else if (state.gs === "PLAY") state.gs = "PAUSE";
    }

    pointer.clicked = false;
    pointer.wheelY = 0;
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
