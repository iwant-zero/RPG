<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Î≥¥Ïä§Í≤åÏù¥Ìä∏ (BOSS GATE)</title>
  <style>
    :root { color-scheme: dark; }
    html, body {
      margin: 0;
      height: 100%;
      background: #050812;
      overflow: hidden;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Apple SD Gothic Neo, Noto Sans KR, sans-serif;
    }

    /* ‚úÖ Î™®Î∞îÏùº Ï£ºÏÜåÏ∞Ω/Ìà¥Î∞î Î≥ÄÌôîÎ°ú Ïù∏Ìïú vh ÌùîÎì§Î¶º ÏôÑÌôî */
    #wrap { height: 100dvh; display: grid; place-items: center; }

    /* ‚úÖ aspect-ratioÎ°ú ÌôîÎ©¥ ÌÅ¨Í∏∞ Í≥ÑÏÇ∞ ÌùîÎì§Î¶º(1px ÏôîÎã§Í∞îÎã§) ÏôÑÌôî */
    #stage {
      position: relative;
      width: min(100vw, 960px);
      aspect-ratio: 16 / 9;
      height: auto;
      max-height: min(100dvh, 540px);
      background: #050812;
      border-radius: 14px;
      box-shadow: 0 10px 40px rgba(0,0,0,.45);
      overflow: hidden;
    }

    canvas#game { width: 100%; height: 100%; display: block; background: #050812; }

    #touch { position: absolute; inset: 0; pointer-events: none; }
    .btn {
      pointer-events: auto;
      position: absolute;
      width: 62px; height: 62px;
      border-radius: 16px;
      display: grid; place-items: center;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      color: rgba(235,240,255,0.92);
      font-weight: 900; font-size: 18px;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      touch-action: none;
    }
    .btn:active {
      transform: translateY(1px);
      background: rgba(91,140,255,0.20);
      border-color: rgba(91,140,255,0.55);
    }
    #b-left { left: 16px; bottom: 22px; }
    #b-right { left: 92px; bottom: 22px; }

    #b-jump { right: 16px; bottom: 96px; width: 70px; height: 70px; border-radius: 18px; font-size: 18px; }
    #b-atk { right: 96px; bottom: 22px; }
    #b-skill { right: 16px; bottom: 22px; }
    #b-potion { right: 96px; bottom: 96px; width: 70px; height: 70px; border-radius: 18px; font-size: 18px; }
    #b-menu { right: 16px; top: 16px; width: 54px; height: 54px; border-radius: 14px; font-size: 18px; }
  </style>
</head>

<body>
  <div id="wrap">
    <div id="stage">
      <canvas id="game" width="960" height="540"></canvas>
      <div id="touch" aria-hidden="true">
        <div class="btn" id="b-left" data-k="left">‚óÄ</div>
        <div class="btn" id="b-right" data-k="right">‚ñ∂</div>

        <div class="btn" id="b-jump" data-k="jump">‚§í</div>
        <div class="btn" id="b-potion" data-k="potion">üß™</div>
        <div class="btn" id="b-atk" data-k="atk">Z</div>
        <div class="btn" id="b-skill" data-k="skill">X</div>

        <div class="btn" id="b-menu" data-k="menu">‚öô</div>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d", { alpha: false });
  const stageEl = document.getElementById("stage");

  const VIEW_W = 960;
  const VIEW_H = 540;

  /* =========================
     ‚úÖ Îñ®Î¶º(Í≤πÏ≥êÎ≥¥ÏûÑ) Ìï¥Í≤∞ ÌïµÏã¨:
     - CSSÎ°ú Î≥¥Ïù¥Îäî Ïã§Ï†ú ÌÅ¨Í∏∞(#stage px)Ïóê ÎßûÏ∂∞ canvas bufferÎ•º ÎßûÏ∂§
     - 1px ÎØ∏ÏÑ∏Î≥ÄÎèôÏùÑ Ï†ïÏàòÌôî + ResizeObserverÎ°ú Ï∂îÏ†Å
     ========================= */
  function getDpr() { return Math.max(1, Math.min(2.5, window.devicePixelRatio || 1)); }

  function resize() {
    if (!stageEl) return;

    const rect = stageEl.getBoundingClientRect();

    // ÌëúÏãú ÌÅ¨Í∏∞(px)Î•º "Ï†ïÏàò"Î°ú Í≥†Ï†ïÌï¥ ÎØ∏ÏÑ∏ ÌùîÎì§Î¶º Ï†úÍ±∞
    const cssW = Math.max(1, Math.round(rect.width));
    const cssH = Math.max(1, Math.round(rect.height));

    const dpr = getDpr();
    const bufW = Math.floor(cssW * dpr);
    const bufH = Math.floor(cssH * dpr);

    // ÌÅ¨Í∏∞ Î≥ÄÌôî ÏóÜÏúºÎ©¥ Ïä§ÌÇµ(Î∂àÌïÑÏöîÌïú setTransform Î∞òÎ≥µ Î∞©ÏßÄ)
    if (canvas.width === bufW && canvas.height === bufH) return;

    canvas.width = bufW;
    canvas.height = bufH;

    // ÎÖºÎ¶¨Ï¢åÌëú(960x540)Î•º ÌòÑÏû¨ Î≤ÑÌçº ÌÅ¨Í∏∞Ïóê Îß§Ìïë
    const sx = bufW / VIEW_W;
    const sy = bufH / VIEW_H;
    ctx.setTransform(sx, 0, 0, sy, 0, 0);

    ctx.imageSmoothingEnabled = true;
  }

  window.addEventListener("resize", resize, { passive: true });

  // stageÏùò Ïã§Ï†ú ÌÅ¨Í∏∞ Î≥ÄÌôî(Î™®Î∞îÏùº Ï£ºÏÜåÏ∞Ω Îì±)ÎèÑ Ï∂îÏ†Å
  if (window.ResizeObserver && stageEl) {
    const ro = new ResizeObserver(() => resize());
    ro.observe(stageEl);
  } else {
    // Íµ¨Ìòï Î∏åÎùºÏö∞Ï†Ä fallback
    setInterval(resize, 250);
  }

  resize();

  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const rand = (a, b) => Math.random() * (b - a) + a;
  const randi = (a, b) => Math.floor(rand(a, b + 1));
  const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
  const dist = (ax, ay, bx, by) => Math.hypot(ax - bx, ay - by);
  const isoNow = () => new Date().toISOString();
  const lerp = (a,b,t)=>a+(b-a)*t;
  function smoothFactor(dt, sharpness=18){ return 1 - Math.pow(0.001, dt*sharpness); }

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (["arrowleft","arrowright","arrowup"," ","z","x","escape","i","p","h","enter","backspace"].includes(k)) {
      e.preventDefault();
      e.stopPropagation();
    }
  }, { passive:false });

  const SAVE_KEY = "boss_gate_web_v10_inventory_restore";
  function save(state) { try { localStorage.setItem(SAVE_KEY, JSON.stringify(state)); } catch {} }
  function load() {
    try {
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch { return null; }
  }

  class AudioMan {
    constructor() {
      this.ctx = null; this.master=null; this.bgmGain=null; this.sfxGain=null;
      this.unlocked = false;
      this.muted = false; this.bgmOn = true; this.sfxOn = true;

      this._bases = {
        bgm:  "./assets/bgm",
        hit:  "./assets/sfx_hit",
        coin: "./assets/sfx_coin",
      };
      this._exts = [".m4a", ".mp3", ".mp4"];

      this.files = {
        bgm:  new Audio(),
        hit:  new Audio(),
        coin: new Audio(),
      };
      this.files.bgm.loop = true;

      for (const k of Object.keys(this.files)) {
        const a = this.files[k];
        a.preload = "auto";
        a.volume = (k === "bgm") ? 0.55 : 0.65;
      }

      this._picked = { bgm:null, hit:null, coin:null };
      this.preResolveAll().catch(()=>{});
    }

    _scoreCanPlay(ext){
      const test = document.createElement("audio");
      const map = {
        ".mp3": ["audio/mpeg"],
        ".m4a": ["audio/mp4", "audio/aac"],
        ".mp4": ["audio/mp4", "video/mp4"],
      };
      const mimes = map[ext] || [];
      let best = 0;
      for (const m of mimes){
        const r = test.canPlayType(m);
        if (r === "probably") best = Math.max(best, 2);
        else if (r === "maybe") best = Math.max(best, 1);
      }
      return best;
    }

    _candidateUrls(base){
      const scored = this._exts.map((ext, idx) => ({
        url: base + ext,
        score: this._scoreCanPlay(ext),
        idx
      }))
      .sort((a,b)=> (b.score - a.score) || (a.idx - b.idx));
      return scored.map(x=>x.url);
    }

    async _exists(url){
      try {
        const r = await fetch(url, { method:"HEAD", cache:"no-cache" });
        if (r.ok) return true;
      } catch {}
      try {
        const r2 = await fetch(url, { method:"GET", cache:"no-cache" });
        return r2.ok;
      } catch {}
      return false;
    }

    async resolve(key){
      if (this._picked[key]) return this._picked[key];

      const base = this._bases[key];
      const urls = this._candidateUrls(base);

      for (const url of urls){
        if (await this._exists(url)) {
          this._picked[key] = url;
          this._applySource(key, url);
          return url;
        }
      }

      const fallback = urls[0] || (base + ".mp3");
      this._picked[key] = fallback;
      this._applySource(key, fallback);
      return fallback;
    }

    _applySource(key, url){
      const a = this.files[key];
      if (!a) return;
      if (a.src && a.src.endsWith(url)) return;
      a.src = url;
      if (key === "bgm") a.loop = true;
      a.load();
    }

    async preResolveAll(){
      await Promise.all([ this.resolve("bgm"), this.resolve("hit"), this.resolve("coin") ]);
    }

    ensureCtx() {
      if (this.ctx) return;
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) return;
      this.ctx = new AC();
      this.master = this.ctx.createGain();
      this.bgmGain = this.ctx.createGain();
      this.sfxGain = this.ctx.createGain();
      this.master.connect(this.ctx.destination);
      this.bgmGain.connect(this.master);
      this.sfxGain.connect(this.master);
      this.master.gain.value = 0.9;
      this.bgmGain.gain.value = 0.45;
      this.sfxGain.gain.value = 0.75;
    }

    async unlock() {
      if (this.unlocked) return;
      this.ensureCtx();
      try { if (this.ctx && this.ctx.state !== "running") await this.ctx.resume(); } catch {}
      this.unlocked = true;

      if (this.ctx) {
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        g.gain.value = 0.0001;
        o.connect(g); g.connect(this.master);
        o.start(); o.stop(this.ctx.currentTime + 0.02);
      }
    }

    setMuted(v) {
      this.muted = v;
      if (this.master) this.master.gain.value = v ? 0 : 0.9;
      for (const a of Object.values(this.files)) a.muted = v;
    }

    beep(freq, dur, type="square", vol=0.2) {
      if (!this.sfxOn || this.muted) return;
      this.ensureCtx();
      if (!this.ctx) return;
      const t0 = this.ctx.currentTime;
      const o = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      o.connect(g); g.connect(this.sfxGain);
      o.start(t0); o.stop(t0 + dur + 0.02);
    }

    async _safePlay(key, fallbackBeep){
      if (this.muted) return false;
      await this.resolve(key);
      const a = this.files[key];
      try {
        a.currentTime = 0;
        await a.play();
        return true;
      } catch {
        this._picked[key] = null;
        await this.resolve(key);
        try {
          a.currentTime = 0;
          await a.play();
          return true;
        } catch {
          if (fallbackBeep) fallbackBeep();
          return false;
        }
      }
    }

    async startBgm() {
      if (!this.bgmOn || this.muted) return;
      const ok = await this._safePlay("bgm", () => {
        this.ensureCtx();
        if (!this.ctx) return;
        if (this._bgmNode) return;
        const t0 = this.ctx.currentTime;
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        o.type = "sine";
        g.gain.value = 0.0001;
        o.connect(g); g.connect(this.bgmGain);
        const notes = [220, 277.18, 329.63, 392.0, 329.63, 277.18];
        for (let i=0;i<999;i++){
          const f = notes[i % notes.length] * (i % 12 === 0 ? 0.5 : 1);
          o.frequency.setValueAtTime(f, t0 + i*0.22);
        }
        g.gain.exponentialRampToValueAtTime(0.12, t0 + 0.12);
        o.start(t0);
        this._bgmNode = { o, g };
      });
      if (ok) {
        const bgm = this.files.bgm;
        bgm.loop = true;
        bgm.volume = 0.55;
      }
    }

    stopBgm() {
      const bgm = this.files.bgm;
      try { bgm.pause(); bgm.currentTime = 0; } catch {}
      if (this._bgmNode && this.ctx) {
        try { this._bgmNode.o.stop(); } catch {}
        this._bgmNode = null;
      }
    }

    async playHit() {
      if (!this.sfxOn || this.muted) return;
      await this._safePlay("hit", () => {
        this.beep(220, 0.06, "square", 0.18);
        this.beep(120, 0.08, "triangle", 0.12);
      });
    }

    async playCoin() {
      if (!this.sfxOn || this.muted) return;
      await this._safePlay("coin", () => {
        this.beep(880, 0.05, "triangle", 0.12);
        this.beep(1320, 0.06, "sine", 0.10);
      });
    }
  }

  const audio = new AudioMan();

  const unlockOnce = async () => {
    await audio.unlock();
    await audio.startBgm();
    window.removeEventListener("pointerdown", unlockOnce);
    window.removeEventListener("keydown", unlockOnce);
  };
  window.addEventListener("pointerdown", unlockOnce, { passive: true });
  window.addEventListener("keydown", unlockOnce, { passive: true });

  // -------------------- Input --------------------
  const keys = new Set();
  const pressed = { jump:false, atk:false, skill:false, menu:false, inv:false, potion:false };

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    keys.add(k);

    if (k === " " || k === "arrowup") pressed.jump = true;
    if (k === "z") pressed.atk = true;
    if (k === "x") pressed.skill = true;
    if (k === "escape" || k === "p") pressed.menu = true;
    if (k === "i") pressed.inv = true;
    if (k === "h") pressed.potion = true;
  }, { passive:false });

  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()), { passive:true });

  const touch = document.getElementById("touch");
  const touchDown = new Set();
  function setTouchKey(name, down) {
    if (down) touchDown.add(name);
    else touchDown.delete(name);
  }
  if (touch) {
    touch.addEventListener("pointerdown", (e) => {
      const t = e.target;
      if (!(t instanceof HTMLElement)) return;
      const k = t.getAttribute("data-k");
      if (!k) return;
      e.preventDefault();
      t.setPointerCapture(e.pointerId);
      setTouchKey(k, true);
      if (k === "jump") pressed.jump = true;
      if (k === "atk") pressed.atk = true;
      if (k === "skill") pressed.skill = true;
      if (k === "menu") pressed.menu = true;
      if (k === "potion") pressed.potion = true;
    }, { passive:false });

    touch.addEventListener("pointerup", (e) => {
      const t = e.target;
      if (!(t instanceof HTMLElement)) return;
      const k = t.getAttribute("data-k");
      if (!k) return;
      e.preventDefault();
      setTouchKey(k, false);
    }, { passive:false });

    touch.addEventListener("pointercancel", () => touchDown.clear(), { passive:true });
  }

  function moveAxis() {
    let x = 0;
    if (keys.has("arrowleft") || keys.has("a")) x -= 1;
    if (keys.has("arrowright") || keys.has("d")) x += 1;
    if (touchDown.has("left")) x -= 1;
    if (touchDown.has("right")) x += 1;
    return clamp(x, -1, 1);
  }
  function wantAttack() { return pressed.atk || keys.has("z") || touchDown.has("atk"); }
  function wantSkill() { return pressed.skill || keys.has("x") || touchDown.has("skill"); }

  // -------------------- Pointer --------------------
  let pointer = { x:0, y:0, down:false, clicked:false, wheelY:0 };
  function toLogicalXY(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const lx = (clientX - rect.left) / rect.width * VIEW_W;
    const ly = (clientY - rect.top) / rect.height * VIEW_H;
    return { x: lx, y: ly };
  }
  canvas.addEventListener("pointerdown", (e) => {
    const p = toLogicalXY(e.clientX, e.clientY);
    pointer.x = p.x; pointer.y = p.y;
    pointer.down = true;
    pointer.clicked = true;
  }, { passive:true });
  canvas.addEventListener("pointerup", () => { pointer.down = false; }, { passive:true });
  canvas.addEventListener("pointermove", (e) => {
    const p = toLogicalXY(e.clientX, e.clientY);
    pointer.x = p.x; pointer.y = p.y;
  }, { passive:true });
  canvas.addEventListener("wheel", (e) => {
    e.preventDefault();
    pointer.wheelY += e.deltaY;
  }, { passive:false });

  function hitBtn(x,y,w,h){
    return pointer.clicked && pointer.x>=x && pointer.x<=x+w && pointer.y>=y && pointer.y<=y+h;
  }

  // -------------------- Assets --------------------
  function loadImage(src) {
    const img = new Image();
    const obj = { img, ok: false };
    img.onload = () => obj.ok = true;
    img.onerror = () => obj.ok = false;
    img.src = src;
    return obj;
  }
  const IMG = {
    player: loadImage("./assets/player_sheet.png"),
    slime:  loadImage("./assets/slime_sheet.png"),
    fxHit:  loadImage("./assets/fx_hit.png"),
    bg:     loadImage("./assets/bg.png"),
  };

  // -------------------- SpriteSheet --------------------
  class SpriteSheet {
    constructor(imageObj, fw, fh, animations) {
      this.imageObj = imageObj;
      this.fw = fw;
      this.fh = fh;
      this.anim = animations;
    }
    draw(name, x, y, t, scale=1, flip=false, alpha=1) {
      const { img, ok } = this.imageObj;
      const a = this.anim[name] || this.anim.idle;
      const frames = Math.max(1, a.frames);
      const idx = a.loop
        ? Math.floor(t * a.fps) % frames
        : Math.min(frames - 1, Math.floor(t * a.fps));
      const sx = idx * this.fw;
      const sy = a.row * this.fh;

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.translate(x, y);
      if (flip) ctx.scale(-1, 1);

      if (ok) {
        ctx.drawImage(img, sx, sy, this.fw, this.fh,
          -this.fw*scale/2, -this.fh*scale/2, this.fw*scale, this.fh*scale);
      } else {
        ctx.fillStyle = "rgba(91,140,255,0.95)";
        if (name === "hurt") ctx.fillStyle = "rgba(255,91,110,0.95)";
        if (name === "attack") ctx.fillStyle = "rgba(255,207,91,0.95)";
        ctx.fillRect(-22*scale, -26*scale, 44*scale, 52*scale);
        ctx.fillStyle = "rgba(235,240,255,0.85)";
        ctx.fillRect(6*scale, -6*scale, 10*scale, 6*scale);
      }
      ctx.restore();
    }
  }

  const playerSheet = new SpriteSheet(IMG.player, 64, 64, {
    idle:   { row:0, frames:6, fps:8,  loop:true  },
    run:    { row:1, frames:8, fps:12, loop:true  },
    jump:   { row:2, frames:4, fps:10, loop:false },
    attack: { row:3, frames:6, fps:16, loop:false },
    hurt:   { row:4, frames:4, fps:14, loop:false }
  });

  const slimeSheet = new SpriteSheet(IMG.slime, 64, 64, {
    idle:   { row:0, frames:6, fps:8,  loop:true  },
    run:    { row:1, frames:6, fps:10, loop:true  },
    hurt:   { row:2, frames:4, fps:14, loop:false },
    attack: { row:3, frames:6, fps:14, loop:false },
    die:    { row:4, frames:6, fps:12, loop:false }
  });

  // -------------------- FX --------------------
  class DamageText {
    constructor(x, y, text, color="rgba(235,240,255,0.92)") {
      this.x=x; this.y=y; this.vy=-50;
      this.text=text; this.t=0; this.life=0.8;
      this.color=color;
    }
    update(dt){ this.t+=dt; this.y += this.vy*dt; }
    draw(cam){
      const a = clamp(1 - this.t/this.life, 0, 1);
      ctx.globalAlpha = a;
      ctx.fillStyle = this.color;
      ctx.font = "bold 18px ui-monospace, Menlo, Consolas, monospace";
      ctx.fillText(this.text, this.x - cam.x, this.y - cam.y);
      ctx.globalAlpha = 1;
    }
    dead(){ return this.t >= this.life; }
  }

  class Particle {
    constructor(x,y,vx,vy,life, col){
      this.x=x; this.y=y; this.vx=vx; this.vy=vy;
      this.t=0; this.life=life; this.col=col;
    }
    update(dt){
      this.t+=dt;
      this.vy += 520*dt;
      this.x += this.vx*dt;
      this.y += this.vy*dt;
      this.vx *= Math.pow(0.12, dt);
      this.vy *= Math.pow(0.22, dt);
    }
    draw(cam){
      const a = clamp(1 - this.t/this.life, 0, 1);
      ctx.globalAlpha = a;
      ctx.fillStyle = this.col;
      ctx.fillRect(this.x - cam.x, this.y - cam.y, 3, 3);
      ctx.globalAlpha = 1;
    }
    dead(){ return this.t >= this.life; }
  }

  class HitSpark {
    constructor(x,y){
      this.x=x; this.y=y; this.t=0; this.life=0.22;
    }
    update(dt){ this.t += dt; }
    draw(cam){
      const a = clamp(1 - this.t/this.life, 0, 1);
      const px = this.x - cam.x, py = this.y - cam.y;
      ctx.save();
      ctx.globalAlpha = a;
      if (IMG.fxHit.ok) {
        const fw=64, fh=64, frames=6;
        const i = Math.min(frames-1, Math.floor((this.t/this.life)*frames));
        ctx.drawImage(IMG.fxHit.img, i*fw, 0, fw, fh, px-32, py-32, 64, 64);
      } else {
        ctx.strokeStyle = "rgba(255,235,120,0.95)";
        ctx.lineWidth = 3;
        const r = 10 + (1-a)*14;
        for(let i=0;i<8;i++){
          const ang = (Math.PI*2)*(i/8);
          ctx.beginPath();
          ctx.moveTo(px, py);
          ctx.lineTo(px + Math.cos(ang)*r, py + Math.sin(ang)*r);
          ctx.stroke();
        }
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.fillRect(px-2, py-2, 4, 4);
      }
      ctx.restore();
    }
    dead(){ return this.t >= this.life; }
  }

  // -------------------- World --------------------
  const WORLD = { w: 4200, h: 1200 };
  const GROUND_Y = 860;
  const GROUND_SCREEN_Y = VIEW_H - 80;
  const CAM_Y = Math.max(0, GROUND_Y - GROUND_SCREEN_Y);

  function stageLabel(i){
    const chap = Math.floor((i-1)/10)+1;
    const step = ((i-1)%10)+1;
    return `${chap}-${step}`;
  }
  function isBossStage(i){
    const step = ((i-1)%10)+1;
    return (step % 5 === 0);
  }

  function buildPlatforms(stageIndex){
    const plats = [];
    plats.push({ x: 0, y: GROUND_Y, w: WORLD.w, h: 80 });

    const seed = stageIndex * 1337;
    const rng = (n)=> {
      const s = Math.sin(seed + n*12.9898) * 43758.5453;
      return s - Math.floor(s);
    };

    for (let i=0;i<10;i++){
      const px = 420 + i*320 + randi(-40, 40);
      const py = GROUND_Y - 120 - Math.floor(rng(i)*220);
      plats.push({ x:px, y:py, w: 170 + randi(0, 60), h: 18 });
    }
    plats.push({ x: WORLD.w - 720, y: GROUND_Y - 160, w: 220, h: 18 });
    return plats;
  }

  // -------------------- Items --------------------
  const SLOTS = ["weapon","armor","ring"];
  const RAR = [
    {k:"N",  name:"ÏùºÎ∞ò", w:60, opt:0, mult:1.00},
    {k:"R",  name:"Ìù¨Í∑Ä", w:28, opt:1, mult:1.20},
    {k:"SR", name:"ÏòÅÏõÖ", w:10, opt:2, mult:1.45},
    {k:"SSR",name:"Ï†ÑÏÑ§", w: 2, opt:2, mult:1.85},
  ];
  const NAMES = {
    weapon:["ÎÇòÎ¨¥ Í≤Ä","Ï≤†Í≤Ä","ÌùëÏ≤†Í≤Ä","Î≤àÍ∞úÏùò Í≤Ä","Ï≤òÌòïÏûê ÎåÄÍ≤Ä"],
    armor:["Ìóå Ïò∑","Í∞ÄÏ£Ω Í∞ëÏò∑","ÏÇ¨Ïä¨ Í∞ëÏò∑","Í∞ïÏ≤† Í∞ëÏò∑","ÏàòÌò∏Ïùò ÌåêÍ∏à"],
    ring:["Îèô Î∞òÏßÄ","ÏùÄ Î∞òÏßÄ","ÏßëÏ§ëÏùò Î∞òÏßÄ","ÌååÍ¥¥Ïùò Î∞òÏßÄ","ÏôïÏùò Î∞òÏßÄ"]
  };
  const AFFIX = [
    {k:"atk", n:"Í≥µÍ≤©", min:1, max:7, w:22},
    {k:"def", n:"Î∞©Ïñ¥", min:1, max:6, w:22},
    {k:"hp",  n:"Ï≤¥Î†•", min:8, max:26, w:18},
    {k:"crit",n:"ÏπòÎ™Ö", min:1, max:7, w:10},
    {k:"spd", n:"Ïù¥ÏÜç", min:6, max:18, w:10},
    {k:"atkP",n:"Í≥µÍ≤©%",min:2, max:10,w:8},
    {k:"hpP", n:"Ï≤¥Î†•%",min:3, max:12,w:5},
    {k:"ls",  n:"Ìù°Ìòà", min:1, max:4, w:3},
  ];
  function wpick(list){
    const sum = list.reduce((s,x)=>s+x.w,0);
    let r = Math.random()*sum;
    for (const x of list){ r-=x.w; if (r<=0) return x; }
    return list[0];
  }
  function rollRarity(){
    const sum = RAR.reduce((s,x)=>s+x.w,0);
    let r = Math.random()*sum;
    for (const x of RAR){ r-=x.w; if (r<=0) return x; }
    return RAR[0];
  }
  function uuid(){
    if (crypto?.randomUUID) return crypto.randomUUID();
    return "id-"+Math.random().toString(16).slice(2)+Date.now().toString(16);
  }
  function rollAffixes(cnt){
    const used=new Set(); const out=[];
    let tries=0;
    while(out.length<cnt && tries<30){
      tries++;
      const a=wpick(AFFIX);
      if(used.has(a.k)) continue;
      used.add(a.k);
      out.push({k:a.k, n:a.n, v:randi(a.min,a.max)});
    }
    return out;
  }
  function makeItem(slot, level){
    const rar = rollRarity();
    const baseName = pick(NAMES[slot]);
    const ilvl = Math.max(1, level + randi(-1, 2));
    let atk=0,def=0,hp=0,crit=0,spd=0;
    if(slot==="weapon") atk = randi(3,7);
    if(slot==="armor"){ def=randi(2,6); hp=randi(10,22); }
    if(slot==="ring"){ crit=randi(1,4); atk=randi(1,3); spd=randi(0,6); }

    const mult = rar.mult * (1 + (ilvl-1)*0.04);
    const stats = {
      atk: Math.round(atk*mult),
      def: Math.round(def*mult),
      hp:  Math.round(hp*mult),
      crit:Math.round(crit*mult),
      spd: Math.round(spd*mult),
    };

    const identified = (rar.k==="N");
    const hidden = (rar.opt>0) ? rollAffixes(rar.opt) : [];

    return {
      id: uuid(),
      slot,
      name: baseName,
      rar: rar.k,
      rarName: rar.name,
      ilvl,
      enh: 0,
      identified,
      hidden,
      aff: [],
      stats,
      createdAt: isoNow()
    };
  }
  function appraise(it){
    if(it.identified) return false;
    it.identified=true;
    it.aff = it.hidden.slice();
    it.hidden = [];
    return true;
  }
  function itemPow(it){
    let p = it.stats.atk*2 + it.stats.def*2 + it.stats.hp*0.6 + it.stats.crit*1.4 + it.stats.spd*0.5 + it.ilvl*2 + it.enh*6;
    if(it.identified){
      for(const a of it.aff){
        if(a.k==="atk") p+=a.v*3;
        if(a.k==="def") p+=a.v*3;
        if(a.k==="hp")  p+=a.v*0.8;
        if(a.k==="crit")p+=a.v*2;
        if(a.k==="spd") p+=a.v*0.8;
        if(a.k==="atkP")p+=a.v*4;
        if(a.k==="hpP") p+=a.v*3;
        if(a.k==="ls")  p+=a.v*6;
      }
    }
    return Math.round(p);
  }
  function sellPrice(it){
    const rarMult = (it.rar==="SSR")?3.2:(it.rar==="SR")?2.2:(it.rar==="R")?1.5:1.0;
    const base = 18 + it.ilvl*8 + Math.floor(itemPow(it)*0.12);
    const idBonus = it.identified ? 1.15 : 0.95;
    return Math.max(5, Math.floor(base * rarMult * idBonus));
  }

  function aabb(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  // ---- Heal ----
  const POTION_MAX = 12;
  const POTION_HEAL_PCT = 0.35;
  const POTION_CD = 8.0;
  const REGEN_DELAY = 5.0;
  const REGEN_RATE = 0.02;

  // ---- Combat ----
  const ATTACK_LOCK_ATK = 0.18;
  const ATTACK_LOCK_SKL = 0.24;

  // ‚úÖ Ï†ëÏ¥â ÌîºÌï¥ Ïø®ÌÉÄÏûÑ(Ïó∞ÌÉÄ Ï§ëÏóêÎèÑ ÌîºÍ∞Ä ÍπéÏù¥Îêò Í≥ºÎèÑ Ïó∞ÌÉÄ Î∞©ÏßÄ)
  const CONTACT_DAMAGE_COOLDOWN = 0.22;

  // ---- Overlap stabilize ----
  const CONTACT_SEP_STRENGTH = 0.78;

  // ---- Drop ----
  const DROP_RATE_NORMAL = 0.07;
  const DROP_RATE_ELITE  = 0.18;
  const DROP_RATE_BOSS   = 0.60;
  const BOSS_DOUBLE_DROP_RATE = 0.22;

  function snapToGround(ent){
    const gy = GROUND_Y - ent.h/2;
    if (ent.y > gy) {
      ent.y = gy;
      ent.vy = 0;
      ent.onGround = true;
    }
  }

  class Player {
    constructor() {
      this.x = 220; this.y = 200;
      this.vx = 0; this.vy = 0;
      this.w = 42; this.h = 54;
      this.face = 1;
      this.onGround = false;

      this.hpBase = 120;
      this.atkBase = 14;
      this.defBase = 6;
      this.critBase = 6;
      this.spdBase = 230;

      this.hp = 120;
      this.atkCd = 0;
      this.skillCd = 0;

      this.inv = 0;     // ÌîºÍ≤© Î¨¥Ï†Å
      this.hitCd = 0;   // ‚úÖ Ï†ëÏ¥â ÌîºÌï¥ Ïø®ÌÉÄÏûÑ
      this.attackLock = 0;

      this.potions = 3;
      this.potionCd = 0;
      this.noHitT = 999;

      this.anim = "idle";
      this.animT = 0;

      this.gold = 120;
      this.stage = 1;
      this.kills = 0;

      this.invItems = [ makeItem("weapon",1), makeItem("armor",1), makeItem("ring",1) ];
      this.equip = { weapon:null, armor:null, ring:null };
      this.autoEquipBest();
    }
    derived() {
      let hpMax = this.hpBase;
      let atk = this.atkBase;
      let def = this.defBase;
      let crit = this.critBase;
      let spd = this.spdBase;
      let atkP=0, hpP=0, ls=0;

      for (const s of SLOTS) {
        const it = this.equip[s];
        if (!it) continue;
        atk += it.stats.atk;
        def += it.stats.def;
        hpMax += it.stats.hp;
        crit += it.stats.crit;
        spd += it.stats.spd;

        if (it.identified) {
          for (const a of it.aff) {
            if (a.k==="atk") atk += a.v;
            if (a.k==="def") def += a.v;
            if (a.k==="hp")  hpMax += a.v;
            if (a.k==="crit")crit += a.v;
            if (a.k==="spd") spd += a.v;
            if (a.k==="atkP")atkP += a.v;
            if (a.k==="hpP") hpP += a.v;
            if (a.k==="ls")  ls += a.v;
          }
        }
      }
      atk = Math.round(atk * (1 + atkP/100));
      hpMax = Math.round(hpMax * (1 + hpP/100));
      crit = clamp(crit, 0, 60);
      spd = clamp(spd, 160, 310);
      ls = clamp(ls, 0, 12);
      return { hpMax, atk, def, crit, spd, ls };
    }
    autoEquipBest() {
      for (const slot of SLOTS) {
        const current = this.equip[slot];
        const cand = this.invItems.filter(it => it.slot === slot);
        if (current) cand.push(current);
        if (!cand.length) continue;
        cand.sort((a,b)=>itemPow(b)-itemPow(a));
        const best = cand[0];
        if (current && best.id === current.id) continue;
        if (current) this.invItems.push(current);
        this.invItems = this.invItems.filter(it => it.id !== best.id);
        this.equip[slot] = best;
      }
      const d = this.derived();
      this.hp = clamp(this.hp, 1, d.hpMax);
    }
  }

  class Slime {
    constructor(x,y, tier, stageIndex) {
      this.x=x; this.y=y;
      this.vx=0; this.vy=0;
      this.w=44; this.h=42;
      this.face = -1;
      this.onGround=false;

      this.tier = tier;
      this.hpMax = 55 + stageIndex*18 + (tier==="elite"?80:0) + (tier==="boss"?420:0);
      this.hp = this.hpMax;
      this.atk = 10 + stageIndex*4 + (tier==="elite"?10:0) + (tier==="boss"?26:0);
      this.def = 2 + Math.floor(stageIndex/2) + (tier==="elite"?3:0) + (tier==="boss"?8:0);
      this.spd = (tier==="boss"?150:(tier==="elite"?190:170));

      this.hitCd=0;
      this.aiT=0;

      this.anim="idle";
      this.animT=0;
      this.dead=false;
      this.dieT=0;

      this.jumpCd = 0;

      // Î™¨Ïä§ÌÑ∞ y Ìäê Î∞©ÏßÄ
      this.groundSnap = true;
    }
  }

  class Coin { constructor(x,y,amount){ this.x=x; this.y=y; this.vx=rand(-40,40); this.vy=rand(-280,-120); this.r=8; this.amount=amount; this.t=0; } }
  class Loot { constructor(x,y,item){ this.x=x; this.y=y; this.vx=rand(-30,30); this.vy=rand(-240,-120); this.r=10; this.item=item; this.t=0; } }

  const cam = { x:0, y:CAM_Y };

  function roundRect(x, y, w, h, r, fill, stroke){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }
  function panel(x,y,w,h,title){
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(10,14,24,0.74)";
    roundRect(x,y,w,h,14,true,false);
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = 1;
    roundRect(x,y,w,h,14,false,true);

    ctx.globalAlpha = 1;
    ctx.fillStyle = "rgba(235,240,255,0.92)";
    ctx.font = "bold 18px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.fillText(title, x+16, y+30);
    ctx.restore();
  }
  function btn(x,y,w,h,text,hot=false){
    ctx.save();
    ctx.fillStyle = hot ? "rgba(91,140,255,0.22)" : "rgba(255,255,255,0.07)";
    ctx.strokeStyle = hot ? "rgba(91,140,255,0.50)" : "rgba(255,255,255,0.14)";
    ctx.lineWidth = 1;
    roundRect(x,y,w,h,12,true,true);
    ctx.fillStyle = "rgba(235,240,255,0.92)";
    ctx.font = "bold 16px system-ui, -apple-system, Segoe UI";
    const tw = ctx.measureText(text).width;
    ctx.fillText(text, x + (w-tw)/2, y + h/2 + 6);
    ctx.restore();
  }
  function badge(x,y,text, col="rgba(91,140,255,0.22)", stroke="rgba(91,140,255,0.50)"){
    ctx.save();
    ctx.fillStyle = col;
    ctx.strokeStyle = stroke;
    roundRect(x,y,64,22,10,true,true);
    ctx.fillStyle = "rgba(235,240,255,0.92)";
    ctx.font = "bold 12px ui-monospace, Menlo, Consolas";
    ctx.fillText(text, x+12, y+16);
    ctx.restore();
  }

  // HUD Î≤ÑÌäº(‚öô + üß™ + üéí)
  const HUD_MENU_BTN   = { x: 14+740+10, y: 14,        w: 46, h: 46 };
  const HUD_POTION_BTN = { x: 14+740+10, y: 14+46+8,   w: 46, h: 46 };
  const HUD_INV_BTN    = { x: 14+740+10, y: 14+46+8+46+8, w: 46, h: 46 };

  function drawIconBtn(x,y,w,h,label,hot=false){
    ctx.save();
    ctx.fillStyle = hot ? "rgba(91,140,255,0.22)" : "rgba(255,255,255,0.07)";
    ctx.strokeStyle = hot ? "rgba(91,140,255,0.55)" : "rgba(255,255,255,0.14)";
    roundRect(x,y,w,h,12,true,true);

    ctx.fillStyle = "rgba(235,240,255,0.92)";
    ctx.font = "900 18px system-ui, -apple-system, Segoe UI";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(label, x + w/2, y + h/2 + 1);
    ctx.restore();
  }

  function freshState(){
    const p = new Player();
    return {
      ver: 10,
      game: "Î≥¥Ïä§Í≤åÏù¥Ìä∏ (BOSS GATE)",
      createdAt: isoNow(),
      updatedAt: isoNow(),

      gs: "MENU", // MENU / PLAY / PAUSE / OPTIONS / INV / EXIT
      opt: { muted:false, bgm:true, sfx:true },

      player: p,
      stageIndex: 1,
      inBossRoom: false,

      platforms: buildPlatforms(1),
      enemies: [],
      coins: [],
      loots: [],

      goalKills: 10,
      killed: 0,

      door: null,
      fx: [],
      dmgText: [],
      parts: [],

      msg: "Î≥¥Ïä§Î¨∏ÏùÑ Î∂ÄÏà¥Îùº. (ESC/P ÎòêÎäî ‚öô: Î©îÎâ¥, I/üéí: Ïù∏Î≤§, H/üß™: Ìè¨ÏÖò)",
      msgT: 2.2,

      t: 0,
      camX: 0,

      invSelId: null,
      invScroll: 0, // ‚úÖ Ïù∏Î≤§ Ïä§ÌÅ¨Î°§
    };
  }

  function applyOptions(state){
    audio.setMuted(!!state.opt.muted);
    audio.bgmOn = !!state.opt.bgm;
    audio.sfxOn = !!state.opt.sfx;
    if (!audio.bgmOn) audio.stopBgm();
    else audio.startBgm();
  }

  function rebuildStage(state){
    const si = state.stageIndex;
    state.platforms = buildPlatforms(si);
    state.enemies = [];
    state.coins = [];
    state.loots = [];
    state.fx = [];
    state.dmgText = [];
    state.parts = [];
    state.door = null;

    state.killed = 0;
    state.goalKills = isBossStage(si) ? 1 : clamp(8 + Math.floor(si*0.7), 8, 18);

    state.player.x = 220;
    state.player.y = GROUND_Y - 120;
    state.player.vx = 0; state.player.vy = 0;
    state.player.attackLock = 0;

    state.camX = 0;

    if (isBossStage(si)) {
      state.inBossRoom = true;
      const bx = WORLD.w - 760;
      state.enemies.push(new Slime(bx, GROUND_Y - 120, "boss", si));
      state.msg = `Î≥¥Ïä§Í≤åÏù¥Ìä∏ ${stageLabel(si)} ‚Äî Î≥¥Ïä§ Îì±Ïû•!`;
      state.msgT = 1.6;
    } else {
      state.inBossRoom = false;
      const n = state.goalKills;
      for (let i=0;i<n;i++){
        const ex = 700 + i*260 + randi(-80,80);
        state.enemies.push(new Slime(ex, GROUND_Y - 120, Math.random()<0.22 ? "elite":"normal", si));
      }
      state.msg = `Ïä§ÌÖåÏù¥ÏßÄ ${stageLabel(si)} ÏãúÏûë! (${state.goalKills}ÎßàÎ¶¨ Ï≤òÏπò)`;
      state.msgT = 1.8;
    }
  }

  function startNew(state){
    const fresh = freshState();
    fresh.opt = state.opt;
    Object.assign(state, fresh);
    rebuildStage(state);
    state.gs = "PLAY";
    save(state);
  }

  function rollCrit(crit){ return (Math.random()*100) < crit; }
  function damageCalc(atk, def, critChance, mult=1){
    const c = rollCrit(critChance);
    let dmg = Math.max(1, Math.round(atk*mult) - def);
    if (c) dmg = Math.round(dmg*1.65);
    return { dmg, crit:c };
  }

  function spawnHitFX(state, x, y){
    state.fx.push(new HitSpark(x,y));
    for (let i=0;i<14;i++){
      state.parts.push(new Particle(x,y, rand(-220,220), rand(-260, -40), rand(0.18, 0.35), "rgba(255,235,120,0.95)"));
    }
    audio.playHit();
  }

  function shouldDropItem(tier){
    if (tier === "boss")  return Math.random() < DROP_RATE_BOSS;
    if (tier === "elite") return Math.random() < DROP_RATE_ELITE;
    return Math.random() < DROP_RATE_NORMAL;
  }

  function dropRewards(state, e){
    const baseGold = 18 + state.stageIndex*10 + (e.tier==="elite"?40:0) + (e.tier==="boss"?380:0);
    state.coins.push(new Coin(e.x, e.y, baseGold));

    if (shouldDropItem(e.tier)) {
      state.loots.push(new Loot(e.x+rand(-10,10), e.y, makeItem(pick(SLOTS), Math.max(1, Math.floor(state.stageIndex/2)+1))));
      if (e.tier === "boss" && Math.random() < BOSS_DOUBLE_DROP_RATE) {
        state.loots.push(new Loot(e.x+rand(-14,14), e.y, makeItem(pick(SLOTS), Math.max(1, Math.floor(state.stageIndex/2)+2))));
      }
    }
  }

  function ensureDoor(state){
    if (state.door) return;
    const x = WORLD.w - 300;
    const y = GROUND_Y - 120;
    const w = 90, h = 120;
    state.door = { x, y, w, h, kind: state.inBossRoom ? "exit" : "next" };
    state.msg = state.inBossRoom ? "Ï∂úÍµ¨ Î≥¥Ïä§Î¨∏Ïù¥ Ïó¥Î†∏Îã§!" : "Îã§Ïùå Î≥¥Ïä§Î¨∏Ïù¥ Ïó¥Î†∏Îã§!";
    state.msgT = 1.4;
  }

  function stageClearReward(state){
    const p = state.player;
    const before = p.potions;

    const addPotion = state.inBossRoom ? 2 : 1;
    p.potions = clamp(p.potions + addPotion, 0, POTION_MAX);

    const bonusGold = state.inBossRoom ? (120 + state.stageIndex*18) : (40 + state.stageIndex*8);
    p.gold += bonusGold;

    const got = p.potions - before;
    state.msg = `ÌÅ¥Î¶¨Ïñ¥ Î≥¥ÏÉÅ: +${bonusGold}G ${got>0?`+Ìè¨ÏÖò${got}Í∞ú`:``}`.trim();
    state.msgT = 1.6;
  }

  function collidePlatforms(ent, plats){
    ent.onGround = false;

    ent.x += ent.vx;
    for (const p of plats){
      if (aabb(ent.x - ent.w/2, ent.y - ent.h/2, ent.w, ent.h, p.x, p.y, p.w, p.h)){
        if (ent.vx > 0) ent.x = p.x - (ent.w/2);
        else if (ent.vx < 0) ent.x = p.x + p.w + (ent.w/2);
        ent.vx = 0;
      }
    }

    ent.y += ent.vy;
    for (const p of plats){
      if (aabb(ent.x - ent.w/2, ent.y - ent.h/2, ent.w, ent.h, p.x, p.y, p.w, p.h)){
        if (ent.vy > 0) {
          ent.y = p.y - (ent.h/2);
          ent.vy = 0;
          ent.onGround = true;
        } else if (ent.vy < 0) {
          ent.y = p.y + p.h + (ent.h/2);
          ent.vy = 0;
        }
      }
    }

    ent.x = clamp(ent.x, 40, WORLD.w - 40);
    ent.y = clamp(ent.y, 40, WORLD.h - 40);
  }

  function drawBackground(){
    if (IMG.bg.ok) {
      const img = IMG.bg.img;
      const par = 0.35;
      const bx = - (cam.x * par) % img.width;
      for (let x = bx - img.width; x < VIEW_W + img.width; x += img.width) {
        ctx.drawImage(img, x, 0, img.width, Math.min(VIEW_H, img.height));
      }
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(0,0,VIEW_W,VIEW_H);
    } else {
      const g = ctx.createLinearGradient(0,0,0,VIEW_H);
      g.addColorStop(0, "#061021");
      g.addColorStop(1, "#070a14");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,VIEW_W,VIEW_H);
    }
  }

  function tryUsePotion(state){
    const p = state.player;
    const d = p.derived();

    if (p.potionCd > 0) {
      state.msg = `Ìè¨ÏÖò Ïø®ÌÉÄÏûÑ ${p.potionCd.toFixed(1)}s`;
      state.msgT = 0.9;
      return false;
    }
    if (p.potions <= 0) {
      state.msg = "Ìè¨ÏÖòÏù¥ ÏóÜÎã§!";
      state.msgT = 1.2;
      return false;
    }
    if (p.hp >= d.hpMax) {
      state.msg = "HPÍ∞Ä Ïù¥ÎØ∏ Í∞ÄÎìùÌïòÎã§.";
      state.msgT = 0.9;
      return false;
    }

    const heal = Math.max(1, Math.floor(d.hpMax * POTION_HEAL_PCT));
    const before = p.hp;
    p.hp = clamp(p.hp + heal, 0, d.hpMax);
    p.potions -= 1;
    p.potionCd = POTION_CD;

    audio.playCoin();
    state.dmgText.push(new DamageText(p.x, p.y - 72, `+${Math.floor(p.hp - before)}`, "rgba(46,229,157,0.95)"));
    state.msg = `Ìè¨ÏÖò ÏÇ¨Ïö©! (+${Math.floor(p.hp - before)} HP)`;
    state.msgT = 1.1;
    save(state);
    return true;
  }

  function applyRegen(state, dt){
    const p = state.player;
    const d = p.derived();
    if (p.hp <= 0) return;
    if (p.hp >= d.hpMax) return;

    if (p.noHitT >= REGEN_DELAY) {
      const heal = d.hpMax * REGEN_RATE * dt;
      p.hp = clamp(p.hp + heal, 0, d.hpMax);
    }
  }

  function applyLifesteal(state, dmg){
    const p = state.player;
    const d = p.derived();
    if (d.ls <= 0) return;
    if (dmg <= 0) return;
    if (p.hp <= 0) return;

    const heal = Math.floor(dmg * (d.ls/100));
    if (heal <= 0) return;
    const before = p.hp;
    p.hp = clamp(p.hp + heal, 0, d.hpMax);
    const got = Math.floor(p.hp - before);
    if (got > 0) {
      state.dmgText.push(new DamageText(p.x, p.y - 86, `+${got}`, "rgba(46,229,157,0.90)"));
    }
  }

  function stabilizeOverlapNoBounce(state, p, e){
    const dx = (p.x - e.x);
    const overlapX = (p.w/2 + e.w/2) - Math.abs(dx);
    if (overlapX <= 0) return false;

    const dir = dx === 0 ? (p.face || 1) : Math.sign(dx);
    const push = overlapX * CONTACT_SEP_STRENGTH;

    p.x += dir * (push * 0.35);
    e.x -= dir * (push * 0.65);

    p.vx *= 0.10;
    e.vx *= 0.10;

    e.vy = 0;
    if (e.groundSnap) snapToGround(e);

    return true;
  }

  function drawPlatforms(plats){
    for (const p of plats) {
      const x = p.x - cam.x;
      const y = p.y - cam.y;
      ctx.fillStyle = "rgba(255,255,255,0.08)";
      ctx.fillRect(x, y, p.w, p.h);
      ctx.fillStyle = "rgba(91,140,255,0.10)";
      ctx.fillRect(x, y, p.w, 3);
    }
  }
  function drawDoor(door){
    const x = door.x - cam.x;
    const y = door.y - cam.y;
    ctx.fillStyle = door.kind==="next" ? "rgba(91,140,255,0.20)" : "rgba(255,91,110,0.22)";
    roundRect(x, y, door.w, door.h, 10, true, false);
    ctx.strokeStyle = door.kind==="next" ? "rgba(91,140,255,0.55)" : "rgba(255,91,110,0.55)";
    ctx.lineWidth = 2;
    roundRect(x, y, door.w, door.h, 10, false, true);
    ctx.fillStyle = "rgba(235,240,255,0.92)";
    ctx.font = "bold 12px ui-monospace, Menlo, Consolas";
    ctx.fillText(door.kind==="next" ? "BOSS GATE" : "EXIT GATE", x+10, y+20);
    ctx.lineWidth = 1;
  }
  function drawCoins(coins){
    for (const c of coins) {
      const x = c.x - cam.x, y = c.y - cam.y;
      ctx.fillStyle = "rgba(255,207,91,0.92)";
      ctx.beginPath(); ctx.arc(x,y,c.r,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,0.35)";
      ctx.fillRect(x-2,y-5,3,3);
    }
  }
  function drawLoot(loots){
    for (const l of loots) {
      const x = l.x - cam.x, y = l.y - cam.y;
      ctx.fillStyle = "rgba(91,140,255,0.92)";
      ctx.beginPath(); ctx.arc(x,y,l.r,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = "rgba(235,240,255,0.60)";
      ctx.fillRect(x-3,y-3,6,6);
    }
  }

  function drawHud(state){
    const p = state.player;
    const d = p.derived();

    ctx.globalAlpha = 0.90;
    ctx.fillStyle = "rgba(10,14,24,0.70)";
    roundRect(14, 14, 740, 110, 14, true, false);
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    roundRect(14, 14, 740, 110, 14, false, true);
    ctx.globalAlpha = 1;

    const hpPct = clamp(p.hp / d.hpMax, 0, 1);
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.fillRect(30, 34, 300, 14);
    ctx.fillStyle = "rgba(46,229,157,0.85)";
    ctx.fillRect(30, 34, 300*hpPct, 14);

    const sc = clamp(p.skillCd / 2.8, 0, 1);
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    ctx.fillRect(30, 54, 300, 10);
    ctx.fillStyle = "rgba(91,140,255,0.75)";
    ctx.fillRect(30, 54, 300*(1-sc), 10);

    const pc = clamp(p.potionCd / POTION_CD, 0, 1);
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    ctx.fillRect(30, 70, 300, 10);
    ctx.fillStyle = "rgba(255,207,91,0.75)";
    ctx.fillRect(30, 70, 300*(1-pc), 10);

    ctx.fillStyle = "rgba(235,240,255,0.92)";
    ctx.font = "bold 12px ui-monospace, Menlo, Consolas";
    ctx.fillText(`BOSS GATE | STAGE ${stageLabel(state.stageIndex)} ${state.inBossRoom ? "(BOSS)" : ""} | KILL ${state.killed}/${state.goalKills}`, 350, 38);
    ctx.fillText(`HP ${Math.floor(p.hp)}/${d.hpMax}  ATK ${d.atk} DEF ${d.def} CRIT ${d.crit}%  SPD ${d.spd}  LS ${d.ls}%`, 350, 56);
    ctx.fillText(`GOLD ${p.gold}G | Ìè¨ÏÖò ${p.potions}/${POTION_MAX} (H/üß™) | Ï†ëÏ¥âÏø® ${p.hitCd.toFixed(2)}s`, 350, 74);
    ctx.fillText(`‚öô:Î©îÎâ¥  üéí/I:Ïù∏Î≤§  Z:Í≥µÍ≤©  X:Ïä§ÌÇ¨  Space:Ï†êÌîÑ  H:Ìè¨ÏÖò`, 350, 92);

    const hotGear = (pointer.x>=HUD_MENU_BTN.x && pointer.x<=HUD_MENU_BTN.x+HUD_MENU_BTN.w &&
                     pointer.y>=HUD_MENU_BTN.y && pointer.y<=HUD_MENU_BTN.y+HUD_MENU_BTN.h);
    drawIconBtn(HUD_MENU_BTN.x, HUD_MENU_BTN.y, HUD_MENU_BTN.w, HUD_MENU_BTN.h, "‚öô", hotGear);

    const hotPot = (pointer.x>=HUD_POTION_BTN.x && pointer.x<=HUD_POTION_BTN.x+HUD_POTION_BTN.w &&
                    pointer.y>=HUD_POTION_BTN.y && pointer.y<=HUD_POTION_BTN.y+HUD_POTION_BTN.h);
    drawIconBtn(HUD_POTION_BTN.x, HUD_POTION_BTN.y, HUD_POTION_BTN.w, HUD_POTION_BTN.h, "üß™", hotPot);

    const hotInv = (pointer.x>=HUD_INV_BTN.x && pointer.x<=HUD_INV_BTN.x+HUD_INV_BTN.w &&
                    pointer.y>=HUD_INV_BTN.y && pointer.y<=HUD_INV_BTN.y+HUD_INV_BTN.h);
    drawIconBtn(HUD_INV_BTN.x, HUD_INV_BTN.y, HUD_INV_BTN.w, HUD_INV_BTN.h, "üéí", hotInv);

    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    roundRect(HUD_POTION_BTN.x+26, HUD_POTION_BTN.y+28, 20, 16, 8, true, false);
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.font = "bold 11px ui-monospace, Menlo, Consolas";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(String(p.potions), HUD_POTION_BTN.x+36, HUD_POTION_BTN.y+36);
    ctx.restore();

    if (state.msgT > 0 && state.msg) {
      ctx.globalAlpha = clamp(state.msgT/0.5, 0, 1);
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      roundRect(14, 130, 720, 36, 12, true, false);
      ctx.fillStyle = "rgba(235,240,255,0.92)";
      ctx.font = "bold 14px system-ui, -apple-system, Segoe UI";
      ctx.fillText(state.msg, 28, 154);
      ctx.globalAlpha = 1;
    }
  }

  function drawBossGateLogo(cx, cy, t){
    const flick = 0.6 + 0.4*Math.sin(t*2.6) + (Math.sin(t*17.0)*0.08);
    const glow = 12 + 10*(0.5+0.5*Math.sin(t*3.2));
    const shine = 0.35 + 0.65*(0.5+0.5*Math.sin(t*1.25));

    ctx.save();
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    ctx.font = "900 46px system-ui, -apple-system, Segoe UI";
    ctx.shadowColor = `rgba(91,140,255,${0.55*flick})`;
    ctx.shadowBlur = glow;
    ctx.fillStyle = `rgba(235,240,255,0.92)`;
    ctx.fillText("Î≥¥Ïä§Í≤åÏù¥Ìä∏", cx, cy-10);

    ctx.font = "800 16px ui-monospace, Menlo, Consolas";
    ctx.shadowColor = `rgba(255,235,120,${0.35*shine})`;
    ctx.shadowBlur = 10;
    ctx.fillStyle = `rgba(255,235,120,0.85)`;
    ctx.fillText("BOSS GATE", cx, cy+26);

    const w = 520, h = 64;
    const x0 = cx - w/2, y0 = cy - 42;
    const sweepX = x0 + (t*220 % (w+160)) - 80;
    const grad = ctx.createLinearGradient(sweepX, 0, sweepX+120, 0);
    grad.addColorStop(0, "rgba(255,255,255,0)");
    grad.addColorStop(0.5, `rgba(255,255,255,${0.25*shine})`);
    grad.addColorStop(1, "rgba(255,255,255,0)");

    ctx.globalAlpha = 1;
    ctx.fillStyle = grad;
    roundRect(x0, y0, w, h, 12, true, false);

    ctx.restore();
  }

  function drawMenu(state){
    drawBackground();
    const px = VIEW_W*0.5-260, py = VIEW_H*0.5-190;
    panel(px, py, 520, 380, " ");
    drawBossGateLogo(VIEW_W*0.5, VIEW_H*0.5-110, state.t);

    ctx.fillStyle = "rgba(235,240,255,0.75)";
    ctx.font = "14px system-ui, -apple-system, Segoe UI";
    ctx.textAlign = "center";
    ctx.fillText("Ïä§ÌÖåÏù¥ÏßÄÎ•º Îö´Í≥†, Î≥¥Ïä§Î¨∏ÏùÑ Î∂ÄÏà¥Îùº.", VIEW_W*0.5, VIEW_H*0.5-62);
    ctx.textAlign = "left";

    const bx = VIEW_W*0.5-180, by = VIEW_H*0.5-30, bw=360, bh=52;
    const hasSave = !!load();

    btn(bx, by, bw, bh, "ÏÉà Í≤åÏûÑ ÏãúÏûë", true);
    btn(bx, by+64, bw, bh, hasSave ? "Ïù¥Ïñ¥ÌïòÍ∏∞" : "Ïù¥Ïñ¥ÌïòÍ∏∞(Ï†ÄÏû• ÏóÜÏùå)", hasSave);
    btn(bx, by+128, bw, bh, "ÏòµÏÖò");
    btn(bx, by+192, bw, bh, "Ï†ÄÏû• ÏÇ≠Ï†ú", false);

    if (hitBtn(bx,by,bw,bh)) startNew(state);

    if (hasSave && hitBtn(bx,by+64,bw,bh)) {
      const s = load();
      if (s) {
        const restored = revive(s);
        Object.assign(state, restored);
        applyOptions(state);
        state.gs = "PLAY";
      }
    }

    if (hitBtn(bx,by+128,bw,bh)) state.gs = "OPTIONS";

    if (hitBtn(bx,by+192,bw,bh)) {
      localStorage.removeItem(SAVE_KEY);
      state.msg = "Ï†ÄÏû• ÏÇ≠Ï†ú ÏôÑÎ£å.";
      state.msgT = 1.5;
    }

    ctx.fillStyle = "rgba(235,240,255,0.55)";
    ctx.font = "12px ui-monospace, Menlo, Consolas";
    ctx.fillText("Î™®Î∞îÏùº: Î≤ÑÌäº/‚öô Î©îÎâ¥ / PC: Î∞©Ìñ•ÌÇ§ + Z/X + Space + H + I", VIEW_W*0.5-240, VIEW_H*0.5+210);
  }

  function drawOptions(state){
    drawBackground();
    panel(VIEW_W*0.5-260, VIEW_H*0.5-170, 520, 340, "ÏòµÏÖò");

    const bx = VIEW_W*0.5-200, by = VIEW_H*0.5-90, bw=400, bh=52;

    btn(bx, by, bw, bh, `ÏùåÏÜåÍ±∞: ${state.opt.muted ? "ON" : "OFF"}`, !state.opt.muted);
    btn(bx, by+64, bw, bh, `BGM: ${state.opt.bgm ? "ON" : "OFF"}`, state.opt.bgm);
    btn(bx, by+128, bw, bh, `SFX: ${state.opt.sfx ? "ON" : "OFF"}`, state.opt.sfx);
    btn(bx, by+212, bw, bh, "Îí§Î°úÍ∞ÄÍ∏∞", true);

    if (hitBtn(bx,by,bw,bh)) { state.opt.muted = !state.opt.muted; applyOptions(state); save(state); }
    if (hitBtn(bx,by+64,bw,bh)) { state.opt.bgm = !state.opt.bgm; applyOptions(state); save(state); }
    if (hitBtn(bx,by+128,bw,bh)) { state.opt.sfx = !state.opt.sfx; applyOptions(state); save(state); }
    if (hitBtn(bx,by+212,bw,bh)) { state.gs = "MENU"; }

    ctx.fillStyle = "rgba(235,240,255,0.65)";
    ctx.font = "13px system-ui, -apple-system, Segoe UI";
    ctx.fillText("Ïò§ÎîîÏò§Í∞Ä Ïïà ÎÇòÎ©¥ ÌôîÎ©¥ÏùÑ Ìïú Î≤à ÌÉ≠/ÌÅ¥Î¶≠Ìï¥ÏÑú Ïñ∏ÎùΩÌï¥Ï§ò.", VIEW_W*0.5-200, VIEW_H*0.5+70);
  }

  function drawScene(state, dim=false){
    drawBackground();
    drawPlatforms(state.platforms);
    if (state.door) drawDoor(state.door);
    drawCoins(state.coins);
    drawLoot(state.loots);

    for (const e of state.enemies) {
      const x = e.x - cam.x;
      const y = e.y - cam.y;
      const flip = (e.face === -1);
      const name = e.dead ? "die" : e.anim;
      const scale = (e.tier==="boss") ? 1.45 : (e.tier==="elite" ? 1.15 : 1.0);
      slimeSheet.draw(name, x, y-8, e.animT, scale, flip, e.hitCd>0 ? 0.75 : 1);

      if (!e.dead) {
        const pct = clamp(e.hp/e.hpMax, 0,1);
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.fillRect(x-34*scale, y-56*scale, 68*scale, 8);
        ctx.fillStyle = (e.tier==="boss") ? "rgba(255,91,110,0.85)" : "rgba(46,229,157,0.85)";
        ctx.fillRect(x-34*scale, y-56*scale, 68*scale*pct, 8);

        ctx.fillStyle = "rgba(235,240,255,0.75)";
        ctx.font = "10px ui-monospace, Menlo, Consolas";
        ctx.fillText(`${Math.floor(e.hp)}/${e.hpMax}`, x-30*scale, y-60*scale);
      }
    }

    const p = state.player;
    const px = p.x - cam.x;
    const py = p.y - cam.y;
    const flipP = (p.face === -1);
    playerSheet.draw(p.anim, px, py-10, p.animT, 1.15, flipP, p.inv>0 ? 0.65 : 1);

    for (const f of state.fx) f.draw(cam);
    for (const t of state.dmgText) t.draw(cam);
    for (const pa of state.parts) pa.draw(cam);

    if (dim) {
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.fillRect(0,0,VIEW_W,VIEW_H);
    }
    drawHud(state);
  }

  function hardExitNow(){
    try { window.close(); } catch {}
    try { location.replace("about:blank"); } catch { location.href = "about:blank"; }
  }

  function drawPause(state){
    drawScene(state, true);

    const px = VIEW_W*0.5-260;
    const py = 70;
    const pw = 520;
    const ph = 400;
    panel(px, py, pw, ph, "ÏùºÏãúÏ†ïÏßÄ / Î©îÎâ¥");

    const bx = VIEW_W*0.5-190;
    const by = py + 54;
    const bw = 380;
    const bh = 46;
    const gap = 10;

    const items = [
      { t:"Ïû¨Í∞ú", hot:true, fn:()=> state.gs="PLAY" },
      { t:"Ïù∏Î≤§ÌÜ†Î¶¨(üéí)", hot:false, fn:()=> state.gs="INV" },
      { t:"ÏòµÏÖò", hot:false, fn:()=> state.gs="OPTIONS" },
      { t:"Ï†ÄÏû• ÌõÑ ÌÉÄÏù¥ÌãÄÎ°ú", hot:false, fn:()=> { save(state); state.gs="MENU"; state.msg="Ï†ÄÏû• ÏôÑÎ£å. ÌÉÄÏù¥ÌãÄÎ°ú Ïù¥Îèô."; state.msgT=1.5; } },
      { t:"Í≤åÏûÑ Ï¢ÖÎ£å(ÏôÑÏ†Ñ ÌÉàÏ∂ú)", hot:true, fn:()=> { hardExitNow(); state.gs="EXIT"; } },
    ];

    for (let i=0;i<items.length;i++){
      const y = by + i*(bh+gap);
      btn(bx, y, bw, bh, items[i].t, items[i].hot);
      if (hitBtn(bx, y, bw, bh)) items[i].fn();
    }

    if (pressed.menu) { pressed.menu = false; state.gs = "PLAY"; }
    if (pressed.inv) { pressed.inv = false; state.gs = "INV"; }
  }

  function drawExitScreen(){
    ctx.fillStyle = "#050812";
    ctx.fillRect(0,0,VIEW_W,VIEW_H);
    ctx.fillStyle = "rgba(235,240,255,0.92)";
    ctx.font = "900 28px system-ui, -apple-system, Segoe UI";
    ctx.textAlign = "center";
    ctx.fillText("Í≤åÏûÑ Ï¢ÖÎ£å", VIEW_W/2, VIEW_H/2 - 10);
    ctx.font = "14px system-ui, -apple-system, Segoe UI";
    ctx.fillStyle = "rgba(235,240,255,0.70)";
    ctx.fillText("Î∏åÎùºÏö∞Ï†ÄÍ∞Ä ÌÉ≠ Îã´Í∏∞Î•º ÎßâÏúºÎ©¥ Îπà ÌôîÎ©¥ÏúºÎ°ú Ïù¥ÎèôÌï©ÎãàÎã§.", VIEW_W/2, VIEW_H/2 + 24);
    ctx.textAlign = "left";
  }

  // -------------------- INVENTORY (Î≥µÍµ¨) --------------------
  function rarColor(r){
    if (r==="SSR") return ["rgba(255,207,91,0.22)","rgba(255,207,91,0.55)"];
    if (r==="SR")  return ["rgba(174,120,255,0.22)","rgba(174,120,255,0.55)"];
    if (r==="R")   return ["rgba(91,140,255,0.22)","rgba(91,140,255,0.55)"];
    return ["rgba(255,255,255,0.10)","rgba(255,255,255,0.18)"];
  }

  function sortInv(items){
    const order = { "SSR":0, "SR":1, "R":2, "N":3 };
    items.sort((a,b)=>{
      const oa = order[a.rar] ?? 9, ob = order[b.rar] ?? 9;
      if (oa !== ob) return oa - ob;
      const pa = itemPow(a), pb = itemPow(b);
      if (pa !== pb) return pb - pa;
      return (b.ilvl - a.ilvl);
    });
  }

  function drawInventory(state){
    drawScene(state, true);

    const p = state.player;

    const px = 80, py = 50, pw = 800, ph = 440;
    panel(px, py, pw, ph, "Ïù∏Î≤§ÌÜ†Î¶¨");

    // ÏÉÅÎã® Ïû•Ï∞©
    const ex = px+20, ey = py+48;
    ctx.fillStyle = "rgba(235,240,255,0.80)";
    ctx.font = "bold 13px ui-monospace, Menlo, Consolas";
    ctx.fillText("Ïû•Ï∞©:", ex, ey);

    const slotBoxes = [
      {slot:"weapon", x:ex+60, y:ey-18},
      {slot:"armor",  x:ex+240, y:ey-18},
      {slot:"ring",   x:ex+420, y:ey-18},
    ];
    for (const sb of slotBoxes){
      const it = p.equip[sb.slot];
      const [fc, sc] = it ? rarColor(it.rar) : ["rgba(255,255,255,0.07)","rgba(255,255,255,0.14)"];
      ctx.fillStyle = fc; ctx.strokeStyle = sc;
      roundRect(sb.x, sb.y, 160, 34, 10, true, true);
      ctx.fillStyle = "rgba(235,240,255,0.92)";
      ctx.font = "bold 12px system-ui, -apple-system, Segoe UI";
      const label = it ? `[${it.rar}] ${it.name}${it.identified?"":"(ÎØ∏Í∞êÏ†ï)"}` : "(ÎπÑÏñ¥ÏûàÏùå)";
      ctx.fillText(label, sb.x+10, sb.y+22);
      ctx.fillStyle = "rgba(235,240,255,0.55)";
      ctx.font = "11px ui-monospace, Menlo, Consolas";
      ctx.fillText(sb.slot.toUpperCase(), sb.x+118, sb.y+22);

      // Ïû•Ï∞© Ìï¥Ï†ú Î≤ÑÌäº(ÌÅ¥Î¶≠ÌïòÎ©¥ Ïù∏Î≤§ÏúºÎ°ú)
      const ux = sb.x+128, uy = sb.y+7;
      if (it) {
        ctx.fillStyle = "rgba(255,91,110,0.14)";
        ctx.strokeStyle = "rgba(255,91,110,0.40)";
        roundRect(ux, uy, 24, 20, 8, true, true);
        ctx.fillStyle = "rgba(235,240,255,0.92)";
        ctx.font = "900 12px system-ui";
        ctx.fillText("X", ux+8, uy+14);
        if (hitBtn(ux,uy,24,20)) {
          p.invItems.push(it);
          p.equip[sb.slot] = null;
          state.msg = "Ïû•Ï∞© Ìï¥Ï†ú!";
          state.msgT = 1.0;
          save(state);
        }
      }
    }

    // Ïö∞Ï∏° ÏÉÅÎã® Î≤ÑÌäºÎì§
    const bx = px+pw-20-160, by = py+48, bw=160, bh=34;
    btn(bx, by, bw, bh, "ÏûêÎèôÏû•Ï∞©", true);
    btn(bx, by+40, bw, bh, "Ï†ïÎ†¨", false);
    btn(bx, by+80, bw, bh, "ÏùºÎ∞òÌÖú ÏùºÍ¥ÑÌåêÎß§", false);
    btn(bx, by+120, bw, bh, "Îã´Í∏∞(ESC/I)", true);

    if (hitBtn(bx,by,bw,bh)) { p.autoEquipBest(); state.msg="ÏûêÎèôÏû•Ï∞© ÏôÑÎ£å"; state.msgT=1.0; save(state); }
    if (hitBtn(bx,by+40,bw,bh)) { sortInv(p.invItems); state.msg="Ï†ïÎ†¨ ÏôÑÎ£å"; state.msgT=1.0; save(state); }
    if (hitBtn(bx,by+80,bw,bh)) {
      let gain=0, sold=0;
      const keep=[];
      for(const it of p.invItems){
        if(it.rar==="N"){ gain += sellPrice(it); sold++; }
        else keep.push(it);
      }
      p.invItems = keep;
      p.gold += gain;
      if (sold>0) audio.playCoin();
      state.msg = sold>0 ? `ÏùºÎ∞òÌÖú ${sold}Í∞ú ÌåêÎß§ (+${gain}G)` : "ÌåêÎß§Ìï† ÏùºÎ∞òÌÖúÏù¥ ÏóÜÏùå";
      state.msgT = 1.2;
      save(state);
    }
    if (hitBtn(bx,by+120,bw,bh)) { state.gs="PLAY"; save(state); }

    // Î¶¨Ïä§Ìä∏ ÏòÅÏó≠
    const listX = px+20;
    const listY = py+100;
    const listW = 520;
    const listH = ph-120;
    ctx.fillStyle = "rgba(0,0,0,0.20)";
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    roundRect(listX, listY, listW, listH, 12, true, true);

    // Ïä§ÌÅ¨Î°§ Ï≤òÎ¶¨(ÎßàÏö∞Ïä§ Ìú†)
    if (Math.abs(pointer.wheelY) > 0.1) {
      const over = (pointer.x>=listX && pointer.x<=listX+listW && pointer.y>=listY && pointer.y<=listY+listH);
      if (over){
        state.invScroll += pointer.wheelY * 0.35;
        pointer.wheelY = 0;
      }
    }

    const rowH = 48;
    const maxScroll = Math.max(0, p.invItems.length * rowH - (listH-12));
    state.invScroll = clamp(state.invScroll, 0, maxScroll);

    // ÏÑ†ÌÉù ÏïÑÏù¥ÌÖú Ï∞æÍ∏∞
    let sel = null;
    if (state.invSelId) sel = p.invItems.find(it=>it.id===state.invSelId) || null;

    // Î¶¨Ïä§Ìä∏ Í∑∏Î¶¨Í∏∞
    ctx.save();
    ctx.beginPath();
    ctx.rect(listX+6, listY+6, listW-12, listH-12);
    ctx.clip();

    const startIdx = Math.floor(state.invScroll/rowH);
    const endIdx = Math.min(p.invItems.length, startIdx + Math.ceil((listH/rowH)+2));
    let y0 = listY+10 - (state.invScroll % rowH);

    for(let i=startIdx;i<endIdx;i++){
      const it = p.invItems[i];
      const isSel = (sel && sel.id===it.id);
      const ry = y0 + (i-startIdx)*rowH;

      const [fc, sc] = rarColor(it.rar);
      ctx.fillStyle = isSel ? "rgba(91,140,255,0.20)" : "rgba(255,255,255,0.05)";
      ctx.strokeStyle = isSel ? "rgba(91,140,255,0.55)" : "rgba(255,255,255,0.10)";
      roundRect(listX+10, ry, listW-20, rowH-8, 10, true, true);

      // rarity badge
      ctx.fillStyle = fc; ctx.strokeStyle = sc;
      roundRect(listX+18, ry+10, 56, 22, 10, true, true);
      ctx.fillStyle = "rgba(235,240,255,0.92)";
      ctx.font = "bold 12px ui-monospace, Menlo, Consolas";
      ctx.fillText(it.rar, listX+36, ry+26);

      // text
      ctx.fillStyle = "rgba(235,240,255,0.92)";
      ctx.font = "bold 13px system-ui, -apple-system, Segoe UI";
      ctx.fillText(`${it.name}${it.identified?"":" (ÎØ∏Í∞êÏ†ï)"}`, listX+80, ry+26);

      ctx.fillStyle = "rgba(235,240,255,0.65)";
      ctx.font = "12px ui-monospace, Menlo, Consolas";
      ctx.fillText(`${it.slot.toUpperCase()}  iLv ${it.ilvl}  PWR ${itemPow(it)}  ÌåêÎß§ ${sellPrice(it)}G`, listX+80, ry+42);

      // ÌÅ¥Î¶≠ ÏÑ†ÌÉù
      const rx = listX+10, rw = listW-20, rh = rowH-8;
      if (hitBtn(rx, ry, rw, rh)){
        state.invSelId = it.id;
        sel = it;
        save(state);
      }
    }

    ctx.restore();

    // Ïö∞Ï∏° ÏÉÅÏÑ∏
    const detailX = px+560;
    const detailY = py+210;
    const detailW = 300;
    const detailH = 260;
    ctx.fillStyle = "rgba(0,0,0,0.20)";
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    roundRect(detailX, detailY, detailW, detailH, 12, true, true);

    ctx.fillStyle = "rgba(235,240,255,0.85)";
    ctx.font = "bold 13px system-ui, -apple-system, Segoe UI";
    ctx.fillText("ÏÑ†ÌÉù ÏïÑÏù¥ÌÖú", detailX+12, detailY+22);

    if (!sel) {
      ctx.fillStyle = "rgba(235,240,255,0.55)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI";
      ctx.fillText("ÏôºÏ™ΩÏóêÏÑú ÏïÑÏù¥ÌÖúÏùÑ ÏÑ†ÌÉùÌï¥.", detailX+12, detailY+46);
    } else {
      const [fc, sc] = rarColor(sel.rar);
      ctx.fillStyle = fc; ctx.strokeStyle = sc;
      roundRect(detailX+12, detailY+34, 66, 22, 10, true, true);
      ctx.fillStyle = "rgba(235,240,255,0.92)";
      ctx.font = "bold 12px ui-monospace, Menlo, Consolas";
      ctx.fillText(sel.rar, detailX+34, detailY+50);

      ctx.fillStyle = "rgba(235,240,255,0.92)";
      ctx.font = "bold 14px system-ui, -apple-system, Segoe UI";
      ctx.fillText(`${sel.name}${sel.identified?"":" (ÎØ∏Í∞êÏ†ï)"}`, detailX+86, detailY+50);

      ctx.fillStyle = "rgba(235,240,255,0.70)";
      ctx.font = "12px ui-monospace, Menlo, Consolas";
      ctx.fillText(`${sel.slot.toUpperCase()} | iLv ${sel.ilvl} | PWR ${itemPow(sel)}`, detailX+12, detailY+78);

      // base stats
      const st = sel.stats;
      ctx.fillText(`Í∏∞Î≥∏: ATK ${st.atk}  DEF ${st.def}  HP ${st.hp}  CRIT ${st.crit}  SPD ${st.spd}`, detailX+12, detailY+100);

      // affixes
      let yy = detailY+122;
      ctx.fillText(sel.identified ? "ÏòµÏÖò:" : "ÏòµÏÖò: (Í∞êÏ†ï ÌïÑÏöî)", detailX+12, yy);
      yy += 18;

      if (sel.identified) {
        if (!sel.aff || sel.aff.length===0) {
          ctx.fillText("-", detailX+12, yy);
          yy += 16;
        } else {
          for (const a of sel.aff) {
            ctx.fillText(`${a.n} +${a.v}`, detailX+12, yy);
            yy += 16;
          }
        }
      } else {
        ctx.fillText(`Ïà®ÍπÄ ÏòµÏÖò ${sel.hidden?.length||0}Í∞ú`, detailX+12, yy);
        yy += 16;
      }

      // buttons
      const b1x = detailX+12, b1y = detailY+detailH-110, bW=detailW-24, bH=34;
      btn(b1x, b1y, bW, bH, "Ïû•Ï∞©", true);
      btn(b1x, b1y+40, bW, bH, sel.identified ? "Í∞êÏ†ï ÏôÑÎ£å" : `Í∞êÏ†ïÌïòÍ∏∞ (${Math.max(20, Math.floor(sellPrice(sel)*0.35))}G)`, !sel.identified);
      btn(b1x, b1y+80, bW, bH, `ÌåêÎß§ (+${sellPrice(sel)}G)`, false);

      if (hitBtn(b1x,b1y,bW,bH)) {
        const slot = sel.slot;
        // ÌòÑÏû¨ Ïû•Ï∞©ÏùÄ Ïù∏Î≤§ÏúºÎ°ú ÎèåÎ¶¨Í≥†, ÏÑ†ÌÉùÏùÑ Ïû•Ï∞©
        if (p.equip[slot]) p.invItems.push(p.equip[slot]);
        p.equip[slot] = sel;
        p.invItems = p.invItems.filter(it=>it.id!==sel.id);
        state.invSelId = null;
        p.autoEquipBest(); // ÌååÏÉùÏπò/HP ÌÅ¥Îû®ÌîÑ
        state.msg = "Ïû•Ï∞© ÏôÑÎ£å!";
        state.msgT = 1.0;
        save(state);
      }

      if (!sel.identified && hitBtn(b1x,b1y+40,bW,bH)) {
        const cost = Math.max(20, Math.floor(sellPrice(sel)*0.35));
        if (p.gold < cost) {
          state.msg = "Í≥®ÎìúÍ∞Ä Î∂ÄÏ°±ÌïòÎã§!";
          state.msgT = 1.0;
        } else {
          p.gold -= cost;
          appraise(sel);
          state.msg = "Í∞êÏ†ï ÏôÑÎ£å! ÏòµÏÖò Ìï¥Î∞©!";
          state.msgT = 1.2;
          audio.playCoin();
          save(state);
        }
      }

      if (hitBtn(b1x,b1y+80,bW,bH)) {
        const gain = sellPrice(sel);
        p.gold += gain;
        p.invItems = p.invItems.filter(it=>it.id!==sel.id);
        state.invSelId = null;
        state.msg = `ÌåêÎß§ ÏôÑÎ£å (+${gain}G)`;
        state.msgT = 1.1;
        audio.playCoin();
        save(state);
      }
    }

    // ÌïòÎã® ÏïàÎÇ¥
    ctx.fillStyle = "rgba(235,240,255,0.60)";
    ctx.font = "12px ui-monospace, Menlo, Consolas";
    ctx.fillText("Ìú† Ïä§ÌÅ¨Î°§: Î™©Î°ù Ïù¥Îèô | I/ESC: Îã´Í∏∞ | üéí Î≤ÑÌäº: Ïù∏Î≤§", px+20, py+ph-18);

    // ÌÇ§Î°ú Îã´Í∏∞
    if (pressed.inv || pressed.menu) {
      pressed.inv = false;
      pressed.menu = false;
      state.gs = "PLAY";
      save(state);
    }
  }

  function updatePlay(state, dt){
    const p = state.player;
    const d = p.derived();

    p.atkCd = Math.max(0, p.atkCd - dt);
    p.skillCd = Math.max(0, p.skillCd - dt);

    p.inv = Math.max(0, p.inv - dt);

    // ‚úÖ Ï†ëÏ¥â ÌîºÌï¥ Ïø®ÌÉÄÏûÑ Í∞êÏÜå
    p.hitCd = Math.max(0, p.hitCd - dt);

    p.attackLock = Math.max(0, p.attackLock - dt);

    p.potionCd = Math.max(0, p.potionCd - dt);
    p.noHitT += dt;

    applyRegen(state, dt);

    const ax = moveAxis();

    if (p.attackLock > 0 && p.onGround) p.vx = 0;
    else p.vx = ax * d.spd * dt;

    if (ax !== 0) p.face = ax > 0 ? 1 : -1;

    if (pressed.jump && p.onGround) {
      p.vy = -520;
      p.onGround = false;
    }
    pressed.jump = false;

    if (pressed.potion) tryUsePotion(state);
    pressed.potion = false;

    p.vy += 1200 * dt;
    collidePlatforms(p, state.platforms);

    if (p.inv > 0) p.anim = "hurt";
    else if (!p.onGround) p.anim = "jump";
    else if (Math.abs(ax) > 0.05 && p.attackLock <= 0) p.anim = "run";
    else p.anim = "idle";

    p.animT += dt;
    if (p.anim !== state._prevAnimP) { p.animT = 0; state._prevAnimP = p.anim; }

    const doAtk = wantAttack();
    const doSkl = wantSkill();

    // Z Í≥µÍ≤©
    if (doAtk && p.atkCd <= 0) {
      p.atkCd = 0.30;
      p.anim = "attack"; p.animT = 0;
      p.attackLock = Math.max(p.attackLock, ATTACK_LOCK_ATK);

      const hx = p.x + p.face * 46;
      const hy = p.y - 10;
      const hw = 72, hh = 52;

      let hit = 0;
      for (const e of state.enemies) {
        if (e.dead) continue;
        if (aabb(hx - hw/2, hy - hh/2, hw, hh, e.x - e.w/2, e.y - e.h/2, e.w, e.h)) {
          const { dmg, crit } = damageCalc(d.atk, e.def, d.crit, 1.05);
          e.hp = clamp(e.hp - dmg, 0, e.hpMax);
          e.hitCd = 0.12;

          e.vy = 0;
          snapToGround(e);

          hit++;
          applyLifesteal(state, dmg);

          spawnHitFX(state, e.x, e.y - 14);
          state.dmgText.push(new DamageText(
            e.x, e.y - 64, `${crit ? "‚ú¶" : ""}${dmg}`,
            crit ? "rgba(255,235,120,0.95)" : "rgba(235,240,255,0.92)"
          ));

          if (e.hp <= 0) {
            e.dead = true; e.dieT = 0;
            dropRewards(state, e);
            state.killed++;
            p.kills++;
          }
        }
      }
      if (hit === 0) audio.playHit();
    }
    pressed.atk = false;

    // X Ïä§ÌÇ¨
    if (doSkl && p.skillCd <= 0) {
      p.skillCd = 2.8;
      p.atkCd = 0.42;
      p.anim = "attack"; p.animT = 0;
      p.attackLock = Math.max(p.attackLock, ATTACK_LOCK_SKL);

      const hx = p.x + p.face * 78;
      const hy = p.y - 12;
      const hw = 160, hh = 76;

      for (const e of state.enemies) {
        if (e.dead) continue;
        if (aabb(hx - hw/2, hy - hh/2, hw, hh, e.x - e.w/2, e.y - e.h/2, e.w, e.h)) {
          const { dmg, crit } = damageCalc(d.atk, e.def, d.crit, 1.85);
          e.hp = clamp(e.hp - dmg, 0, e.hpMax);
          e.hitCd = 0.16;

          e.vy = 0;
          snapToGround(e);

          applyLifesteal(state, dmg);

          spawnHitFX(state, e.x, e.y - 14);
          state.dmgText.push(new DamageText(
            e.x, e.y - 64, `${crit ? "‚ú¶" : ""}${dmg}`,
            "rgba(255,207,91,0.95)"
          ));

          if (e.hp <= 0) {
            e.dead = true; e.dieT = 0;
            dropRewards(state, e);
            state.killed++;
            p.kills++;
          }
        }
      }
    }
    pressed.skill = false;

    // Ï†Å AI + Ï†ëÏ¥â ÌåêÏ†ï
    for (const e of state.enemies) {
      if (e.dead) { e.dieT += dt; continue; }
      e.hitCd = Math.max(0, e.hitCd - dt);
      e.aiT += dt;
      e.jumpCd = Math.max(0, e.jumpCd - dt);

      const dx = p.x - e.x;
      const ad = Math.abs(dx);
      const chase = ad < 360 || (e.tier==="boss" && ad < 520);
      const dir = dx > 0 ? 1 : -1;
      e.face = dir;

      if (e.onGround && chase && e.jumpCd <= 0 && ad > 140 && Math.random() < 0.002) {
        e.vy = -420;
        e.jumpCd = 1.25;
      }

      e.vx = chase ? (dir * e.spd * dt * 0.75) : (Math.sin(e.aiT*1.2) * e.spd * dt * 0.28);
      e.vy += 1100 * dt;

      collidePlatforms(e, state.platforms);
      snapToGround(e);

      const overlapped = aabb(
        p.x - p.w/2, p.y - p.h/2, p.w, p.h,
        e.x - e.w/2, e.y - e.h/2, e.w, e.h
      );

      if (overlapped) stabilizeOverlapNoBounce(state, p, e);

      // ‚úÖ ÌïµÏã¨: Ïó∞ÌÉÄ Ï§ëÏóêÎèÑ Ï†ëÏ¥â ÌîºÌï¥ Îì§Ïñ¥Í∞ê(Î¨¥Ï†Å+Ï†ëÏ¥âÏø®Î°úÎßå Ï†úÌïú)
      if (overlapped && p.inv <= 0 && p.hitCd <= 0) {
        const { dmg } = damageCalc(e.atk, d.def, 0, 1);

        p.hp = clamp(p.hp - dmg, 0, d.hpMax);
        p.inv = 0.55;
        p.hitCd = CONTACT_DAMAGE_COOLDOWN;
        p.noHitT = 0;

        audio.playHit();
        state.dmgText.push(new DamageText(p.x, p.y - 64, `-${dmg}`, "rgba(255,91,110,0.95)"));
        p.x += -e.face * 14;

        if (p.hp <= 0) {
          const lost = Math.round(p.gold * 0.08);
          p.gold = Math.max(0, p.gold - lost);
          p.hp = d.hpMax;
          p.noHitT = 999;
          state.gs = "MENU";
          state.msg = `Î≥¥Ïä§Í≤åÏù¥Ìä∏ÏóêÏÑú Ïì∞Îü¨Ï°åÎã§‚Ä¶ ${lost}G ÏûÉÏùå.`;
          state.msgT = 2.0;
          save(state);
          return;
        }
      }

      if (e.dead) e.anim = "die";
      else if (e.hitCd > 0) e.anim = "hurt";
      else if (!e.onGround) e.anim = "run";
      else if (chase) e.anim = "run";
      else e.anim = "idle";

      e.animT += dt;
      if (e.anim !== e._prevAnim) { e.animT = 0; e._prevAnim = e.anim; }
    }

    if (state.killed >= state.goalKills) ensureDoor(state);

    // ÏΩîÏù∏
    for (let i=state.coins.length-1;i>=0;i--){
      const c = state.coins[i];
      c.t += dt;
      c.vy += 1100*dt;
      c.x += c.vx*dt;
      c.y += c.vy*dt;
      if (c.y > GROUND_Y - 12) {
        c.y = GROUND_Y - 12;
        c.vy *= -0.22;
        c.vx *= 0.55;
      }
      if (dist(c.x,c.y, p.x, p.y-20) < 38) {
        p.gold += c.amount;
        state.coins.splice(i,1);
        audio.playCoin();
      }
    }

    // Î£®ÌåÖ
    for (let i=state.loots.length-1;i>=0;i--){
      const l = state.loots[i];
      l.t += dt;
      l.vy += 1100*dt;
      l.x += l.vx*dt;
      l.y += l.vy*dt;
      if (l.y > GROUND_Y - 16) {
        l.y = GROUND_Y - 16;
        l.vy *= -0.18;
        l.vx *= 0.45;
      }
      if (dist(l.x,l.y, p.x, p.y-20) < 38) {
        p.invItems.push(l.item);
        state.loots.splice(i,1);
        state.msg = `ÌöçÎìù: [${l.item.rar}] ${l.item.name}${l.item.identified?"":"(ÎØ∏Í∞êÏ†ï)"}`;
        state.msgT = 1.5;
      }
    }

    // Î¨∏ ÏßÑÏûÖ
    if (state.door) {
      const d0 = state.door;
      if (aabb(p.x - p.w/2, p.y - p.h/2, p.w, p.h, d0.x, d0.y, d0.w, d0.h)) {
        stageClearReward(state);
        state.stageIndex += 1;
        state.player.stage = state.stageIndex;
        rebuildStage(state);
        save(state);
      }
    }

    for (const f of state.fx) f.update(dt);
    state.fx = state.fx.filter(x => !x.dead());
    for (const t of state.dmgText) t.update(dt);
    state.dmgText = state.dmgText.filter(x => !x.dead());
    for (const pa of state.parts) pa.update(dt);
    state.parts = state.parts.filter(x => !x.dead());

    if (state.msgT > 0) state.msgT -= dt;

    cam.y = CAM_Y;
    const targetX = clamp(p.x - VIEW_W*0.45, 0, WORLD.w - VIEW_W);
    state.camX = lerp(state.camX, targetX, smoothFactor(dt, 18));
    cam.x = state.camX;

    // HUD ÌÅ¥Î¶≠(‚öô/üß™/üéí)
    const hotGear = (pointer.x>=HUD_MENU_BTN.x && pointer.x<=HUD_MENU_BTN.x+HUD_MENU_BTN.w &&
                     pointer.y>=HUD_MENU_BTN.y && pointer.y<=HUD_MENU_BTN.y+HUD_MENU_BTN.h);
    if (pointer.clicked && hotGear) { state.gs = "PAUSE"; save(state); }

    const hotPotionHud = (pointer.x>=HUD_POTION_BTN.x && pointer.x<=HUD_POTION_BTN.x+HUD_POTION_BTN.w &&
                          pointer.y>=HUD_POTION_BTN.y && pointer.y<=HUD_POTION_BTN.y+HUD_POTION_BTN.h);
    if (pointer.clicked && hotPotionHud) { tryUsePotion(state); }

    const hotInv = (pointer.x>=HUD_INV_BTN.x && pointer.x<=HUD_INV_BTN.x+HUD_INV_BTN.w &&
                    pointer.y>=HUD_INV_BTN.y && pointer.y<=HUD_INV_BTN.y+HUD_INV_BTN.h);
    if (pointer.clicked && hotInv) { state.gs = "INV"; save(state); }

    if (pressed.menu) { pressed.menu = false; state.gs = "PAUSE"; save(state); return; }
    if (pressed.inv)  { pressed.inv  = false; state.gs = "INV";   save(state); return; }
  }

  function revive(raw){
    const st = freshState();
    st.gs = raw.gs || "MENU";
    st.opt = raw.opt || st.opt;

    st.player = new Player();
    Object.assign(st.player, raw.player || {});
    st.player.invItems ??= [];
    st.player.equip ??= { weapon:null, armor:null, ring:null };
    for (const s of SLOTS) st.player.equip[s] = st.player.equip[s] || null;

    st.stageIndex = raw.stageIndex ?? st.stageIndex;
    st.inBossRoom = raw.inBossRoom ?? st.inBossRoom;

    rebuildStage(st);

    st.player.invItems = raw.player?.invItems ?? st.player.invItems;
    st.player.equip = raw.player?.equip ?? st.player.equip;
    for (const s of SLOTS) st.player.equip[s] = st.player.equip[s] || null;

    st.player.gold = raw.player?.gold ?? st.player.gold;
    st.player.hp = raw.player?.hp ?? st.player.hp;

    st.killed = raw.killed ?? 0;
    st.goalKills = raw.goalKills ?? st.goalKills;

    st.msg = raw.msg ?? st.msg;
    st.msgT = raw.msgT ?? 0;

    st.invSelId = raw.invSelId ?? null;
    st.invScroll = raw.invScroll ?? 0;

    st.t = 0;
    st.camX = raw.camX ?? 0;
    return st;
  }

  let state = load() ? revive(load()) : freshState();
  applyOptions(state);
  if (state.gs === "PLAY") rebuildStage(state);

  let last = performance.now();
  function loop(t){
    const dt = Math.min(0.033, (t - last)/1000);
    last = t;

    state.t += dt;

    if (state.gs === "PLAY") updatePlay(state, dt);

    state.updatedAt = isoNow();
    if (Math.random() < 0.03) save(state);

    // transformÏù¥ VIEW_W/VIEW_H Í∏∞Ï§ÄÏúºÎ°ú Ïû°ÌòÄ ÏûàÏúºÎØÄÎ°ú Ïù¥ÎåÄÎ°ú clearÌï¥ÎèÑ Ï†ÑÏ≤¥ ÏßÄÏõåÏßê
    ctx.clearRect(0,0,VIEW_W,VIEW_H);

    if (state.gs === "MENU") drawMenu(state);
    else if (state.gs === "OPTIONS") drawOptions(state);
    else if (state.gs === "PAUSE") drawPause(state);
    else if (state.gs === "INV") drawInventory(state);
    else if (state.gs === "EXIT") drawExitScreen();
    else drawScene(state);

    pointer.clicked = false;
    pointer.wheelY = 0;
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
