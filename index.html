<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no" />
  <title>보스게이트 - v4.2 (자동 스테이지 + 조이스틱 3중 입력)</title>
  <style>
    :root{
      --bg:#070a12;
      --panel: rgba(12,18,38,0.88);
      --line: rgba(255,255,255,0.12);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.65);
      --good:#6ae37b;
      --warn:#ffd36a;
      --bad:#ff6a6a;
      --btn1:#243a77;
      --btn2:#1b2a55;
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --r:18px;
      --font: ui-sans-serif, system-ui, -apple-system, "Apple SD Gothic Neo", "Noto Sans KR", Segoe UI, Roboto, Arial, sans-serif;
    }

    html, body{
      margin:0; padding:0;
      width:100%; height:100%;
      overflow:hidden;
      background: var(--bg);
      color: var(--text);
      font-family: var(--font);
      -webkit-tap-highlight-color: transparent;
      user-select:none;
    }

    #app{
      position:fixed; inset:0;
      width:100vw; height:100vh;
      background: radial-gradient(1200px 900px at 30% 20%, #121b3a 0%, #070a12 55%, #050610 100%);
      overflow:hidden;
      touch-action:none;
    }

    /* 캔버스는 그리기만, 입력은 HUD */
    #cv{
      position:absolute; inset:0;
      width:100%; height:100%;
      display:block;
      background: transparent;
      pointer-events:none;
    }

    #hud{
      position:absolute; inset:0;
      pointer-events:auto;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    .panel{
      background: var(--panel);
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    .topbar{
      position:absolute;
      left:12px; right:12px; top:12px;
      display:flex;
      gap:10px;
      align-items:stretch;
      justify-content:space-between;
      z-index: 10;
      pointer-events:auto;
    }

    .status{
      padding:10px 12px;
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width: 280px;
      pointer-events:auto;
    }
    .status .title{ font-weight:900; font-size:13px; letter-spacing:-0.2px; }
    .status .meta{
      display:flex; flex-wrap:wrap;
      gap:10px;
      font-size:12px;
      color: var(--muted);
      letter-spacing:-0.2px;
      align-items:center;
    }

    .btnRow{
      display:flex;
      gap:8px;
      padding:8px;
      align-items:center;
      pointer-events:auto;
    }

    button{
      appearance:none;
      border:none;
      background:none;
      color:inherit;
      font:inherit;
    }

    .btn{
      border: 1px solid rgba(255,255,255,0.14);
      background: linear-gradient(180deg, var(--btn1), var(--btn2));
      color: var(--text);
      padding:10px 12px;
      border-radius:14px;
      font-weight:900;
      font-size:13px;
      letter-spacing:-0.2px;
      cursor:pointer;
      touch-action: manipulation;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      min-height: 40px;
      box-shadow: 0 10px 18px rgba(0,0,0,0.22);
      pointer-events:auto;
    }
    .btn.small{ padding:9px 10px; min-height:36px; font-size:12px; border-radius:12px; }
    .btn.ghost{ background: rgba(255,255,255,0.06); box-shadow:none; }
    .btn.bad{ background: linear-gradient(180deg, rgba(255,106,106,0.25), rgba(255,106,106,0.16)); border-color: rgba(255,106,106,0.28); }
    .btn.good{ background: linear-gradient(180deg, rgba(106,227,123,0.22), rgba(106,227,123,0.14)); border-color: rgba(106,227,123,0.28); }
    .btn.on{ outline:2px solid rgba(106,167,255,0.55); border-color: rgba(106,167,255,0.55); }
    .btn:active{ transform: translateY(1px); }

    .chip{
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: var(--muted);
      display:inline-flex;
      gap:6px;
      align-items:center;
    }
    .chip.good{ color: rgba(106,227,123,0.95); border-color: rgba(106,227,123,0.28); }
    .chip.warn{ color: rgba(255,211,106,0.95); border-color: rgba(255,211,106,0.30); }
    .chip.bad{  color: rgba(255,106,106,0.95); border-color: rgba(255,106,106,0.30); }

    .bottombar{
      position:absolute;
      left:12px; right:12px; bottom:12px;
      display:flex;
      gap:12px;
      align-items:flex-end;
      justify-content:space-between;
      z-index: 10;
      pointer-events:auto;
    }

    .joystick{
      width: 150px; height: 150px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
      position:relative;
      touch-action:none; /* 여기서 드래그 */
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:auto;
    }
    .stick{
      width:64px; height:64px;
      border-radius:999px;
      background: rgba(255,255,255,0.12);
      border:1px solid rgba(255,255,255,0.20);
      box-shadow: 0 12px 26px rgba(0,0,0,0.28);
      position:absolute;
      left:50%; top:50%;
      transform: translate(-50%,-50%);
      pointer-events:none;
    }

    .actions{
      display:flex;
      gap:10px;
      align-items:flex-end;
      pointer-events:auto;
    }
    .col{
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:stretch;
      pointer-events:auto;
    }

    .toastWrap{
      position:absolute;
      left:50%;
      bottom:190px;
      transform: translateX(-50%);
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:center;
      pointer-events:none;
      z-index: 20;
      max-width: min(560px, calc(100vw - 24px));
    }
    .toast{
      background: rgba(0,0,0,0.60);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 999px;
      padding: 10px 14px;
      font-size: 13px;
      color: rgba(255,255,255,0.92);
      backdrop-filter: blur(8px);
      box-shadow: 0 12px 30px rgba(0,0,0,0.25);
      opacity:0;
      transform: translateY(6px);
      transition: opacity .18s ease, transform .18s ease;
      text-align:center;
      line-height:1.25;
      word-break: keep-all;
    }
    .toast.show{ opacity:1; transform: translateY(0); }
    .toast b{ color:#fff; }

    /* 디버그 패널(입력 들어오는지 바로 확인) */
    #debug{
      position:absolute;
      left:12px; bottom:12px;
      transform: translateY(-170px);
      width: min(620px, calc(100vw - 24px));
      z-index: 9999;
      display:block; /* v4.2는 기본 ON */
      padding:10px 12px;
      font-size:12px;
      color: rgba(255,255,255,0.92);
      pointer-events:auto;
    }
    #debug pre{
      margin:8px 0 0 0;
      white-space: pre-wrap;
      word-break: break-word;
      color: rgba(255,255,255,0.82);
      line-height: 1.35;
    }

    #fatal{
      position:absolute;
      inset:12px;
      z-index: 10000;
      display:none;
      padding:14px;
      background: rgba(0,0,0,0.78);
      border: 1px solid rgba(255,106,106,0.35);
      border-radius: 18px;
      overflow:auto;
      pointer-events:auto;
    }
    #fatal h3{
      margin:0 0 8px 0;
      color: rgba(255,106,106,0.95);
      font-size: 14px;
      letter-spacing:-0.2px;
    }
    #fatal pre{
      margin:0;
      white-space: pre-wrap;
      word-break: break-word;
      font-size: 12px;
      color: rgba(255,255,255,0.88);
      line-height: 1.45;
    }

    @media (max-width: 520px){
      .joystick{ width:132px; height:132px; }
      #debug{ transform: translateY(-186px); }
    }
  </style>
</head>

<body>
<div id="app">
  <canvas id="cv"></canvas>

  <div id="hud">
    <div class="topbar">
      <div class="panel status">
        <div class="title">보스게이트 v4.2 (자동 스테이지)</div>
        <div class="meta">
          <span id="sceneTxt">장면: -</span>
          <span id="stageTxt">스테이지: -</span>
          <span id="timerTxt">제한: -</span>
          <span id="fpsTxt">FPS: -</span>
        </div>
        <div class="meta">
          <span class="chip" id="devTxt">기기: -</span>
          <span class="chip" id="ctxTxt">CTX: -</span>
          <span class="chip" id="joyTxt">JOY: -</span>
        </div>
      </div>

      <div class="panel btnRow">
        <button class="btn small" id="btnStage">스테이지</button>
        <button class="btn small bad" id="btnBoss">보스</button>
        <button class="btn small ghost" id="btnRespawn">몹재생성</button>
        <button class="btn small ghost" id="btnReset">리셋</button>
      </div>
    </div>

    <div class="toastWrap" id="toastWrap"></div>

    <div class="bottombar">
      <div class="panel joystick" id="joy">
        <div class="stick" id="stick"></div>
      </div>

      <div class="actions">
        <div class="panel col">
          <button class="btn good" id="btnAttack">공격</button>
          <button class="btn" id="btnDash">대시</button>
        </div>
        <div class="panel col">
          <button class="btn small" id="btnToggleTarget">오토 타겟</button>
          <button class="btn small" id="btnToggleAtk">오토 공격</button>
        </div>
      </div>
    </div>

    <div class="panel" id="debug">
      <b>DEBUG</b> (입력/버튼/상태 로그 — 이게 찍히면 “먹통 아님”)
      <pre id="debugLog"></pre>
    </div>

    <div id="fatal">
      <h3>실행 중 에러 발생(먹통 원인)</h3>
      <pre id="fatalText"></pre>
      <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
        <button class="btn small" id="btnHideFatal">닫기</button>
        <button class="btn small ghost" id="btnReload">새로고침</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  "use strict";

  // ---------- DOM ----------
  const cv = document.getElementById("cv");
  const sceneTxt = document.getElementById("sceneTxt");
  const stageTxt = document.getElementById("stageTxt");
  const timerTxt = document.getElementById("timerTxt");
  const fpsTxt   = document.getElementById("fpsTxt");
  const devTxt   = document.getElementById("devTxt");
  const ctxTxt   = document.getElementById("ctxTxt");
  const joyTxt   = document.getElementById("joyTxt");

  const toastWrap = document.getElementById("toastWrap");
  const debugLogEl = document.getElementById("debugLog");

  const btnStage = document.getElementById("btnStage");
  const btnBoss  = document.getElementById("btnBoss");
  const btnRespawn = document.getElementById("btnRespawn");
  const btnReset = document.getElementById("btnReset");

  const btnAttack = document.getElementById("btnAttack");
  const btnDash   = document.getElementById("btnDash");
  const btnToggleTarget = document.getElementById("btnToggleTarget");
  const btnToggleAtk    = document.getElementById("btnToggleAtk");

  const joy = document.getElementById("joy");
  const stick = document.getElementById("stick");

  const fatal = document.getElementById("fatal");
  const fatalText = document.getElementById("fatalText");
  const btnHideFatal = document.getElementById("btnHideFatal");
  const btnReload = document.getElementById("btnReload");

  // ---------- 오류 처리 ----------
  function showFatal(msg){
    fatalText.textContent = msg;
    fatal.style.display = "block";
  }
  window.addEventListener("error", (e)=>{
    const msg =
`[window.onerror]
${e.message || "unknown error"}
file: ${e.filename || "-"}
line: ${e.lineno || "-"} col: ${e.colno || "-"}
${e.error && e.error.stack ? ("\n" + e.error.stack) : ""}`;
    showFatal(msg);
  });
  window.addEventListener("unhandledrejection", (e)=>{
    const reason = (e && e.reason) ? (e.reason.stack || String(e.reason)) : "unknown rejection";
    showFatal(`[unhandledrejection]\n${reason}`);
  });
  btnHideFatal.addEventListener("click", ()=> fatal.style.display="none");
  btnReload.addEventListener("click", ()=> location.reload());

  // ---------- 유틸 ----------
  const clamp = (v,a,b)=> Math.max(a, Math.min(b,v));
  const now = ()=> performance.now();

  function isMobileLike(){
    return (navigator.maxTouchPoints || 0) > 0 || matchMedia("(pointer: coarse)").matches;
  }
  devTxt.textContent = `기기: ${isMobileLike() ? "스마트폰/태블릿" : "PC"}`;

  // ---------- 로그 ----------
  const logs = [];
  function log(s){
    const t = new Date().toISOString().slice(11,19);
    logs.push(`[${t}] ${s}`);
    while (logs.length > 18) logs.shift();
    debugLogEl.textContent = logs.join("\n");
  }

  // ---------- 토스트 ----------
  const toasts = [];
  function toast(html, life=1100){
    const el = document.createElement("div");
    el.className = "toast";
    el.innerHTML = html;
    toastWrap.appendChild(el);
    requestAnimationFrame(()=> el.classList.add("show"));
    toasts.push({ el, die: now()+life });
  }
  function updateToasts(){
    const t = now();
    for (let i=toasts.length-1;i>=0;i--){
      if (t > toasts[i].die){
        const el = toasts[i].el;
        el.classList.remove("show");
        setTimeout(()=> el.remove(), 220);
        toasts.splice(i,1);
      }
    }
  }

  // ---------- 버튼 바인딩(클릭/터치/포인터 3중) ----------
  function bind(btn, name, fn){
    const run = (e)=>{
      try{
        if (e && e.cancelable) e.preventDefault();
        log(`BTN: ${name}`);
        fn();
      }catch(err){
        showFatal(`[bind:${name}]\n${err && err.stack ? err.stack : String(err)}`);
      }
    };
    btn.addEventListener("click", run, { passive:false });
    btn.addEventListener("touchstart", run, { passive:false });
    btn.addEventListener("pointerdown", run, { passive:false });
  }

  // ---------- 캔버스 ----------
  const ctx = (() => {
    try{
      const c = cv.getContext("2d", { alpha:false });
      ctxTxt.textContent = c ? "CTX: 2D OK" : "CTX: FAIL";
      return c;
    }catch(_){
      ctxTxt.textContent = "CTX: FAIL";
      return null;
    }
  })();
  if (!ctx){
    showFatal("Canvas 2D 컨텍스트 생성 실패");
    return;
  }

  function resize(){
    const dpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
    const w = Math.max(1, window.innerWidth);
    const h = Math.max(1, window.innerHeight);
    cv.width  = Math.floor(w * dpr);
    cv.height = Math.floor(h * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    log(`resize: ${w}x${h} dpr=${dpr}`);
  }
  window.addEventListener("resize", resize, { passive:true });
  resize();

  // ---------- 상태 ----------
  const Game = {
    scene: "stage",
    stageId: "1-1",
    stageTime: 0,
    timeLimit: 300,
    autoTarget: true,
    autoAttack: true,
  };

  const Player = {
    x: 0, y: 0,
    r: 14,
    spd: 240,
    dashTime: 0,
    dashCd: 0,
  };

  const Mobs = []; // {kind,x,y,r,phase}

  function syncHUD(){
    sceneTxt.textContent = `장면: ${Game.scene==="stage" ? "스테이지" : "보스"}`;
    stageTxt.textContent = `스테이지: ${Game.stageId}`;
    btnToggleTarget.classList.toggle("on", Game.autoTarget);
    btnToggleAtk.classList.toggle("on", Game.autoAttack);
  }

  function respawnMobs(){
    Mobs.length = 0;
    if (Game.scene === "stage"){
      for (let i=0;i<7;i++){
        const elite = Math.random()<0.2;
        Mobs.push({
          kind: elite ? "elite" : "slime",
          x:(Math.random()*2-1)*260,
          y:(Math.random()*2-1)*170,
          r: elite ? 18 : 14,
          phase: Math.random()*Math.PI*2
        });
      }
    } else {
      Mobs.push({
        kind:"boss",
        x: 260, y: 0,
        r: 34,
        phase: Math.random()*Math.PI*2
      });
    }
    log(`MOBS: ${Mobs.length} spawned`);
  }

  function startStage(){
    Game.scene = "stage";
    Game.stageId = "1-1";
    Game.stageTime = 0;
    Game.timeLimit = 300;
    Player.x = 0; Player.y = 0;
    respawnMobs();
    syncHUD();
    toast("<b>스테이지 1-1</b> 자동/재시작", 1200);
  }

  function startBoss(){
    Game.scene = "boss";
    Game.stageId = "BOSS";
    Game.stageTime = 0;
    Game.timeLimit = 240;
    Player.x = 0; Player.y = 0;
    respawnMobs();
    syncHUD();
    toast("<b>보스전</b> 시작", 1200);
  }

  function resetAll(){
    Player.x=0; Player.y=0;
    Player.dashTime=0; Player.dashCd=0;
    startStage();
    toast("<b>리셋</b>", 900);
  }

  // ---------- 입력(조이스틱 + 키보드) ----------
  const Joy = { active:false, id:null, cx:0, cy:0, x:0, y:0, maxR:56, lastEvt:"-" };
  const Keys = new Set();

  function resetStick(){
    stick.style.transform = "translate(-50%,-50%)";
  }
  function setStick(dx,dy){
    const r = Math.hypot(dx,dy);
    let sx=dx, sy=dy;
    if (r > Joy.maxR){
      const k = Joy.maxR / r;
      sx*=k; sy*=k;
    }
    stick.style.transform = `translate(calc(-50% + ${sx}px), calc(-50% + ${sy}px))`;
  }
  function joyApply(clientX, clientY){
    const dx = clientX - Joy.cx;
    const dy = clientY - Joy.cy;
    setStick(dx,dy);
    Joy.x = clamp(dx/Joy.maxR, -1, 1);
    Joy.y = clamp(dy/Joy.maxR, -1, 1);
    joyTxt.textContent = `JOY: ${Joy.x.toFixed(2)}, ${Joy.y.toFixed(2)} (${Joy.lastEvt})`;
  }
  function joyStartGeneric(clientX, clientY, tag){
    Joy.active = true;
    Joy.lastEvt = tag;
    const rect = joy.getBoundingClientRect();
    Joy.cx = rect.left + rect.width/2;
    Joy.cy = rect.top  + rect.height/2;
    joyApply(clientX, clientY);
    log(`JOY START (${tag})`);
  }
  function joyMoveGeneric(clientX, clientY, tag){
    if (!Joy.active) return;
    Joy.lastEvt = tag;
    joyApply(clientX, clientY);
  }
  function joyEndGeneric(tag){
    if (!Joy.active) return;
    Joy.active = false;
    Joy.id = null;
    Joy.x = 0; Joy.y = 0;
    Joy.lastEvt = tag;
    joyTxt.textContent = `JOY: 0.00, 0.00 (${tag})`;
    resetStick();
    log(`JOY END (${tag})`);
  }

  // 1) Pointer Events
  joy.addEventListener("pointerdown", (e)=>{
    if (e.cancelable) e.preventDefault();
    Joy.id = e.pointerId;
    try{ joy.setPointerCapture(e.pointerId); }catch(_){}
    joyStartGeneric(e.clientX, e.clientY, "pointer");
  }, { passive:false });

  joy.addEventListener("pointermove", (e)=>{
    if (!Joy.active) return;
    if (Joy.id !== null && e.pointerId !== Joy.id) return;
    if (e.cancelable) e.preventDefault();
    joyMoveGeneric(e.clientX, e.clientY, "pointer");
  }, { passive:false });

  joy.addEventListener("pointerup", (e)=>{
    if (Joy.id !== null && e.pointerId !== Joy.id) return;
    if (e.cancelable) e.preventDefault();
    joyEndGeneric("pointerup");
  }, { passive:false });

  joy.addEventListener("pointercancel", (e)=>{
    if (e.cancelable) e.preventDefault();
    joyEndGeneric("pointercancel");
  }, { passive:false });

  // 2) Touch Events (pointer가 안 먹는 폰 대비)
  joy.addEventListener("touchstart", (e)=>{
    if (e.cancelable) e.preventDefault();
    const t = e.changedTouches[0];
    if (!t) return;
    joyStartGeneric(t.clientX, t.clientY, "touch");
  }, { passive:false });

  joy.addEventListener("touchmove", (e)=>{
    if (!Joy.active) return;
    if (e.cancelable) e.preventDefault();
    const t = e.changedTouches[0];
    if (!t) return;
    joyMoveGeneric(t.clientX, t.clientY, "touch");
  }, { passive:false });

  joy.addEventListener("touchend", (e)=>{
    if (e.cancelable) e.preventDefault();
    joyEndGeneric("touchend");
  }, { passive:false });

  joy.addEventListener("touchcancel", (e)=>{
    if (e.cancelable) e.preventDefault();
    joyEndGeneric("touchcancel");
  }, { passive:false });

  // 3) Mouse Events (일부 환경 대비)
  let mouseDown = false;
  joy.addEventListener("mousedown", (e)=>{
    e.preventDefault();
    mouseDown = true;
    joyStartGeneric(e.clientX, e.clientY, "mouse");
  });
  window.addEventListener("mousemove", (e)=>{
    if (!mouseDown) return;
    joyMoveGeneric(e.clientX, e.clientY, "mouse");
  });
  window.addEventListener("mouseup", ()=>{
    if (!mouseDown) return;
    mouseDown = false;
    joyEndGeneric("mouseup");
  });

  // 키보드 이동 (PC 즉시 테스트)
  window.addEventListener("keydown", (e)=>{
    const k = e.key.toLowerCase();
    Keys.add(k);
    if (["arrowup","arrowdown","arrowleft","arrowright"," "].includes(e.key)) e.preventDefault();
  }, { passive:false });
  window.addEventListener("keyup", (e)=>{
    Keys.delete(e.key.toLowerCase());
  });

  function getKeyboardDir(){
    let x=0,y=0;
    if (Keys.has("a") || Keys.has("arrowleft"))  x -= 1;
    if (Keys.has("d") || Keys.has("arrowright")) x += 1;
    if (Keys.has("w") || Keys.has("arrowup"))    y -= 1;
    if (Keys.has("s") || Keys.has("arrowdown"))  y += 1;
    const len = Math.hypot(x,y);
    if (len>1e-6){ x/=len; y/=len; }
    return {x,y};
  }

  // ---------- 버튼 ----------
  bind(btnStage, "스테이지", startStage);
  bind(btnBoss,  "보스", startBoss);
  bind(btnRespawn, "몹재생성", ()=>{ respawnMobs(); toast("몹 재생성", 900); });
  bind(btnReset, "리셋", resetAll);

  bind(btnAttack, "공격", ()=> toast("공격!", 600));
  bind(btnDash,   "대시", ()=>{
    Player.dashTime = 0.12;
    Player.dashCd = 0.8;
    toast("대시!", 600);
  });

  bind(btnToggleTarget, "오토타겟", ()=>{
    Game.autoTarget = !Game.autoTarget;
    btnToggleTarget.classList.toggle("on", Game.autoTarget);
    toast(`오토 타겟: <b>${Game.autoTarget?"ON":"OFF"}</b>`, 900);
  });
  bind(btnToggleAtk, "오토공격", ()=>{
    Game.autoAttack = !Game.autoAttack;
    btnToggleAtk.classList.toggle("on", Game.autoAttack);
    toast(`오토 공격: <b>${Game.autoAttack?"ON":"OFF"}</b>`, 900);
  });

  // ---------- 루프 ----------
  let last = now();
  let fpsAcc=0, fpsFrames=0, fps=60;

  function update(dt){
    // 타이머
    Game.stageTime += dt;
    const left = Math.max(0, Math.ceil(Game.timeLimit - Game.stageTime));
    const mm = String(Math.floor(left/60)).padStart(2,"0");
    const ss = String(left%60).padStart(2,"0");
    timerTxt.textContent = `제한: ${mm}:${ss}`;
    if (left <= 0){
      toast("<b>시간 초과</b> — 스테이지 재시작", 1300);
      startStage();
    }

    // 이동 (조이스틱 우선, 키보드 보조)
    let mx = Joy.active ? Joy.x : 0;
    let my = Joy.active ? Joy.y : 0;

    if (!Joy.active){
      const k = getKeyboardDir();
      mx = k.x; my = k.y;
    }

    const len = Math.hypot(mx,my);
    const nx = len>1e-6 ? mx/len : 0;
    const ny = len>1e-6 ? my/len : 0;

    Player.dashTime = Math.max(0, Player.dashTime - dt);
    Player.dashCd   = Math.max(0, Player.dashCd - dt);

    const spd = Player.spd * (Player.dashTime>0 ? 2.4 : 1.0);
    Player.x += nx * spd * dt;
    Player.y += ny * spd * dt;

    // 몬스터 움직임(“살아있다” 표시)
    for (const m of Mobs){
      m.phase += dt * (m.kind==="boss" ? 1.2 : 1.8);
    }
  }

  function draw(){
    const w = window.innerWidth;
    const h = window.innerHeight;

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect(0,0,w,h);

    ctx.save();
    ctx.translate(w/2, h/2);

    // 안내문(무조건 보이게)
    ctx.fillStyle = "rgba(255,255,255,0.86)";
    ctx.font = "800 16px system-ui, sans-serif";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText("v4.2: 로딩되면 자동으로 몬스터 생성됨 (조이스틱 드래그로 이동)", -w/2 + 16, -h/2 + 16);

    // 몬스터
    for (const m of Mobs){
      const wob = Math.sin(m.phase) * 2.4;
      ctx.fillStyle =
        m.kind==="boss" ? "rgba(255,106,106,0.92)" :
        m.kind==="elite"? "rgba(106,167,255,0.92)" :
                          "rgba(106,227,123,0.92)";
      ctx.beginPath();
      ctx.arc(m.x, m.y + wob, m.r, 0, Math.PI*2);
      ctx.fill();
    }

    // 플레이어
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.beginPath();
    ctx.arc(Player.x, Player.y, Player.r, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function loop(){
    const t = now();
    let dt = (t - last) / 1000;
    last = t;
    dt = Math.min(0.05, Math.max(0, dt));

    fpsAcc += dt; fpsFrames++;
    if (fpsAcc >= 0.4){
      fps = Math.round(fpsFrames / fpsAcc);
      fpsAcc = 0; fpsFrames = 0;
      fpsTxt.textContent = `FPS: ${fps}`;
    }

    update(dt);
    draw();
    updateToasts();
    requestAnimationFrame(loop);
  }

  // ---------- 시작 ----------
  syncHUD();
  joyTxt.textContent = "JOY: 0.00, 0.00 (-)";
  toast("<b>v4.2 로딩 완료</b>", 1200);

  // ✅ 자동으로 스테이지 시작 + 몹 생성 (사용자가 버튼 안 눌러도 몬스터가 보이게)
  setTimeout(()=>{
    startStage();
    log("AUTO: startStage()");
  }, 200);

  loop();
})();
</script>
</body>
</html>
