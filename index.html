<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no" />
  <title>보스게이트 - v4.5 (자동 확장자 탐색 + 이미지 우선)</title>
  <style>
    :root{
      --bg:#070a12;
      --panel: rgba(12,18,38,0.88);
      --line: rgba(255,255,255,0.12);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.65);
      --good:#6ae37b;
      --warn:#ffd36a;
      --bad:#ff6a6a;
      --btn1:#243a77;
      --btn2:#1b2a55;
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --r:18px;
      --font: ui-sans-serif, system-ui, -apple-system, "Apple SD Gothic Neo", "Noto Sans KR", Segoe UI, Roboto, Arial, sans-serif;
    }

    html, body{
      margin:0; padding:0;
      width:100%; height:100%;
      overflow:hidden;
      background: var(--bg);
      color: var(--text);
      font-family: var(--font);
      -webkit-tap-highlight-color: transparent;
      user-select:none;
    }

    #app{
      position:fixed; inset:0;
      width:100vw; height:100vh;
      background: radial-gradient(1200px 900px at 30% 20%, #121b3a 0%, #070a12 55%, #050610 100%);
      overflow:hidden;
      touch-action:none;
    }

    #cv{
      position:absolute; inset:0;
      width:100%; height:100%;
      display:block;
      background: transparent;
      pointer-events:none;
    }

    #hud{
      position:absolute; inset:0;
      pointer-events:auto;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    .panel{
      background: var(--panel);
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    .topbar{
      position:absolute;
      left:12px; right:12px; top:12px;
      display:flex;
      gap:10px;
      align-items:stretch;
      justify-content:space-between;
      z-index: 10;
      pointer-events:auto;
    }

    .status{
      padding:10px 12px;
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width: 360px;
      pointer-events:auto;
    }
    .status .title{ font-weight:900; font-size:13px; letter-spacing:-0.2px; }
    .status .meta{
      display:flex; flex-wrap:wrap;
      gap:10px;
      font-size:12px;
      color: var(--muted);
      letter-spacing:-0.2px;
      align-items:center;
    }

    .btnRow{
      display:flex;
      gap:8px;
      padding:8px;
      align-items:center;
      pointer-events:auto;
    }

    button{
      appearance:none;
      border:none;
      background:none;
      color:inherit;
      font:inherit;
    }

    .btn{
      border: 1px solid rgba(255,255,255,0.14);
      background: linear-gradient(180deg, var(--btn1), var(--btn2));
      color: var(--text);
      padding:10px 12px;
      border-radius:14px;
      font-weight:900;
      font-size:13px;
      letter-spacing:-0.2px;
      cursor:pointer;
      touch-action: manipulation;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      min-height: 40px;
      box-shadow: 0 10px 18px rgba(0,0,0,0.22);
      pointer-events:auto;
    }
    .btn.small{ padding:9px 10px; min-height:36px; font-size:12px; border-radius:12px; }
    .btn.ghost{ background: rgba(255,255,255,0.06); box-shadow:none; }
    .btn.bad{ background: linear-gradient(180deg, rgba(255,106,106,0.25), rgba(255,106,106,0.16)); border-color: rgba(255,106,106,0.28); }
    .btn.good{ background: linear-gradient(180deg, rgba(106,227,123,0.22), rgba(106,227,123,0.14)); border-color: rgba(106,227,123,0.28); }
    .btn.on{ outline:2px solid rgba(106,167,255,0.55); border-color: rgba(106,167,255,0.55); }
    .btn:active{ transform: translateY(1px); }

    .chip{
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: var(--muted);
      display:inline-flex;
      gap:6px;
      align-items:center;
    }
    .chip.good{ color: rgba(106,227,123,0.95); border-color: rgba(106,227,123,0.28); }
    .chip.warn{ color: rgba(255,211,106,0.95); border-color: rgba(255,211,106,0.30); }
    .chip.bad{  color: rgba(255,106,106,0.95); border-color: rgba(255,106,106,0.30); }

    .bottombar{
      position:absolute;
      left:12px; right:12px; bottom:12px;
      display:flex;
      gap:12px;
      align-items:flex-end;
      justify-content:space-between;
      z-index: 10;
      pointer-events:auto;
    }

    .joystick{
      width: 150px; height: 150px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
      position:relative;
      touch-action:none;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:auto;
    }
    .stick{
      width:64px; height:64px;
      border-radius:999px;
      background: rgba(255,255,255,0.12);
      border:1px solid rgba(255,255,255,0.20);
      box-shadow: 0 12px 26px rgba(0,0,0,0.28);
      position:absolute;
      left:50%; top:50%;
      transform: translate(-50%,-50%);
      pointer-events:none;
    }

    .actions{
      display:flex;
      gap:10px;
      align-items:flex-end;
      pointer-events:auto;
    }
    .col{
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:stretch;
      pointer-events:auto;
    }

    .toastWrap{
      position:absolute;
      left:50%;
      bottom:190px;
      transform: translateX(-50%);
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:center;
      pointer-events:none;
      z-index: 20;
      max-width: min(640px, calc(100vw - 24px));
    }
    .toast{
      background: rgba(0,0,0,0.60);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 999px;
      padding: 10px 14px;
      font-size: 13px;
      color: rgba(255,255,255,0.92);
      backdrop-filter: blur(8px);
      box-shadow: 0 12px 30px rgba(0,0,0,0.25);
      opacity:0;
      transform: translateY(6px);
      transition: opacity .18s ease, transform .18s ease;
      text-align:center;
      line-height:1.25;
      word-break: keep-all;
    }
    .toast.show{ opacity:1; transform: translateY(0); }
    .toast b{ color:#fff; }

    #debug{
      position:absolute;
      left:12px; bottom:12px;
      transform: translateY(-170px);
      width: min(760px, calc(100vw - 24px));
      z-index: 9999;
      display:block;
      padding:10px 12px;
      font-size:12px;
      color: rgba(255,255,255,0.92);
      pointer-events:auto;
    }
    #debug pre{
      margin:8px 0 0 0;
      white-space: pre-wrap;
      word-break: break-word;
      color: rgba(255,255,255,0.82);
      line-height: 1.35;
    }

    #fatal{
      position:absolute;
      inset:12px;
      z-index: 10000;
      display:none;
      padding:14px;
      background: rgba(0,0,0,0.78);
      border: 1px solid rgba(255,106,106,0.35);
      border-radius: 18px;
      overflow:auto;
      pointer-events:auto;
    }
    #fatal h3{
      margin:0 0 8px 0;
      color: rgba(255,106,106,0.95);
      font-size: 14px;
      letter-spacing:-0.2px;
    }
    #fatal pre{
      margin:0;
      white-space: pre-wrap;
      word-break: break-word;
      font-size: 12px;
      color: rgba(255,255,255,0.88);
      line-height: 1.45;
    }

    @media (max-width: 520px){
      .joystick{ width:132px; height:132px; }
      #debug{ transform: translateY(-186px); }
      .status{ min-width: 300px; }
    }
  </style>
</head>

<body>
<div id="app">
  <canvas id="cv"></canvas>

  <div id="hud">
    <div class="topbar">
      <div class="panel status">
        <div class="title">보스게이트 v4.5 (자동 확장자 탐색)</div>
        <div class="meta">
          <span id="sceneTxt">장면: -</span>
          <span id="stageTxt">스테이지: -</span>
          <span id="timerTxt">제한: -</span>
          <span id="fpsTxt">FPS: -</span>
        </div>
        <div class="meta">
          <span class="chip" id="devTxt">기기: -</span>
          <span class="chip" id="ctxTxt">CTX: -</span>
          <span class="chip" id="assetTxt">ASSET: -</span>
          <span class="chip good" id="killTxt">처치: 0</span>
          <span class="chip" id="invTxt">인벤: 0</span>
        </div>
      </div>

      <div class="panel btnRow">
        <button class="btn small" id="btnStage">스테이지</button>
        <button class="btn small bad" id="btnBoss">보스</button>
        <button class="btn small ghost" id="btnRespawn">몹재생성</button>
        <button class="btn small ghost" id="btnReset">리셋</button>
      </div>
    </div>

    <div class="toastWrap" id="toastWrap"></div>

    <div class="bottombar">
      <div class="panel joystick" id="joy">
        <div class="stick" id="stick"></div>
      </div>

      <div class="actions">
        <div class="panel col">
          <button class="btn good" id="btnAttack">공격</button>
          <button class="btn" id="btnDash">대시</button>
        </div>
        <div class="panel col">
          <button class="btn small on" id="btnToggleTarget">오토 타겟</button>
          <button class="btn small on" id="btnToggleAtk">오토 공격</button>
          <button class="btn small ghost" id="btnPick">줍기</button>
        </div>
      </div>
    </div>

    <div class="panel" id="debug">
      <b>DEBUG</b> (ASSET OK 로그가 찍히면 이미지 경로/확장자 정상)
      <pre id="debugLog"></pre>
    </div>

    <div id="fatal">
      <h3>실행 중 에러 발생(먹통 원인)</h3>
      <pre id="fatalText"></pre>
      <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
        <button class="btn small" id="btnHideFatal">닫기</button>
        <button class="btn small ghost" id="btnReload">새로고침</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  "use strict";

  // ---------- DOM ----------
  const cv = document.getElementById("cv");
  const sceneTxt = document.getElementById("sceneTxt");
  const stageTxt = document.getElementById("stageTxt");
  const timerTxt = document.getElementById("timerTxt");
  const fpsTxt   = document.getElementById("fpsTxt");
  const devTxt   = document.getElementById("devTxt");
  const ctxTxt   = document.getElementById("ctxTxt");
  const assetTxt = document.getElementById("assetTxt");
  const killTxt  = document.getElementById("killTxt");
  const invTxt   = document.getElementById("invTxt");

  const toastWrap = document.getElementById("toastWrap");
  const debugLogEl = document.getElementById("debugLog");

  const btnStage = document.getElementById("btnStage");
  const btnBoss  = document.getElementById("btnBoss");
  const btnRespawn = document.getElementById("btnRespawn");
  const btnReset = document.getElementById("btnReset");

  const btnAttack = document.getElementById("btnAttack");
  const btnDash   = document.getElementById("btnDash");
  const btnToggleTarget = document.getElementById("btnToggleTarget");
  const btnToggleAtk    = document.getElementById("btnToggleAtk");
  const btnPick         = document.getElementById("btnPick");

  const joy = document.getElementById("joy");
  const stick = document.getElementById("stick");

  const fatal = document.getElementById("fatal");
  const fatalText = document.getElementById("fatalText");
  const btnHideFatal = document.getElementById("btnHideFatal");
  const btnReload = document.getElementById("btnReload");

  // ---------- 오류 처리 ----------
  function showFatal(msg){
    fatalText.textContent = msg;
    fatal.style.display = "block";
  }
  window.addEventListener("error", (e)=>{
    const msg =
`[window.onerror]
${e.message || "unknown error"}
file: ${e.filename || "-"}
line: ${e.lineno || "-"} col: ${e.colno || "-"}
${e.error && e.error.stack ? ("\n" + e.error.stack) : ""}`;
    showFatal(msg);
  });
  window.addEventListener("unhandledrejection", (e)=>{
    const reason = (e && e.reason) ? (e.reason.stack || String(e.reason)) : "unknown rejection";
    showFatal(`[unhandledrejection]\n${reason}`);
  });
  btnHideFatal.addEventListener("click", ()=> fatal.style.display="none");
  btnReload.addEventListener("click", ()=> location.reload());

  // ---------- 유틸 ----------
  const clamp = (v,a,b)=> Math.max(a, Math.min(b,v));
  const now = ()=> performance.now();
  const dist = (ax,ay,bx,by)=> Math.hypot(ax-bx, ay-by);

  function isMobileLike(){
    return (navigator.maxTouchPoints || 0) > 0 || matchMedia("(pointer: coarse)").matches;
  }
  devTxt.textContent = `기기: ${isMobileLike() ? "스마트폰/태블릿" : "PC"}`;

  // ---------- 로그 ----------
  const logs = [];
  function log(s){
    const t = new Date().toISOString().slice(11,19);
    logs.push(`[${t}] ${s}`);
    while (logs.length > 22) logs.shift();
    debugLogEl.textContent = logs.join("\n");
  }

  // ---------- 토스트 ----------
  const toasts = [];
  function toast(html, life=1100){
    const el = document.createElement("div");
    el.className = "toast";
    el.innerHTML = html;
    toastWrap.appendChild(el);
    requestAnimationFrame(()=> el.classList.add("show"));
    toasts.push({ el, die: now()+life });
  }
  function updateToasts(){
    const t = now();
    for (let i=toasts.length-1;i>=0;i--){
      if (t > toasts[i].die){
        const el = toasts[i].el;
        el.classList.remove("show");
        setTimeout(()=> el.remove(), 220);
        toasts.splice(i,1);
      }
    }
  }

  // ---------- 버튼 바인딩 ----------
  function bind(btn, name, fn){
    const run = (e)=>{
      try{
        if (e && e.cancelable) e.preventDefault();
        log(`BTN: ${name}`);
        fn();
      }catch(err){
        showFatal(`[bind:${name}]\n${err && err.stack ? err.stack : String(err)}`);
      }
    };
    btn.addEventListener("click", run, { passive:false });
    btn.addEventListener("touchstart", run, { passive:false });
    btn.addEventListener("pointerdown", run, { passive:false });
  }

  // ---------- 캔버스 ----------
  const ctx = (() => {
    try{
      const c = cv.getContext("2d", { alpha:false });
      ctxTxt.textContent = c ? "CTX: 2D OK" : "CTX: FAIL";
      return c;
    }catch(_){
      ctxTxt.textContent = "CTX: FAIL";
      return null;
    }
  })();
  if (!ctx){
    showFatal("Canvas 2D 컨텍스트 생성 실패");
    return;
  }

  function resize(){
    const dpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
    const w = Math.max(1, window.innerWidth);
    const h = Math.max(1, window.innerHeight);
    cv.width  = Math.floor(w * dpr);
    cv.height = Math.floor(h * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    log(`resize: ${w}x${h} dpr=${dpr}`);
  }
  window.addEventListener("resize", resize, { passive:true });
  resize();

  // =========================================================
  //  ASSET SYSTEM (자동 확장자 탐색)
  // =========================================================
  const ASSET = {
    bases: {
      bg:     "assets/bg",
      player: "assets/player",
      slime:  "assets/slime",
      elite:  "assets/elite",
      boss:   "assets/boss",
    },
    // 가능성 높은 순서 + 대문자 확장자까지 대비
    exts: ["png","webp","jpg","jpeg","PNG","WEBP","JPG","JPEG"],
    img: {},
    ok: {},
    urlUsed: {},
    ready: false,
  };

  function loadImageTry(url){
    return new Promise((resolve)=>{
      const im = new Image();
      im.decoding = "async";
      im.onload = ()=> resolve({ ok:true, im, url });
      im.onerror = ()=> resolve({ ok:false, im:null, url });
      im.src = url;
    });
  }

  async function loadImageAuto(key){
    const base = ASSET.bases[key];
    for (const ext of ASSET.exts){
      const url = `${base}.${ext}`;
      const r = await loadImageTry(url);
      if (r.ok) return r;
    }
    return { ok:false, im:null, url:"(not found)" };
  }

  async function preloadAssets(){
    assetTxt.textContent = "ASSET: 로딩중...";
    assetTxt.className = "chip";

    const keys = Object.keys(ASSET.bases);
    let okN = 0;

    for (const k of keys){
      const r = await loadImageAuto(k);
      ASSET.ok[k] = r.ok;
      ASSET.urlUsed[k] = r.url;
      if (r.ok){
        ASSET.img[k] = r.im;
        okN++;
        log(`ASSET OK: ${k} <- ${r.url}`);
      } else {
        log(`ASSET FAIL: ${k} (png/webp/jpg/jpeg 없음)`);
      }
    }

    ASSET.ready = true;

    if (okN === 0){
      assetTxt.textContent = "ASSET: 없음(도형 모드)";
      assetTxt.className = "chip warn";
    } else {
      assetTxt.textContent = `ASSET: ${okN}/${keys.length} 로드`;
      assetTxt.className = "chip good";
    }
  }

  function drawSpriteOrCircle(kind, x, y, r){
    const mapKey =
      kind==="player" ? "player" :
      kind==="slime"  ? "slime"  :
      kind==="elite"  ? "elite"  :
      kind==="boss"   ? "boss"   : null;

    const has = mapKey && ASSET.ok[mapKey] && ASSET.img[mapKey];

    if (has){
      const im = ASSET.img[mapKey];
      const size = r * 2.4;
      ctx.drawImage(im, x - size/2, y - size/2, size, size);
      return;
    }

    ctx.fillStyle =
      kind==="boss" ? "rgba(255,106,106,0.92)" :
      kind==="elite"? "rgba(106,167,255,0.92)" :
      kind==="slime"? "rgba(106,227,123,0.92)" :
                      "rgba(255,255,255,0.95)";
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.fill();
  }

  function drawBg(w,h){
    if (ASSET.ok.bg && ASSET.img.bg){
      const im = ASSET.img.bg;
      const iw = im.width, ih = im.height;
      const s = Math.max(w/iw, h/ih);
      const dw = iw*s, dh = ih*s;
      ctx.drawImage(im, (w-dw)/2, (h-dh)/2, dw, dh);
      return;
    }
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect(0,0,w,h);
  }

  // =========================================================
  //  GAME (v4.4 로직 유지)
  // =========================================================
  const Game = {
    scene: "stage",
    stageId: "1-1",
    stageTime: 0,
    timeLimit: 300,
    autoTarget: true,
    autoAttack: true,
    kills: 0,
  };

  const Player = {
    x: 0, y: 0,
    r: 14,
    spd: 240,
    dashTime: 0,
    dashCd: 0,
    atk: 16,
    atkRange: 36,
    atkCd: 0.28,
    atkTimer: 0,
  };

  const Mobs = [];
  let mobSeq = 1;
  const Inv = [];

  function syncHUD(){
    sceneTxt.textContent = `장면: ${Game.scene==="stage" ? "스테이지" : "보스"}`;
    stageTxt.textContent = `스테이지: ${Game.stageId}`;
    btnToggleTarget.classList.toggle("on", Game.autoTarget);
    btnToggleAtk.classList.toggle("on", Game.autoAttack);
    killTxt.textContent = `처치: ${Game.kills}`;
    invTxt.textContent = `인벤: ${Inv.length}`;
  }

  function mobTemplate(kind){
    if (kind === "boss")  return { r: 36, hp: 320, spd: 70 };
    if (kind === "elite") return { r: 18, hp: 90,  spd: 120 };
    return { r: 14, hp: 55,  spd: 95 };
  }

  function respawnMobs(){
    Mobs.length = 0;
    mobSeq = 1;

    if (Game.scene === "stage"){
      for (let i=0;i<8;i++){
        const kind = Math.random()<0.2 ? "elite" : "slime";
        const t = mobTemplate(kind);
        Mobs.push({
          id: mobSeq++,
          kind,
          x:(Math.random()*2-1)*260,
          y:(Math.random()*2-1)*170,
          r:t.r,
          hp:t.hp,
          hpMax:t.hp,
          spd:t.spd,
          phase: Math.random()*Math.PI*2,
          hitFlash: 0,
          knockX: 0,
          knockY: 0,
        });
      }
    } else {
      const t = mobTemplate("boss");
      Mobs.push({
        id: mobSeq++,
        kind:"boss",
        x: 260, y: 0,
        r:t.r,
        hp:t.hp,
        hpMax:t.hp,
        spd:t.spd,
        phase: Math.random()*Math.PI*2,
        hitFlash: 0,
        knockX: 0,
        knockY: 0,
      });
    }
    log(`MOBS: ${Mobs.length} spawned`);
  }

  function startStage(){
    Game.scene = "stage";
    Game.stageId = "1-1";
    Game.stageTime = 0;
    Game.timeLimit = 300;
    Player.x = 0; Player.y = 0;
    Player.dashTime = 0; Player.dashCd = 0;
    Player.atkTimer = 0;
    respawnMobs();
    syncHUD();
    toast("<b>스테이지 1-1</b> 시작", 900);
  }

  function startBoss(){
    Game.scene = "boss";
    Game.stageId = "BOSS";
    Game.stageTime = 0;
    Game.timeLimit = 240;
    Player.x = 0; Player.y = 0;
    Player.dashTime = 0; Player.dashCd = 0;
    Player.atkTimer = 0;
    respawnMobs();
    syncHUD();
    toast("<b>보스전</b> 시작", 900);
  }

  function resetAll(){
    Game.kills = 0;
    Inv.length = 0;
    startStage();
    toast("<b>리셋 완료</b>", 800);
  }

  // ---------- Joystick ----------
  const Joy = { active:false, id:null, cx:0, cy:0, x:0, y:0, maxR:56 };
  function resetStick(){ stick.style.transform = "translate(-50%,-50%)"; }
  function setStick(dx,dy){
    const r = Math.hypot(dx,dy);
    let sx=dx, sy=dy;
    if (r > Joy.maxR){
      const k = Joy.maxR / r;
      sx*=k; sy*=k;
    }
    stick.style.transform = `translate(calc(-50% + ${sx}px), calc(-50% + ${sy}px))`;
  }
  function joyStart(clientX, clientY){
    Joy.active = true;
    const rect = joy.getBoundingClientRect();
    Joy.cx = rect.left + rect.width/2;
    Joy.cy = rect.top  + rect.height/2;
    const dx = clientX - Joy.cx;
    const dy = clientY - Joy.cy;
    setStick(dx,dy);
    Joy.x = clamp(dx/Joy.maxR, -1, 1);
    Joy.y = clamp(dy/Joy.maxR, -1, 1);
  }
  function joyMove(clientX, clientY){
    if (!Joy.active) return;
    const dx = clientX - Joy.cx;
    const dy = clientY - Joy.cy;
    setStick(dx,dy);
    Joy.x = clamp(dx/Joy.maxR, -1, 1);
    Joy.y = clamp(dy/Joy.maxR, -1, 1);
  }
  function joyEnd(){
    Joy.active = false;
    Joy.x = 0; Joy.y = 0;
    resetStick();
  }

  joy.addEventListener("pointerdown", (e)=>{ if (e.cancelable) e.preventDefault(); joyStart(e.clientX, e.clientY); }, {passive:false});
  joy.addEventListener("pointermove", (e)=>{ if (e.cancelable) e.preventDefault(); joyMove(e.clientX, e.clientY); }, {passive:false});
  joy.addEventListener("pointerup",   (e)=>{ if (e.cancelable) e.preventDefault(); joyEnd(); }, {passive:false});
  joy.addEventListener("pointercancel",(e)=>{ if (e.cancelable) e.preventDefault(); joyEnd(); }, {passive:false});

  // ---------- Combat ----------
  function nearestMobInRange(range){
    let best=null, bestD=1e9;
    for (const m of Mobs){
      if (m.hp<=0) continue;
      const d = dist(Player.x, Player.y, m.x, m.y);
      if (d<bestD){ bestD=d; best=m; }
    }
    if (!best) return null;
    return bestD <= range + best.r ? best : null;
  }

  function dealDamage(m, dmg, knock=120){
    m.hp = Math.max(0, m.hp - dmg);
    m.hitFlash = 0.12;

    const dx = m.x - Player.x;
    const dy = m.y - Player.y;
    const len = Math.hypot(dx,dy) || 1;
    m.knockX += (dx/len) * knock;
    m.knockY += (dy/len) * knock;

    if (m.hp<=0){
      Game.kills += 1;
      if (Math.random()<0.40){
        Inv.push({ name:"미감정 장비", desc:"기본공격 +1~3 (잠재: 미공개)" });
        toast("드랍: <b>미감정 장비</b>", 900);
      }
      syncHUD();
    }
  }

  function tryAttack(src="btn"){
    if (Player.atkTimer>0) return;
    Player.atkTimer = Player.atkCd;

    const target = nearestMobInRange(Player.atkRange);
    if (!target){ toast("헛손질", 450); return; }

    const dmg = Player.atk + (Math.random()<0.18 ? 10 : 0);
    dealDamage(target, dmg, target.kind==="boss" ? 80 : 140);
  }

  function resolvePlayerMobCollisions(){
    for (const m of Mobs){
      if (m.hp<=0) continue;
      const dx = Player.x - m.x;
      const dy = Player.y - m.y;
      const d = Math.hypot(dx,dy) || 0.0001;
      const minD = Player.r + m.r;
      if (d < minD){
        const push = (minD - d);
        const nx = dx / d;
        const ny = dy / d;
        Player.x += nx * push;
        Player.y += ny * push;
        m.x -= nx * (push*0.20);
        m.y -= ny * (push*0.20);
      }
    }
  }

  function moveMobs(dt){
    for (const m of Mobs){
      if (m.hp<=0) continue;
      m.phase += dt * (m.kind==="boss" ? 1.1 : 1.8);
      m.hitFlash = Math.max(0, m.hitFlash - dt);

      const kDamp=10;
      m.knockX = m.knockX * Math.max(0, 1 - kDamp*dt);
      m.knockY = m.knockY * Math.max(0, 1 - kDamp*dt);

      const dx = Player.x - m.x;
      const dy = Player.y - m.y;
      const d = Math.hypot(dx,dy) || 1;

      const desired = (m.kind==="boss") ? 80 : 60;
      const speed = m.spd * (d > desired ? 1.0 : 0.25);

      const nx = dx / d;
      const ny = dy / d;
      const wob = Math.sin(m.phase) * 0.35;

      m.x += (nx * speed + (-ny * wob * 18)) * dt + m.knockX * dt;
      m.y += (ny * speed + ( nx * wob * 18)) * dt + m.knockY * dt;
    }
  }

  // ---------- Buttons ----------
  bind(btnStage, "스테이지", startStage);
  bind(btnBoss, "보스", startBoss);
  bind(btnRespawn, "몹재생성", ()=>{ respawnMobs(); toast("몹 재생성", 800); });
  bind(btnReset, "리셋", resetAll);

  bind(btnAttack, "공격", ()=> tryAttack("btn"));
  bind(btnDash, "대시", ()=>{
    if (Player.dashCd>0){ toast("대시 쿨타임", 500); return; }
    Player.dashTime = 0.12;
    Player.dashCd = 0.75;
    toast("대시!", 500);
  });

  bind(btnToggleTarget, "오토타겟", ()=>{
    Game.autoTarget = !Game.autoTarget;
    btnToggleTarget.classList.toggle("on", Game.autoTarget);
    toast(`오토 타겟: <b>${Game.autoTarget?"ON":"OFF"}</b>`, 900);
  });
  bind(btnToggleAtk, "오토공격", ()=>{
    Game.autoAttack = !Game.autoAttack;
    btnToggleAtk.classList.toggle("on", Game.autoAttack);
    toast(`오토 공격: <b>${Game.autoAttack?"ON":"OFF"}</b>`, 900);
  });

  bind(btnPick, "줍기", ()=>{
    toast(Inv.length ? `줍기: <b>${Inv[Inv.length-1].name}</b>` : "줍기: 인벤 비어있음", 900);
    syncHUD();
  });

  // ---------- Loop ----------
  let last = now();
  let fpsAcc=0, fpsFrames=0;

  function update(dt){
    Game.stageTime += dt;
    const left = Math.max(0, Math.ceil(Game.timeLimit - Game.stageTime));
    const mm = String(Math.floor(left/60)).padStart(2,"0");
    const ss = String(left%60).padStart(2,"0");
    timerTxt.textContent = `제한: ${mm}:${ss}`;
    if (left<=0){ startStage(); return; }

    Player.atkTimer = Math.max(0, Player.atkTimer - dt);

    const mx = Joy.active ? Joy.x : 0;
    const my = Joy.active ? Joy.y : 0;
    const mlen = Math.hypot(mx,my);

    Player.dashTime = Math.max(0, Player.dashTime - dt);
    Player.dashCd   = Math.max(0, Player.dashCd - dt);
    const spd = Player.spd * (Player.dashTime>0 ? 2.4 : 1.0);

    const nx = mlen>1e-6 ? mx/mlen : 0;
    const ny = mlen>1e-6 ? my/mlen : 0;

    Player.x += nx * spd * dt;
    Player.y += ny * spd * dt;

    moveMobs(dt);
    resolvePlayerMobCollisions();

    // 죽은 몹 제거
    for (let i=Mobs.length-1;i>=0;i--){
      if (Mobs[i].hp<=0) Mobs.splice(i,1);
    }

    // 오토 공격
    if (Game.autoAttack){
      const t = nearestMobInRange(Player.atkRange);
      if (t && Player.atkTimer<=0) tryAttack("auto");
    }
  }

  function draw(){
    const w = window.innerWidth;
    const h = window.innerHeight;

    ctx.clearRect(0,0,w,h);
    drawBg(w,h);

    ctx.save();
    ctx.translate(w/2, h/2);

    // 몬스터 + HP바
    for (const m of Mobs){
      drawSpriteOrCircle(m.kind, m.x, m.y, m.r);

      const barW = Math.max(34, m.r*2.2);
      const barH = 6;
      const bx = m.x - barW/2;
      const by = m.y - m.r - 14;

      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.fillRect(bx, by, barW, barH);

      const hpRatio = m.hpMax>0 ? (m.hp/m.hpMax) : 0;
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.fillRect(bx, by, barW*hpRatio, barH);

      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.strokeRect(bx, by, barW, barH);
    }

    // 플레이어
    drawSpriteOrCircle("player", Player.x, Player.y, Player.r);

    // 공격 범위(희미)
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.beginPath();
    ctx.arc(Player.x, Player.y, Player.atkRange, 0, Math.PI*2);
    ctx.stroke();

    ctx.restore();
  }

  function loop(){
    const t = now();
    let dt = (t - last)/1000;
    last = t;
    dt = Math.min(0.05, Math.max(0, dt));

    fpsAcc += dt; fpsFrames++;
    if (fpsAcc >= 0.4){
      const fps = Math.round(fpsFrames / fpsAcc);
      fpsAcc = 0; fpsFrames = 0;
      fpsTxt.textContent = `FPS: ${fps}`;
    }

    update(dt);
    draw();
    updateToasts();
    requestAnimationFrame(loop);
  }

  // ---------- Start ----------
  syncHUD();
  toast("<b>v4.5 로딩</b>…", 900);

  preloadAssets().finally(()=>{
    startStage();
    toast("이미지는 <b>확장자 자동 탐색</b>으로 로드됨", 1400);
    loop();
  });

})();
</script>
</body>
</html>
