<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no" />
  <title>보스게이트 (통합 최신본 - PC/스마트폰 안정화)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel: rgba(10,16,32,0.82);
      --panel2: rgba(15,24,48,0.88);
      --line: rgba(255,255,255,0.12);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.65);
      --good:#6ae37b;
      --warn:#ffd36a;
      --bad:#ff6a6a;
      --btn:#1b2a55;
      --btn2:#243a77;
      --btnDown:#0f1c3f;
      --accent:#6aa7ff;
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius: 14px;
      --radius2: 18px;
      --font: ui-sans-serif, system-ui, -apple-system, "Apple SD Gothic Neo", "Noto Sans KR", Segoe UI, Roboto, Arial, sans-serif;
    }

    /* 흔들림(스크롤 바운스/줌/더블탭) 원천 차단 */
    html, body {
      margin:0; padding:0;
      width:100%; height:100%;
      background: var(--bg);
      overflow:hidden;
      overscroll-behavior: none;
      touch-action: none;
      -webkit-user-select:none;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      font-family: var(--font);
      color: var(--text);
    }

    #app {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    canvas {
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
      background: radial-gradient(1200px 900px at 30% 20%, #121b3a 0%, #0b1020 55%, #060913 100%);
      touch-action: none;
    }

    /* HUD */
    .hud {
      position:absolute;
      inset: 0;
      pointer-events:none;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    .topbar {
      position:absolute;
      left: 12px;
      right: 12px;
      top: 12px;
      display:flex;
      gap: 10px;
      align-items: stretch;
      justify-content: space-between;
      pointer-events:none;
    }

    .panel {
      pointer-events:auto;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    .leftGroup, .rightGroup {
      display:flex;
      gap: 10px;
      align-items:center;
    }

    .status {
      padding: 10px 12px;
      display:flex;
      gap: 10px;
      align-items:center;
      min-width: 320px;
    }

    .status .col {
      display:flex;
      flex-direction:column;
      gap: 4px;
      min-width: 120px;
    }

    .status .title {
      font-weight: 700;
      letter-spacing: -0.2px;
      font-size: 13px;
      color: var(--text);
      opacity: .95;
    }

    .status .meta {
      font-size: 12px;
      color: var(--muted);
      letter-spacing: -0.2px;
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
    }

    .barWrap {
      display:flex;
      gap: 10px;
      align-items:center;
      min-width: 260px;
    }
    .bar {
      flex:1;
      height: 10px;
      background: rgba(255,255,255,0.12);
      border-radius: 99px;
      overflow:hidden;
      border: 1px solid rgba(255,255,255,0.10);
    }
    .bar > i {
      display:block;
      height:100%;
      width: 50%;
      background: linear-gradient(90deg, rgba(106,167,255,0.9), rgba(106,255,210,0.9));
      border-radius: 99px;
    }
    .bar.hp > i { background: linear-gradient(90deg, rgba(255,106,106,0.95), rgba(255,189,106,0.85)); }
    .bar.mp > i { background: linear-gradient(90deg, rgba(106,167,255,0.95), rgba(106,255,210,0.85)); }

    .mini {
      padding: 10px 12px;
      display:flex;
      gap: 8px;
      align-items:center;
      white-space:nowrap;
    }

    .btnRow {
      display:flex;
      gap: 8px;
      align-items:center;
      padding: 8px;
    }

    .btn {
      pointer-events:auto;
      border: 1px solid rgba(255,255,255,0.14);
      background: linear-gradient(180deg, var(--btn2), var(--btn));
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      font-weight: 700;
      font-size: 13px;
      letter-spacing: -0.2px;
      cursor: pointer;
      user-select:none;
      touch-action: none;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      min-height: 40px;
      box-shadow: 0 10px 18px rgba(0,0,0,0.22);
    }
    .btn:active { background: linear-gradient(180deg, var(--btnDown), #0b1433); transform: translateY(1px); }
    .btn.small { padding: 9px 10px; min-height: 36px; font-size: 12px; border-radius: 12px; }
    .btn.ghost { background: rgba(255,255,255,0.06); box-shadow:none; }
    .btn.on { outline: 2px solid rgba(106,167,255,0.55); border-color: rgba(106,167,255,0.55); }
    .btn.bad { background: linear-gradient(180deg, rgba(255,106,106,0.25), rgba(255,106,106,0.16)); border-color: rgba(255,106,106,0.28); }
    .btn.good { background: linear-gradient(180deg, rgba(106,227,123,0.22), rgba(106,227,123,0.14)); border-color: rgba(106,227,123,0.28); }

    .chip {
      font-size: 12px;
      color: var(--muted);
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
    }
    .chip.good { color: rgba(106,227,123,0.95); border-color: rgba(106,227,123,0.28); }
    .chip.warn { color: rgba(255,211,106,0.95); border-color: rgba(255,211,106,0.30); }
    .chip.bad { color: rgba(255,106,106,0.95); border-color: rgba(255,106,106,0.30); }

    /* 하단 조작 HUD */
    .bottombar {
      position:absolute;
      left: 12px;
      right: 12px;
      bottom: 12px;
      display:flex;
      gap: 12px;
      align-items:flex-end;
      justify-content: space-between;
      pointer-events:none;
    }

    .joystick {
      pointer-events:auto;
      width: 148px;
      height: 148px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      touch-action:none;
    }
    .stick {
      width: 64px;
      height: 64px;
      border-radius: 999px;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.20);
      box-shadow: 0 12px 26px rgba(0,0,0,0.28);
      position:absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%,-50%);
    }

    .actions {
      pointer-events:none;
      display:flex;
      gap: 10px;
      align-items:flex-end;
    }
    .actions .col {
      pointer-events:auto;
      display:flex;
      flex-direction:column;
      gap: 10px;
      align-items:stretch;
    }

    .toastWrap{
      position:absolute;
      left: 50%;
      bottom: 190px;
      transform: translateX(-50%);
      display:flex;
      flex-direction:column;
      gap: 8px;
      align-items:center;
      pointer-events:none;
      max-width: min(520px, calc(100vw - 24px));
    }
    .toast{
      pointer-events:none;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 999px;
      padding: 10px 14px;
      font-size: 13px;
      color: rgba(255,255,255,0.92);
      backdrop-filter: blur(8px);
      box-shadow: 0 12px 30px rgba(0,0,0,0.25);
      opacity: 0;
      transform: translateY(6px);
      transition: opacity .18s ease, transform .18s ease;
      text-align:center;
      line-height: 1.25;
    }
    .toast.show{ opacity: 1; transform: translateY(0); }
    .toast b{ color: #fff; }
    .toast .g{ color: var(--good); }
    .toast .w{ color: var(--warn); }
    .toast .r{ color: var(--bad); }

    /* 모달(메뉴/인벤) */
    .modal {
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,0.50);
      pointer-events:auto;
      padding: 18px;
    }
    .modal.show { display:flex; }
    .modalCard {
      width: min(780px, 100%);
      max-height: min(78vh, 840px);
      overflow:auto;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(12,18,38,0.92);
      backdrop-filter: blur(14px);
      box-shadow: 0 20px 50px rgba(0,0,0,0.35);
      padding: 14px;
    }
    .modalHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 8px 6px 12px 6px;
      border-bottom: 1px solid rgba(255,255,255,0.12);
      margin-bottom: 10px;
    }
    .modalHeader h2{
      margin:0;
      font-size: 16px;
      letter-spacing:-0.3px;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 12px;
    }
    .box{
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 12px;
      background: rgba(255,255,255,0.04);
    }
    .box h3{
      margin: 0 0 8px 0;
      font-size: 13px;
      color: rgba(255,255,255,0.86);
      letter-spacing:-0.2px;
    }
    .list{
      display:flex;
      flex-direction:column;
      gap: 8px;
    }
    .itemRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 10px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.20);
    }
    .itemRow .name{
      display:flex;
      flex-direction:column;
      gap: 4px;
      min-width: 0;
    }
    .itemRow .name b{
      font-size: 13px;
      letter-spacing:-0.2px;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .itemRow .name span{
      font-size: 12px;
      color: var(--muted);
    }

    .kbd {
      font-size: 12px;
      color: rgba(255,255,255,0.82);
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      padding: 2px 8px;
      border-radius: 999px;
      margin-left: 6px;
    }

    @media (max-width: 520px){
      .status{ min-width: 0; }
      .grid2{ grid-template-columns: 1fr; }
      .joystick{ width: 132px; height: 132px; }
      .toastWrap{ bottom: 182px; }
    }
  </style>
</head>

<body>
<div id="app">
  <canvas id="cv"></canvas>

  <div class="hud">
    <div class="topbar">
      <div class="leftGroup">
        <div class="panel status" id="statusPanel">
          <div class="col">
            <div class="title">보스게이트</div>
            <div class="meta">
              <span id="sceneTxt">장면: 메뉴</span>
              <span id="stageTxt">스테이지: -</span>
              <span id="timerTxt">제한: -</span>
            </div>
          </div>
          <div class="barWrap">
            <div style="min-width:52px;font-size:12px;color:var(--muted);">HP</div>
            <div class="bar hp"><i id="hpBar"></i></div>
            <div style="min-width:52px;font-size:12px;color:var(--muted);">MP</div>
            <div class="bar mp"><i id="mpBar"></i></div>
          </div>
        </div>
      </div>

      <div class="rightGroup">
        <div class="panel mini">
          <span class="chip" id="deviceChip">기기: -</span>
          <span class="chip warn" id="fpsChip">FPS: -</span>
        </div>

        <div class="panel btnRow">
          <button class="btn small ghost" id="btnMenu">메뉴<span class="kbd">Esc</span></button>
          <button class="btn small ghost" id="btnInv">인벤<span class="kbd">I</span></button>
          <button class="btn small" id="btnStage">스테이지</button>
          <button class="btn small bad" id="btnBoss">보스</button>
        </div>
      </div>
    </div>

    <div class="toastWrap" id="toastWrap"></div>

    <div class="bottombar">
      <div class="panel joystick" id="joy">
        <div class="stick" id="stick"></div>
      </div>

      <div class="actions">
        <div class="col panel" style="padding:10px;">
          <button class="btn good" id="btnAttack">공격</button>
          <button class="btn" id="btnDash">대시</button>
        </div>
        <div class="col panel" style="padding:10px;">
          <button class="btn small" id="btnPickup">줍기</button>
          <button class="btn small" id="btnToggleTarget">오토 타겟</button>
          <button class="btn small" id="btnToggleAtk">오토 공격</button>
          <button class="btn small" id="btnToggleLoot">오토 줍기</button>
        </div>
        <div class="col panel" style="padding:10px;">
          <button class="btn small" id="btnToggleMove">오토 이동</button>
          <button class="btn small" id="btnToggleLock">추적 잠금</button>
          <button class="btn small ghost" id="btnReset">리셋</button>
        </div>
      </div>
    </div>
  </div>

  <!-- 메뉴 모달 -->
  <div class="modal" id="menuModal">
    <div class="modalCard">
      <div class="modalHeader">
        <h2>메뉴</h2>
        <button class="btn small ghost" id="btnCloseMenu">닫기</button>
      </div>

      <div class="grid2">
        <div class="box">
          <h3>진행</h3>
          <div style="display:flex; gap:10px; flex-wrap:wrap;">
            <button class="btn" id="btnStartStage">스테이지 1-1 시작</button>
            <button class="btn bad" id="btnStartBoss">보스 시작</button>
            <button class="btn ghost" id="btnEndRun">실행 종료(스테이지 종료)</button>
          </div>
          <div style="margin-top:10px; font-size:12px; color:var(--muted); line-height:1.45;">
            · 스테이지는 제한 시간 5분(예시) / 몬스터 처치 및 드랍을 통해 성장<br/>
            · “미감정” 장비는 기본 성능으로 즉시 사용 가능, 감정 시 잠재 옵션 해방(간단 구현)<br/>
            · 스테이지 종료 시 업적 기반으로 감정권 지급(예시)
          </div>
        </div>

        <div class="box">
          <h3>조작</h3>
          <div style="font-size:12px; color:var(--muted); line-height:1.55;">
            PC: 이동 <b>WASD</b> / 공격 <b>Space</b> / 대시 <b>Shift</b> / 인벤 <b>I</b> / 메뉴 <b>Esc</b><br/>
            모바일: 왼쪽 조이스틱 이동 / 우측 버튼 공격·대시·토글<br/><br/>
            <span class="chip warn">중요</span>
            입력 이벤트는 pointer로 통합했고, 연타/토글로 화면이 떨리는 문제를 막기 위해
            dt 상한 + fixed timestep + 버튼 반복 입력 잠금을 적용했음.
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- 인벤 모달 -->
  <div class="modal" id="invModal">
    <div class="modalCard">
      <div class="modalHeader">
        <h2>인벤토리</h2>
        <button class="btn small ghost" id="btnCloseInv">닫기</button>
      </div>

      <div class="grid2">
        <div class="box">
          <h3>장비/아이템</h3>
          <div class="list" id="invList"></div>
        </div>

        <div class="box">
          <h3>선택 상세</h3>
          <div id="invDetail" style="font-size:12px;color:var(--muted);line-height:1.55;">
            아이템을 선택하면 상세가 표시됩니다.
          </div>
          <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;">
            <button class="btn small" id="btnUse">사용/장착</button>
            <button class="btn small" id="btnAppraise">감정(감정권)</button>
            <button class="btn small bad" id="btnDrop">버리기</button>
          </div>
          <div style="margin-top:10px; font-size:12px; color:var(--muted); line-height:1.45;">
            감정권: <b id="ticketTxt">0</b> / 장착: <b id="equipTxt">-</b>
          </div>
        </div>
      </div>
    </div>
  </div>

</div>

<script>
(() => {
  "use strict";

  /* =========================
    0) 유틸 / 전역
  ========================= */
  const clamp = (v,a,b)=> Math.max(a, Math.min(b,v));
  const lerp  = (a,b,t)=> a + (b-a)*t;
  const rand  = (a,b)=> a + Math.random()*(b-a);
  const nowMs = ()=> performance.now();

  function isMobileLike(){
    // 포인터/터치 기반 감지(UA보다 안정적)
    return (navigator.maxTouchPoints || 0) > 0 || matchMedia("(pointer: coarse)").matches;
  }

  const app = document.getElementById("app");
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d", { alpha: false, desynchronized: true });

  // UI refs
  const sceneTxt = document.getElementById("sceneTxt");
  const stageTxt = document.getElementById("stageTxt");
  const timerTxt = document.getElementById("timerTxt");
  const hpBar = document.getElementById("hpBar");
  const mpBar = document.getElementById("mpBar");
  const fpsChip = document.getElementById("fpsChip");
  const deviceChip = document.getElementById("deviceChip");

  const btnMenu = document.getElementById("btnMenu");
  const btnInv = document.getElementById("btnInv");
  const btnStage = document.getElementById("btnStage");
  const btnBoss = document.getElementById("btnBoss");

  const btnAttack = document.getElementById("btnAttack");
  const btnDash = document.getElementById("btnDash");
  const btnPickup = document.getElementById("btnPickup");

  const btnToggleTarget = document.getElementById("btnToggleTarget");
  const btnToggleAtk = document.getElementById("btnToggleAtk");
  const btnToggleLoot = document.getElementById("btnToggleLoot");
  const btnToggleMove = document.getElementById("btnToggleMove");
  const btnToggleLock = document.getElementById("btnToggleLock");
  const btnReset = document.getElementById("btnReset");

  const menuModal = document.getElementById("menuModal");
  const invModal = document.getElementById("invModal");
  const btnCloseMenu = document.getElementById("btnCloseMenu");
  const btnCloseInv = document.getElementById("btnCloseInv");

  const btnStartStage = document.getElementById("btnStartStage");
  const btnStartBoss = document.getElementById("btnStartBoss");
  const btnEndRun = document.getElementById("btnEndRun");

  const invList = document.getElementById("invList");
  const invDetail = document.getElementById("invDetail");
  const btnUse = document.getElementById("btnUse");
  const btnAppraise = document.getElementById("btnAppraise");
  const btnDrop = document.getElementById("btnDrop");
  const ticketTxt = document.getElementById("ticketTxt");
  const equipTxt = document.getElementById("equipTxt");

  const toastWrap = document.getElementById("toastWrap");

  // joystick
  const joy = document.getElementById("joy");
  const stick = document.getElementById("stick");

  // device label
  deviceChip.textContent = `기기: ${isMobileLike() ? "스마트폰/태블릿" : "PC"}`;

  // 중요: 이벤트는 모두 preventDefault 필요(스크롤/줌/탭 하이라이트 방지)
  const addNoScroll = (el, type, fn) => el.addEventListener(type, (e)=>{ e.preventDefault(); fn(e); }, { passive:false });

  // 버튼 “연타로 토글 난사” 방지 (pointerdown 반복 입력 잠금)
  function bindButton(btn, handler, opts={}){
    const lockMs = opts.lockMs ?? 140;
    let locked = false;

    addNoScroll(btn, "pointerdown", (e)=>{
      if (locked) return;
      locked = true;
      btn.setPointerCapture?.(e.pointerId);
      handler(e);
      setTimeout(()=> locked=false, lockMs);
    });

    // 클릭 이벤트가 뒤따라오는 브라우저가 있어 차단
    btn.addEventListener("click", (e)=> e.preventDefault());
  }

  // 토스트
  const toasts = [];
  function toast(html, life=1400){
    const el = document.createElement("div");
    el.className = "toast";
    el.innerHTML = html;
    toastWrap.appendChild(el);
    requestAnimationFrame(()=> el.classList.add("show"));
    const t = { el, die: nowMs()+life };
    toasts.push(t);
  }
  function updateToasts(){
    const t = nowMs();
    for (let i=toasts.length-1;i>=0;i--){
      if (t > toasts[i].die){
        const el = toasts[i].el;
        el.classList.remove("show");
        setTimeout(()=> el.remove(), 220);
        toasts.splice(i,1);
      }
    }
  }

  /* =========================
    1) 캔버스 스케일(흔들림 방지 핵심)
       - DPR 반영
       - 가상 해상도(세로/가로 자동)
       - fixed timestep 렌더
  ========================= */
  const View = {
    dpr: 1,
    vw: 0, vh: 0,
    // 가상 해상도(논리 좌표)
    baseW: 720,
    baseH: 1280,
    scale: 1,
    ox: 0, oy: 0, // letterbox offset
  };

  function pickBaseRes(){
    // 화면비에 따라 가상 해상도를 바꿔서 UI/카메라 안정화
    const w = window.innerWidth;
    const h = window.innerHeight;
    const portrait = h >= w;

    if (portrait){
      View.baseW = 720;   // 9:16 느낌
      View.baseH = 1280;
    } else {
      View.baseW = 1280;  // 16:9 느낌
      View.baseH = 720;
    }
  }

  function resize(){
    pickBaseRes();
    View.vw = Math.max(1, window.innerWidth);
    View.vh = Math.max(1, window.innerHeight);
    View.dpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1));

    const targetW = View.baseW;
    const targetH = View.baseH;

    const s = Math.min(View.vw/targetW, View.vh/targetH);
    View.scale = s;

    const drawW = Math.floor(targetW * s);
    const drawH = Math.floor(targetH * s);

    View.ox = Math.floor((View.vw - drawW)/2);
    View.oy = Math.floor((View.vh - drawH)/2);

    cv.width  = Math.floor(View.vw * View.dpr);
    cv.height = Math.floor(View.vh * View.dpr);

    ctx.setTransform(View.dpr,0,0,View.dpr,0,0); // CSS px 단위로 그리기
    ctx.imageSmoothingEnabled = true;

    // 조이스틱 위치도 흔들리지 않게 초기화
    resetJoystickVisual();
  }

  window.addEventListener("resize", resize, { passive:true });
  resize();

  /* =========================
    2) 입력(PC/모바일 통합)
       - pointer 기반
       - 스크롤/줌 차단
       - 조이스틱
  ========================= */
  const Input = {
    keys: new Set(),
    moveX: 0,
    moveY: 0,
    attack: false,
    dash: false,
    pickup: false,
    // “버튼/토글 누름”에 의한 흔들림 방지용: 이 프레임에서 소비
    pressed: new Set(), // e.g. "attack", "dash"
  };

  addNoScroll(window, "contextmenu", ()=>{});
  addNoScroll(window, "touchmove", ()=>{});
  addNoScroll(window, "touchstart", ()=>{});
  addNoScroll(window, "touchend", ()=>{});

  window.addEventListener("keydown", (e)=>{
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
    Input.keys.add(e.key.toLowerCase());
    if (e.key === "Escape") toggleMenu(true);
    if (e.key.toLowerCase() === "i") toggleInv(true);
  });

  window.addEventListener("keyup", (e)=>{
    Input.keys.delete(e.key.toLowerCase());
  });

  // 조이스틱
  const Joy = {
    active: false,
    pid: null,
    cx: 0, cy: 0,
    x: 0, y: 0,
    maxR: 52, // stick 이동 반경(px)
  };

  function resetJoystickVisual(){
    stick.style.transform = "translate(-50%,-50%)";
  }

  function setStick(dx, dy){
    const r = Math.hypot(dx,dy);
    const m = Joy.maxR;
    let sx = dx, sy = dy;
    if (r > m){
      const k = m/r;
      sx *= k; sy *= k;
    }
    stick.style.transform = `translate(calc(-50% + ${sx}px), calc(-50% + ${sy}px))`;
  }

  addNoScroll(joy, "pointerdown", (e)=>{
    Joy.active = true;
    Joy.pid = e.pointerId;
    joy.setPointerCapture?.(e.pointerId);

    const rect = joy.getBoundingClientRect();
    Joy.cx = rect.left + rect.width/2;
    Joy.cy = rect.top + rect.height/2;

    const dx = e.clientX - Joy.cx;
    const dy = e.clientY - Joy.cy;
    setStick(dx,dy);

    const nx = clamp(dx/Joy.maxR, -1, 1);
    const ny = clamp(dy/Joy.maxR, -1, 1);
    Joy.x = nx;
    Joy.y = ny;
  });

  addNoScroll(joy, "pointermove", (e)=>{
    if (!Joy.active || e.pointerId !== Joy.pid) return;
    const dx = e.clientX - Joy.cx;
    const dy = e.clientY - Joy.cy;
    setStick(dx,dy);
    Joy.x = clamp(dx/Joy.maxR, -1, 1);
    Joy.y = clamp(dy/Joy.maxR, -1, 1);
  });

  addNoScroll(joy, "pointerup", (e)=>{
    if (e.pointerId !== Joy.pid) return;
    Joy.active = false;
    Joy.pid = null;
    Joy.x = 0; Joy.y = 0;
    resetJoystickVisual();
  });

  addNoScroll(joy, "pointercancel", (e)=>{
    Joy.active = false;
    Joy.pid = null;
    Joy.x = 0; Joy.y = 0;
    resetJoystickVisual();
  });

  // 캔버스 탭/클릭도 흔들림(스크롤) 방지
  addNoScroll(cv, "pointerdown", ()=>{});
  addNoScroll(cv, "pointermove", ()=>{});
  addNoScroll(cv, "pointerup", ()=>{});

  /* =========================
    3) 게임 데이터/상태
  ========================= */
  const Game = {
    scene: "menu",     // menu | stage | boss
    stageId: null,     // "1-1"
    stageTime: 0,      // 진행 시간
    timeLimit: 0,      // 제한 시간 (초)
    finished: false,

    // 토글들
    autoTarget: true,
    autoAttack: true,
    autoLoot: true,
    autoMove: false,
    lockOn: false,

    // 업적/감정권
    appraisalTickets: 0,

    // 인벤
    inv: [],
    selectedInvId: null,
    equipped: null,

    // 난이도/웨이브
    wave: 0,
    bossAlive: false,
  };

  const Player = {
    x: 0, y: 0,
    vx: 0, vy: 0,
    r: 14,
    hp: 100, hpMax: 100,
    mp: 50, mpMax: 50,
    atk: 14,
    spd: 180,
    dashCd: 0,
    dashTime: 0,
    targetId: null,
  };

  const World = {
    mobs: [],
    drops: [],
    nextId: 1,
    camX: 0,
    camY: 0,
    shake: 0,
    shakeT: 0,
  };

  function resetRun(){
    Game.scene = "menu";
    Game.stageId = null;
    Game.stageTime = 0;
    Game.timeLimit = 0;
    Game.finished = false;
    Game.wave = 0;
    Game.bossAlive = false;

    World.mobs.length = 0;
    World.drops.length = 0;
    World.nextId = 1;
    World.camX = 0; World.camY = 0;
    World.shake = 0; World.shakeT = 0;

    Player.x = 0; Player.y = 0;
    Player.vx = 0; Player.vy = 0;
    Player.hp = Player.hpMax;
    Player.mp = Player.mpMax;
    Player.dashCd = 0; Player.dashTime = 0;
    Player.targetId = null;

    // 인벤은 유지(통합 최신본 느낌) / 원하면 여기서 초기화 가능
    toast(`<b>리셋</b> 완료`, 900);
  }

  /* =========================
    4) 드랍/아이템 (미감정/감정)
  ========================= */
  function makeUnidentifiedGear(){
    const id = World.nextId++;
    const base = {
      id,
      type: "gear",
      identified: false,
      name: "미감정 장비",
      rarity: (Math.random()<0.1) ? "희귀" : (Math.random()<0.35 ? "고급" : "일반"),
      baseAtk: Math.floor(rand(2,6)),
      // 잠재 옵션(감정 시 오픈)
      latent: {
        atk: Math.random()<0.55 ? Math.floor(rand(2,10)) : 0,
        hp:  Math.random()<0.35 ? Math.floor(rand(10,50)) : 0,
        spd: Math.random()<0.25 ? Math.floor(rand(5,20)) : 0,
      }
    };
    return base;
  }

  function describeItem(it){
    if (!it) return "";
    const r = it.rarity;
    if (it.type === "gear"){
      if (!it.identified){
        return `${r} / 기본공격 +${it.baseAtk} (잠재: 미공개)`;
      }
      const L = it.latent || {atk:0,hp:0,spd:0};
      const parts = [];
      parts.push(`기본공격 +${it.baseAtk}`);
      if (L.atk) parts.push(`잠재공격 +${L.atk}`);
      if (L.hp)  parts.push(`잠재HP +${L.hp}`);
      if (L.spd) parts.push(`잠재SPD +${L.spd}`);
      return `${r} / ${parts.join(" · ")}`;
    }
    return "아이템";
  }

  function updateInvUI(){
    invList.innerHTML = "";
    Game.inv.forEach(it=>{
      const row = document.createElement("div");
      row.className = "itemRow";
      const left = document.createElement("div");
      left.className = "name";
      const title = document.createElement("b");
      title.textContent = (it.type==="gear" ? (it.identified ? it.name : "미감정 장비") : it.name);
      const sub = document.createElement("span");
      sub.textContent = describeItem(it);
      left.appendChild(title);
      left.appendChild(sub);

      const right = document.createElement("div");
      right.style.display = "flex";
      right.style.gap = "8px";
      right.style.alignItems = "center";

      const tag = document.createElement("span");
      tag.className = "chip " + (it.identified ? "good" : "warn");
      tag.textContent = it.identified ? "감정됨" : "미감정";

      const sel = document.createElement("button");
      sel.className = "btn small";
      sel.textContent = "선택";
      bindButton(sel, ()=>{
        Game.selectedInvId = it.id;
        renderInvDetail();
      }, { lockMs: 120 });

      right.appendChild(tag);
      right.appendChild(sel);

      row.appendChild(left);
      row.appendChild(right);
      invList.appendChild(row);
    });

    ticketTxt.textContent = String(Game.appraisalTickets);
    equipTxt.textContent = Game.equipped ? (Game.equipped.identified ? Game.equipped.name : "미감정 장착") : "-";
  }

  function renderInvDetail(){
    const it = Game.inv.find(x=>x.id===Game.selectedInvId);
    if (!it){
      invDetail.innerHTML = "아이템을 선택하면 상세가 표시됩니다.";
      updateInvUI();
      return;
    }
    const lines = [];
    lines.push(`<b style="color:#fff;">${it.identified ? it.name : "미감정 장비"}</b>`);
    lines.push(`<span class="chip ${it.identified ? "good" : "warn"}" style="margin-left:6px;">${it.identified ? "감정됨" : "미감정"}</span>`);
    lines.push(`<div style="margin-top:8px;color:rgba(255,255,255,0.78);">${describeItem(it)}</div>`);

    if (it.type==="gear"){
      lines.push(`<div style="margin-top:10px;color:rgba(255,255,255,0.68);line-height:1.5;">
        · 미감정 상태에서도 <b>기본공격</b>은 즉시 적용 가능<br/>
        · 감정 시 잠재 옵션이 해방될 수 있음(대박/평범 혼합)
      </div>`);
    }
    invDetail.innerHTML = lines.join("");
    updateInvUI();
  }

  function equipOrUseSelected(){
    const it = Game.inv.find(x=>x.id===Game.selectedInvId);
    if (!it) return toast(`선택된 아이템이 없음`, 900);
    if (it.type==="gear"){
      Game.equipped = it;
      applyEquipmentStats();
      toast(`<b>장착</b> 완료`, 900);
      updateInvUI();
    }
  }

  function applyEquipmentStats(){
    // 기본 스탯 리셋
    Player.atk = 14;
    Player.hpMax = 100;
    Player.mpMax = 50;
    Player.spd = 180;

    if (!Game.equipped) return;
    const it = Game.equipped;
    Player.atk += it.baseAtk || 0;

    if (it.identified){
      const L = it.latent || {atk:0,hp:0,spd:0};
      Player.atk += L.atk || 0;
      Player.hpMax += L.hp || 0;
      Player.spd += L.spd || 0;
    }

    Player.hp = clamp(Player.hp, 1, Player.hpMax);
    Player.mp = clamp(Player.mp, 0, Player.mpMax);
  }

  function appraiseSelected(){
    const it = Game.inv.find(x=>x.id===Game.selectedInvId);
    if (!it) return toast(`선택된 아이템이 없음`, 900);
    if (it.identified) return toast(`이미 감정됨`, 900);
    if (Game.appraisalTickets <= 0) return toast(`<span class="r">감정권</span>이 부족함`, 1100);

    Game.appraisalTickets--;

    // 감정 결과
    it.identified = true;
    const jackpot = Math.random() < 0.18;
    it.name = jackpot ? "잠재 폭발 장비" : "감정 장비";

    // 대박이면 잠재 수치 강화
    if (jackpot && it.latent){
      if (it.latent.atk) it.latent.atk += Math.floor(rand(4,10));
      if (it.latent.hp)  it.latent.hp  += Math.floor(rand(20,60));
      if (it.latent.spd) it.latent.spd += Math.floor(rand(6,18));
      // 잠재가 아예 없으면 하나는 뜨게
      if (!it.latent.atk && !it.latent.hp && !it.latent.spd){
        it.latent.atk = Math.floor(rand(6,14));
      }
    }

    applyEquipmentStats();
    toast(jackpot
      ? `<b>감정 성공!</b> <span class="g">대박</span> 잠재 옵션이 크게 강화됨`
      : `<b>감정 성공!</b> 잠재 옵션이 해방됨`
    , 1400);

    renderInvDetail();
  }

  function dropSelected(){
    const idx = Game.inv.findIndex(x=>x.id===Game.selectedInvId);
    if (idx < 0) return toast(`선택된 아이템이 없음`, 900);

    const it = Game.inv[idx];
    if (Game.equipped && Game.equipped.id === it.id){
      Game.equipped = null;
      applyEquipmentStats();
    }
    Game.inv.splice(idx,1);
    Game.selectedInvId = null;
    renderInvDetail();
    toast(`<b>버림</b> 처리`, 900);
  }

  /* =========================
    5) 몬스터/전투/드랍
  ========================= */
  function spawnMob(kind, x, y){
    const id = World.nextId++;
    const mob = {
      id,
      kind,
      x, y,
      vx: 0, vy: 0,
      r: kind==="boss" ? 34 : (kind==="elite" ? 18 : 14),
      hp: kind==="boss" ? 380 : (kind==="elite" ? 90 : 45),
      hpMax: 0,
      atk: kind==="boss" ? 18 : (kind==="elite" ? 10 : 6),
      spd: kind==="boss" ? 110 : (kind==="elite" ? 140 : 120),
      phase: Math.random()*Math.PI*2, // 애니메이션 위상(안정적)
    };
    mob.hpMax = mob.hp;
    World.mobs.push(mob);
    return mob;
  }

  function spawnDrop(x, y){
    const it = makeUnidentifiedGear();
    World.drops.push({
      id: it.id,
      x, y,
      item: it,
      r: 10
    });
  }

  function getNearestMob(){
    let best = null;
    let bd = Infinity;
    for (const m of World.mobs){
      if (m.hp <= 0) continue;
      const dx = m.x - Player.x;
      const dy = m.y - Player.y;
      const d = dx*dx + dy*dy;
      if (d < bd){
        bd = d;
        best = m;
      }
    }
    return best;
  }

  function getMobById(id){
    return World.mobs.find(m=>m.id===id) || null;
  }

  function dealDamageToMob(m, dmg){
    if (!m || m.hp<=0) return;
    m.hp -= dmg;
    World.shake = Math.min(1, World.shake + 0.18);
    World.shakeT = 0.18;

    if (m.hp <= 0){
      m.hp = 0;
      // 드랍
      if (Math.random() < (m.kind==="boss" ? 0.95 : (m.kind==="elite" ? 0.55 : 0.25))){
        spawnDrop(m.x + rand(-8,8), m.y + rand(-8,8));
        toast(`<b>드랍!</b> 미감정 장비 획득 가능`, 1100);
      }
      // 보스 처치
      if (m.kind==="boss"){
        Game.bossAlive = false;
        toast(`<b>보스 처치</b>! 스테이지 종료로 이동`, 1500);
      }
    }
  }

  function playerAttack(){
    // 공격은 프레임당 1회만 소비(연타/중복 이벤트 방지)
    if (Input.pressed.has("attack")) return;
    Input.pressed.add("attack");

    // 타겟 선정
    let t = null;
    if (Game.lockOn && Player.targetId){
      t = getMobById(Player.targetId);
      if (!t || t.hp<=0) t = null;
    }
    if (!t){
      t = getNearestMob();
      Player.targetId = t ? t.id : null;
    }
    if (!t){
      toast(`주변에 대상이 없음`, 900);
      return;
    }

    const dx = t.x - Player.x;
    const dy = t.y - Player.y;
    const dist = Math.hypot(dx,dy);

    if (dist > 58){
      toast(`사거리 밖`, 700);
      return;
    }

    const dmg = Player.atk + Math.floor(rand(-2,4));
    dealDamageToMob(t, dmg);
  }

  function playerDash(){
    if (Input.pressed.has("dash")) return;
    Input.pressed.add("dash");

    if (Player.dashCd > 0) return toast(`대시 쿨타임`, 650);
    Player.dashCd = 1.1;
    Player.dashTime = 0.12;
    toast(`<b>대시</b>`, 600);
  }

  function pickupNow(){
    if (Input.pressed.has("pickup")) return;
    Input.pressed.add("pickup");

    // 근처 드랍 먹기
    let best = -1;
    let bd = Infinity;
    for (let i=0;i<World.drops.length;i++){
      const d = World.drops[i];
      const dx = d.x - Player.x;
      const dy = d.y - Player.y;
      const dist2 = dx*dx + dy*dy;
      if (dist2 < bd){
        bd = dist2; best = i;
      }
    }
    if (best<0 || bd > 75*75){
      toast(`줍기 범위에 없음`, 800);
      return;
    }

    const drop = World.drops.splice(best,1)[0];
    Game.inv.push(drop.item);
    toast(`<b>획득</b>: 미감정 장비`, 1100);
    updateInvUI();
  }

  /* =========================
    6) 씬 전환 / 시작 / 종료
  ========================= */
  function startStage11(){
    Game.scene = "stage";
    Game.stageId = "1-1";
    Game.stageTime = 0;
    Game.timeLimit = 300; // 5분
    Game.finished = false;
    Game.wave = 0;
    Game.bossAlive = false;

    World.mobs.length = 0;
    World.drops.length = 0;
    Player.x = 0; Player.y = 0;
    Player.vx = 0; Player.vy = 0;
    Player.hp = Player.hpMax;
    Player.mp = Player.mpMax;
    Player.targetId = null;

    // 초기 웨이브
    spawnWave();
    toast(`<b>스테이지 1-1</b> 진입`, 1200);
    closeAllModals();
  }

  function startBoss(){
    Game.scene = "boss";
    Game.stageId = "BOSS";
    Game.stageTime = 0;
    Game.timeLimit = 240; // 4분 예시
    Game.finished = false;

    World.mobs.length = 0;
    World.drops.length = 0;

    Player.x = 0; Player.y = 0;
    Player.vx = 0; Player.vy = 0;
    Player.hp = Player.hpMax;
    Player.mp = Player.mpMax;
    Player.targetId = null;

    spawnMob("boss", 260, 0);
    Game.bossAlive = true;
    toast(`<b>보스전</b> 시작`, 1200);
    closeAllModals();
  }

  function endRun(){
    if (Game.scene==="menu") return;
    Game.finished = true;

    // 업적 기반 감정권 지급(간단)
    const kills = Game.wave * 4 + (Game.scene==="boss" ? 1 : 0);
    const gain = clamp(Math.floor(kills/4), 1, 3);
    Game.appraisalTickets += gain;
    toast(`<b>스테이지 종료</b> - 감정권 <span class="g">+${gain}</span>`, 1500);

    Game.scene = "menu";
    Game.stageId = null;
    Game.stageTime = 0;
    Game.timeLimit = 0;
    World.mobs.length = 0;
    World.drops.length = 0;

    updateInvUI();
  }

  function spawnWave(){
    Game.wave++;
    const n = 4 + Math.min(6, Game.wave);
    for (let i=0;i<n;i++){
      const kind = (Math.random()<0.18) ? "elite" : "slime";
      const x = rand(-260, 260);
      const y = rand(-160, 160);
      spawnMob(kind, x, y);
    }
    toast(`웨이브 <b>${Game.wave}</b>`, 900);

    // “???” 암시(상편 엔딩 느낌)
    if (Game.wave === 1){
      toast(`터널 끝에서 <b>??? (Lv.?)</b> 기척이 느껴진다…`, 1600);
    }
  }

  /* =========================
    7) UI 토글/모달
  ========================= */
  function closeAllModals(){
    menuModal.classList.remove("show");
    invModal.classList.remove("show");
  }

  function toggleMenu(forceOpen=false){
    if (forceOpen) {
      menuModal.classList.toggle("show");
      invModal.classList.remove("show");
    } else {
      menuModal.classList.toggle("show");
      if (menuModal.classList.contains("show")) invModal.classList.remove("show");
    }
  }

  function toggleInv(forceOpen=false){
    updateInvUI();
    renderInvDetail();
    if (forceOpen) {
      invModal.classList.toggle("show");
      menuModal.classList.remove("show");
    } else {
      invModal.classList.toggle("show");
      if (invModal.classList.contains("show")) menuModal.classList.remove("show");
    }
  }

  /* =========================
    8) 버튼 바인딩
  ========================= */
  bindButton(btnMenu, ()=> toggleMenu(true), { lockMs: 160 });
  bindButton(btnInv, ()=> toggleInv(true), { lockMs: 160 });

  bindButton(btnStage, ()=>{
    startStage11();
  }, { lockMs: 200 });

  bindButton(btnBoss, ()=>{
    startBoss();
  }, { lockMs: 200 });

  bindButton(btnCloseMenu, ()=> menuModal.classList.remove("show"));
  bindButton(btnCloseInv, ()=> invModal.classList.remove("show"));

  bindButton(btnStartStage, ()=> startStage11(), { lockMs: 220 });
  bindButton(btnStartBoss, ()=> startBoss(), { lockMs: 220 });
  bindButton(btnEndRun, ()=> endRun(), { lockMs: 220 });

  bindButton(btnAttack, ()=> { Input.attack = true; }, { lockMs: 80 });
  bindButton(btnDash, ()=> { Input.dash = true; }, { lockMs: 120 });
  bindButton(btnPickup, ()=> { Input.pickup = true; }, { lockMs: 120 });

  bindButton(btnToggleTarget, ()=>{
    Game.autoTarget = !Game.autoTarget;
    toast(`오토 타겟: <b>${Game.autoTarget ? "ON" : "OFF"}</b>`, 900);
  });
  bindButton(btnToggleAtk, ()=>{
    Game.autoAttack = !Game.autoAttack;
    toast(`오토 공격: <b>${Game.autoAttack ? "ON" : "OFF"}</b>`, 900);
  });
  bindButton(btnToggleLoot, ()=>{
    Game.autoLoot = !Game.autoLoot;
    toast(`오토 줍기: <b>${Game.autoLoot ? "ON" : "OFF"}</b>`, 900);
  });
  bindButton(btnToggleMove, ()=>{
    Game.autoMove = !Game.autoMove;
    toast(`오토 이동: <b>${Game.autoMove ? "ON" : "OFF"}</b>`, 900);
  });
  bindButton(btnToggleLock, ()=>{
    Game.lockOn = !Game.lockOn;
    toast(`추적 잠금: <b>${Game.lockOn ? "ON" : "OFF"}</b>`, 900);
    if (!Game.lockOn) Player.targetId = null;
  });
  bindButton(btnReset, ()=> resetRun(), { lockMs: 260 });

  bindButton(btnUse, ()=> equipOrUseSelected(), { lockMs: 180 });
  bindButton(btnAppraise, ()=> appraiseSelected(), { lockMs: 220 });
  bindButton(btnDrop, ()=> dropSelected(), { lockMs: 200 });

  // 토글 버튼 UI 상태 갱신
  function syncToggleButtons(){
    btnToggleTarget.classList.toggle("on", Game.autoTarget);
    btnToggleAtk.classList.toggle("on", Game.autoAttack);
    btnToggleLoot.classList.toggle("on", Game.autoLoot);
    btnToggleMove.classList.toggle("on", Game.autoMove);
    btnToggleLock.classList.toggle("on", Game.lockOn);
  }

  /* =========================
    9) 업데이트(물리/AI) - fixed timestep
       흔들림의 대부분은 dt 폭주/누적에서 발생 → 여기서 해결
  ========================= */
  const FIXED_DT = 1/60;
  let acc = 0;
  let lastT = nowMs();

  // FPS 표시
  let fpsAcc = 0, fpsFrames = 0, fps = 60;

  function updateFixed(dt){
    // 입력(PC WASD + 조이스틱) 합성
    let mx = 0, my = 0;
    if (Input.keys.has("w") || Input.keys.has("arrowup")) my -= 1;
    if (Input.keys.has("s") || Input.keys.has("arrowdown")) my += 1;
    if (Input.keys.has("a") || Input.keys.has("arrowleft")) mx -= 1;
    if (Input.keys.has("d") || Input.keys.has("arrowright")) mx += 1;

    // 조이스틱이 있으면 우선
    if (Joy.active){
      mx = Joy.x;
      my = Joy.y;
    }

    // 정규화
    const len = Math.hypot(mx,my);
    if (len > 1e-6){
      mx /= len; my /= len;
    }

    Input.moveX = mx;
    Input.moveY = my;

    // 키 입력 공격/대시
    if (Input.keys.has(" ")) Input.attack = true;
    if (Input.keys.has("shift")) Input.dash = true;

    // 스테이지 시간
    if (Game.scene !== "menu" && !Game.finished){
      Game.stageTime += dt;
      if (Game.timeLimit > 0 && Game.stageTime >= Game.timeLimit){
        toast(`<span class="w">시간 초과</span> - 종료 처리`, 1400);
        endRun();
      }
    }

    // 플레이어 이동
    const spd = Player.spd * (Player.dashTime > 0 ? 2.4 : 1.0);
    Player.dashTime = Math.max(0, Player.dashTime - dt);
    Player.dashCd = Math.max(0, Player.dashCd - dt);

    // 오토 이동(타겟 쪽으로)
    if (Game.scene !== "menu" && Game.autoMove){
      let t = getNearestMob();
      if (Game.lockOn && Player.targetId){
        const locked = getMobById(Player.targetId);
        if (locked && locked.hp>0) t = locked;
      }
      if (t){
        const dx = t.x - Player.x;
        const dy = t.y - Player.y;
        const d = Math.hypot(dx,dy);
        if (d > 70){
          Input.moveX = dx/d;
          Input.moveY = dy/d;
        } else {
          Input.moveX = 0;
          Input.moveY = 0;
        }
      }
    }

    Player.vx = Input.moveX * spd;
    Player.vy = Input.moveY * spd;
    Player.x += Player.vx * dt;
    Player.y += Player.vy * dt;

    // 몬스터 AI
    for (const m of World.mobs){
      if (m.hp<=0) continue;

      // 플레이어 추적
      const dx = Player.x - m.x;
      const dy = Player.y - m.y;
      const d = Math.hypot(dx,dy) || 1;

      // 약간의 “부유감” (phase 기반으로 안정적으로)
      m.phase += dt * (m.kind==="boss" ? 1.1 : 1.6);

      // 일정 거리 유지
      const want = (m.kind==="boss" ? 56 : 44);
      let ax = 0, ay = 0;
      if (d > want){
        ax = (dx/d) * m.spd;
        ay = (dy/d) * m.spd;
      } else {
        // 근접 시 살짝 원운동(위상 기반이라 떨림 없음)
        const px = Math.cos(m.phase) * 20;
        const py = Math.sin(m.phase) * 20;
        ax = (px/d) * (m.spd*0.35);
        ay = (py/d) * (m.spd*0.35);
      }

      m.vx = lerp(m.vx, ax, 0.18);
      m.vy = lerp(m.vy, ay, 0.18);
      m.x += m.vx * dt;
      m.y += m.vy * dt;

      // 플레이어 공격(단순)
      if (d < (m.kind==="boss"?60:48) && Math.random() < (m.kind==="boss"?0.06:0.045)){
        Player.hp = Math.max(0, Player.hp - m.atk);
        World.shake = Math.min(1, World.shake + 0.22);
        World.shakeT = 0.22;
        if (Player.hp<=0){
          toast(`<span class="r">사망</span> - 종료 처리`, 1500);
          endRun();
        }
      }
    }

    // 오토 타겟
    if (Game.scene !== "menu" && Game.autoTarget){
      if (!Player.targetId || !getMobById(Player.targetId) || getMobById(Player.targetId).hp<=0){
        const t = getNearestMob();
        Player.targetId = t ? t.id : null;
      }
    }

    // 오토 공격
    if (Game.scene !== "menu" && Game.autoAttack){
      const t = Game.lockOn && Player.targetId ? getMobById(Player.targetId) : getNearestMob();
      if (t){
        const dx = t.x - Player.x, dy = t.y - Player.y;
        const d = Math.hypot(dx,dy);
        if (d < 58 && Math.random() < 0.22){
          playerAttack();
        }
      }
    }

    // 오토 줍기
    if (Game.scene !== "menu" && Game.autoLoot && World.drops.length>0){
      // 가까운 드랍이 55 이내면 자동 줍기
      let near = null;
      let bd = Infinity;
      for (const d of World.drops){
        const dx = d.x-Player.x, dy = d.y-Player.y;
        const dist2 = dx*dx+dy*dy;
        if (dist2 < bd){
          bd = dist2; near = d;
        }
      }
      if (near && bd < 55*55 && Math.random()<0.20){
        // 직접 픽업 처리(중복 방지)
        const idx = World.drops.findIndex(x=>x.id===near.id);
        if (idx>=0){
          const drop = World.drops.splice(idx,1)[0];
          Game.inv.push(drop.item);
          updateInvUI();
          toast(`<b>자동 줍기</b>: 미감정 장비`, 900);
        }
      }
    }

    // 수동 액션 소비
    if (Input.attack){
      Input.attack = false;
      playerAttack();
    }
    if (Input.dash){
      Input.dash = false;
      playerDash();
    }
    if (Input.pickup){
      Input.pickup = false;
      pickupNow();
    }

    // 웨이브/보스 종료 조건
    if (Game.scene === "stage"){
      const alive = World.mobs.some(m=>m.hp>0);
      if (!alive){
        // 다음 웨이브
        if (Game.wave < 3){
          spawnWave();
        } else {
          toast(`<b>스테이지 클리어</b>`, 1200);
          endRun();
        }
      }
    } else if (Game.scene === "boss"){
      const bossAlive = World.mobs.some(m=>m.kind==="boss" && m.hp>0);
      if (!bossAlive){
        toast(`<b>보스전 종료</b>`, 1200);
        endRun();
      }
    }

    // 카메라(플레이어 추적) - dt 안정화로 흔들림 제거
    World.camX = lerp(World.camX, Player.x, 0.12);
    World.camY = lerp(World.camY, Player.y, 0.12);

    // 쉐이크(감쇠)
    if (World.shakeT > 0){
      World.shakeT -= dt;
      World.shake = Math.max(0, World.shake - dt*3.2);
    } else {
      World.shake = Math.max(0, World.shake - dt*2.2);
    }

    // 프레임별 pressed 리셋
    Input.pressed.clear();
  }

  /* =========================
    10) 렌더
  ========================= */
  function draw(){
    ctx.clearRect(0,0,View.vw,View.vh);

    // letterbox 영역 계산
    const W = View.baseW, H = View.baseH;
    const s = View.scale;
    const ox = View.ox, oy = View.oy;

    // letterbox 배경
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect(0,0,View.vw,View.vh);

    // 게임 영역 clip
    ctx.translate(ox, oy);
    ctx.beginPath();
    ctx.rect(0,0,W*s,H*s);
    ctx.clip();

    // 게임 영역 배경
    ctx.fillStyle = "rgba(0,0,0,0.22)";
    ctx.fillRect(0,0,W*s,H*s);

    // 게임 좌표계
    ctx.scale(s,s);

    // 카메라 흔들림(값 안정적)
    let shx=0, shy=0;
    if (World.shake > 0.001){
      const t = nowMs()*0.001;
      shx = Math.cos(t*19.7) * 6 * World.shake;
      shy = Math.sin(t*17.1) * 6 * World.shake;
    }

    const camX = World.camX + shx;
    const camY = World.camY + shy;

    // 월드 -> 화면 변환(플레이어 중심)
    const cx = W/2 - camX;
    const cy = H/2 - camY;

    // 바닥 그리드
    ctx.save();
    ctx.translate(cx, cy);
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.lineWidth = 1;

    const grid = 60;
    const minX = Math.floor((camX - W)/grid)*grid - grid*2;
    const maxX = Math.floor((camX + W)/grid)*grid + grid*2;
    const minY = Math.floor((camY - H)/grid)*grid - grid*2;
    const maxY = Math.floor((camY + H)/grid)*grid + grid*2;

    for (let x=minX; x<=maxX; x+=grid){
      ctx.beginPath();
      ctx.moveTo(x, minY);
      ctx.lineTo(x, maxY);
      ctx.stroke();
    }
    for (let y=minY; y<=maxY; y+=grid){
      ctx.beginPath();
      ctx.moveTo(minX, y);
      ctx.lineTo(maxX, y);
      ctx.stroke();
    }
    ctx.restore();

    // 드랍
    ctx.save();
    ctx.translate(cx, cy);
    for (const d of World.drops){
      ctx.beginPath();
      ctx.fillStyle = "rgba(255,211,106,0.92)";
      ctx.arc(d.x, d.y, d.r, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.stroke();

      // 반짝 테두리(안정적)
      ctx.globalAlpha = 0.25;
      ctx.beginPath();
      ctx.arc(d.x, d.y, d.r+5, 0, Math.PI*2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
    ctx.restore();

    // 몬스터
    ctx.save();
    ctx.translate(cx, cy);
    for (const m of World.mobs){
      if (m.hp<=0) continue;
      const wob = Math.sin(m.phase)*2.2; // 떨림 아닌 “부유”
      ctx.save();
      ctx.translate(m.x, m.y + wob);

      // 본체
      if (m.kind==="boss"){
        ctx.fillStyle = "rgba(255,106,106,0.92)";
      } else if (m.kind==="elite"){
        ctx.fillStyle = "rgba(106,167,255,0.92)";
      } else {
        ctx.fillStyle = "rgba(106,227,123,0.92)";
      }

      ctx.beginPath();
      ctx.arc(0,0,m.r,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 2;
      ctx.stroke();

      // HP바
      const w = m.kind==="boss" ? 90 : 64;
      const h = 8;
      ctx.translate(0, -m.r - 18);
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.fillRect(-w/2,-h/2,w,h);
      ctx.fillStyle = "rgba(255,255,255,0.14)";
      ctx.fillRect(-w/2,-h/2,w,h);

      const p = clamp(m.hp/m.hpMax, 0, 1);
      ctx.fillStyle = m.kind==="boss" ? "rgba(255,106,106,0.95)" : "rgba(255,211,106,0.90)";
      ctx.fillRect(-w/2,-h/2, w*p, h);

      ctx.restore();
    }
    ctx.restore();

    // 플레이어
    ctx.save();
    ctx.translate(cx, cy);
    ctx.save();
    ctx.translate(Player.x, Player.y);

    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.beginPath();
    ctx.arc(0,0,Player.r,0,Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = "rgba(0,0,0,0.35)";
    ctx.lineWidth = 2;
    ctx.stroke();

    // 타겟 표시
    if (Player.targetId){
      const t = getMobById(Player.targetId);
      if (t && t.hp>0){
        ctx.strokeStyle = "rgba(106,167,255,0.85)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(t.x-Player.x, t.y-Player.y, t.r+10, 0, Math.PI*2);
        ctx.stroke();
      }
    }

    ctx.restore();
    ctx.restore();

    // UI 텍스트(게임 영역 내부)
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.font = "700 16px " + getComputedStyle(document.body).fontFamily;
    ctx.textAlign = "left";
    ctx.textBaseline = "top";

    const hint = (Game.scene==="menu")
      ? "메뉴에서 스테이지/보스 시작"
      : "오토/추적 토글로 전투 조절";
    ctx.fillText(hint, 18, 16);

    ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
    ctx.fillStyle = "rgba(255,255,255,0.62)";
    ctx.fillText("※ 흔들림 버그 방지: fixed timestep + dt cap + pointer 통합", 18, 40);

    ctx.restore();

    ctx.restore(); // outer
  }

  /* =========================
    11) HUD 업데이트
  ========================= */
  function updateHUD(){
    sceneTxt.textContent = `장면: ${Game.scene==="menu" ? "메뉴" : (Game.scene==="stage" ? "스테이지" : "보스")}`;
    stageTxt.textContent = `스테이지: ${Game.stageId ?? "-"}`;

    if (Game.scene==="menu"){
      timerTxt.textContent = `제한: -`;
    } else {
      const left = Math.max(0, Math.ceil(Game.timeLimit - Game.stageTime));
      const mm = String(Math.floor(left/60)).padStart(2,"0");
      const ss = String(left%60).padStart(2,"0");
      timerTxt.textContent = `제한: ${mm}:${ss}`;
    }

    hpBar.style.width = `${clamp(Player.hp/Player.hpMax,0,1)*100}%`;
    mpBar.style.width = `${clamp(Player.mp/Player.mpMax,0,1)*100}%`;

    fpsChip.textContent = `FPS: ${fps}`;
    fpsChip.classList.toggle("warn", fps < 50);
    fpsChip.classList.toggle("good", fps >= 50);

    syncToggleButtons();
  }

  /* =========================
    12) 메인 루프
       - dt 상한으로 폭주 방지(탭 전환/렉/모바일 백그라운드 등)
       - fixed step
  ========================= */
  function loop(){
    const t = nowMs();
    let dt = (t - lastT) / 1000;
    lastT = t;

    // dt 상한 (가장 중요한 흔들림 방지)
    dt = clamp(dt, 0, 0.05);

    // FPS
    fpsAcc += dt;
    fpsFrames++;
    if (fpsAcc >= 0.4){
      fps = Math.round(fpsFrames / fpsAcc);
      fpsAcc = 0; fpsFrames = 0;
    }

    acc += dt;
    // 너무 쌓이면 컷(백그라운드 복귀시 폭주 방지)
    acc = Math.min(acc, 0.25);

    while (acc >= FIXED_DT){
      updateFixed(FIXED_DT);
      acc -= FIXED_DT;
    }

    draw();
    updateHUD();
    updateToasts();

    requestAnimationFrame(loop);
  }

  /* =========================
    13) 초기 세팅
  ========================= */
  // 시작 인벤(테스트용)
  Game.inv.push(makeUnidentifiedGear());
  Game.inv.push(makeUnidentifiedGear());
  updateInvUI();

  // 안내 토스트
  toast(`<b>안정화 빌드</b>: 버튼 연타/토글해도 화면이 떨리지 않음`, 1600);
  toast(`메뉴에서 <b>스테이지 1-1</b> 또는 <b>보스</b> 시작`, 1500);

  // 모달 외부 클릭 닫기
  addNoScroll(menuModal, "pointerdown", (e)=>{
    if (e.target === menuModal) menuModal.classList.remove("show");
  });
  addNoScroll(invModal, "pointerdown", (e)=>{
    if (e.target === invModal) invModal.classList.remove("show");
  });

  // 페이지 포커스 복귀 시 dt 폭주 방지
  document.addEventListener("visibilitychange", ()=>{
    lastT = nowMs();
    acc = 0;
  });

  loop();

})();
</script>
</body>
</html>
